CCS PCD C Compiler, Version 5.015, 5967               18-Jun-19 06:31

               Filename:   D:\Do An Tot Nghiep\Code Module SIM M95\Code MPLabIDE 8.92\PIC24EP512GP806\M95\M95.lst

               ROM used:   17386 bytes (5%)
                           Largest free fragment is 65536
               RAM used:   1276 (2%) at main() level
                           1639 (3%) worst case
               Stack size: 128

*
00000:  GOTO    3DAA
*
00050:  DATA    06,11,00
.................... #include <configPic.h> 
.................... #ifndef __CONFIG_H_ 
.................... #define __CONFIG_H_ 
....................  
.................... #include <24ep512gp806.h> 
.................... //////////// Standard Header file for the PIC24EP512GP806 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24EP512GP806 
*
00200:  CLR     54
00202:  MOV     #AC,W3
00204:  SUB     W0,W3,W3
00206:  BRA     C,212
00208:  MOV     #21C,W3
0020A:  ADD     W3,W0,W0
0020C:  TBLRDL.B[W0],W0L
0020E:  CLR.B   1
00210:  RETURN  
00212:  MOV     #21C,W0
00214:  ADD     W3,W3,W3
00216:  ADD     W3,W0,W3
00218:  TBLRDH  [W3],W0
0021A:  RETURN  
0021C:  DATA    00,C1,00
0021E:  DATA    81,40,C1
00220:  DATA    01,C0,81
00222:  DATA    80,41,40
00224:  DATA    01,C0,01
00226:  DATA    80,41,C0
00228:  DATA    00,C1,80
0022A:  DATA    81,40,41
0022C:  DATA    01,C0,00
0022E:  DATA    80,41,C1
00230:  DATA    00,C1,81
00232:  DATA    81,40,40
00234:  DATA    00,C1,00
00236:  DATA    81,40,C1
00238:  DATA    01,C0,81
0023A:  DATA    80,41,40
0023C:  DATA    01,C0,01
0023E:  DATA    80,41,C0
00240:  DATA    00,C1,80
00242:  DATA    81,40,41
00244:  DATA    00,C1,00
00246:  DATA    81,40,C1
00248:  DATA    01,C0,81
0024A:  DATA    80,41,40
0024C:  DATA    00,C1,01
0024E:  DATA    81,40,C0
00250:  DATA    01,C0,80
00252:  DATA    80,41,41
00254:  DATA    01,C0,01
00256:  DATA    80,41,C0
00258:  DATA    00,C1,80
0025A:  DATA    81,40,41
0025C:  DATA    01,C0,00
0025E:  DATA    80,41,C1
00260:  DATA    00,C1,81
00262:  DATA    81,40,40
00264:  DATA    00,C1,01
00266:  DATA    81,40,C0
00268:  DATA    01,C0,80
0026A:  DATA    80,41,41
0026C:  DATA    00,C1,00
0026E:  DATA    81,40,C1
00270:  DATA    01,C0,81
00272:  DATA    80,41,40
00274:  DATA    01,C0,00
00276:  DATA    80,41,C1
00278:  DATA    00,C1,81
0027A:  DATA    81,40,40
0027C:  DATA    00,C1,01
0027E:  DATA    81,40,C0
00280:  DATA    01,C0,80
00282:  DATA    80,41,41
00284:  DATA    01,C0,01
00286:  DATA    80,41,C0
00288:  DATA    00,C1,80
0028A:  DATA    81,40,41
0028C:  DATA    01,C0,00
0028E:  DATA    80,41,C1
00290:  DATA    00,C1,81
00292:  DATA    81,40,40
00294:  DATA    00,C1,00
00296:  DATA    81,40,C1
00298:  DATA    01,C0,81
0029A:  DATA    80,41,40
0029C:  DATA    01,C0,01
0029E:  DATA    80,41,C0
002A0:  DATA    00,C1,80
002A2:  DATA    81,40,41
002A4:  DATA    00,C1,00
002A6:  DATA    81,40,C1
002A8:  DATA    01,C0,81
002AA:  DATA    80,41,40
002AC:  DATA    00,C1,01
002AE:  DATA    81,40,C0
002B0:  DATA    01,C0,80
002B2:  DATA    80,41,41
002B4:  DATA    01,C0,01
002B6:  DATA    80,41,C0
002B8:  DATA    00,C1,80
002BA:  DATA    81,40,41
002BC:  DATA    00,C1,00
002BE:  DATA    81,40,C1
002C0:  DATA    01,C0,81
002C2:  DATA    80,41,40
002C4:  DATA    01,C0,00
002C6:  DATA    80,41,00
002C8:  CLR     54
002CA:  MOV     #AC,W3
002CC:  SUB     W0,W3,W3
002CE:  BRA     C,2DA
002D0:  MOV     #2E4,W3
002D2:  ADD     W3,W0,W0
002D4:  TBLRDL.B[W0],W0L
002D6:  CLR.B   1
002D8:  RETURN  
002DA:  MOV     #2E4,W0
002DC:  ADD     W3,W3,W3
002DE:  ADD     W3,W0,W3
002E0:  TBLRDH  [W3],W0
002E2:  RETURN  
002E4:  DATA    00,C0,7D
002E6:  DATA    C1,01,BD
002E8:  DATA    C3,03,BC
002EA:  DATA    02,C2,7C
002EC:  DATA    C6,06,B4
002EE:  DATA    07,C7,74
002F0:  DATA    05,C5,75
002F2:  DATA    C4,04,B5
002F4:  DATA    CC,0C,77
002F6:  DATA    0D,CD,B7
002F8:  DATA    0F,CF,B6
002FA:  DATA    CE,0E,76
002FC:  DATA    0A,CA,72
002FE:  DATA    CB,0B,B2
00300:  DATA    C9,09,B3
00302:  DATA    08,C8,73
00304:  DATA    D8,18,B1
00306:  DATA    19,D9,71
00308:  DATA    1B,DB,70
0030A:  DATA    DA,1A,B0
0030C:  DATA    1E,DE,50
0030E:  DATA    DF,1F,90
00310:  DATA    DD,1D,91
00312:  DATA    1C,DC,51
00314:  DATA    14,D4,93
00316:  DATA    D5,15,53
00318:  DATA    D7,17,52
0031A:  DATA    16,D6,92
0031C:  DATA    D2,12,96
0031E:  DATA    13,D3,56
00320:  DATA    11,D1,57
00322:  DATA    D0,10,97
00324:  DATA    F0,30,55
00326:  DATA    31,F1,95
00328:  DATA    33,F3,94
0032A:  DATA    F2,32,54
0032C:  DATA    36,F6,9C
0032E:  DATA    F7,37,5C
00330:  DATA    F5,35,5D
00332:  DATA    34,F4,9D
00334:  DATA    3C,FC,5F
00336:  DATA    FD,3D,9F
00338:  DATA    FF,3F,9E
0033A:  DATA    3E,FE,5E
0033C:  DATA    FA,3A,5A
0033E:  DATA    3B,FB,9A
00340:  DATA    39,F9,9B
00342:  DATA    F8,38,5B
00344:  DATA    28,E8,99
00346:  DATA    E9,29,59
00348:  DATA    EB,2B,58
0034A:  DATA    2A,EA,98
0034C:  DATA    EE,2E,88
0034E:  DATA    2F,EF,48
00350:  DATA    2D,ED,49
00352:  DATA    EC,2C,89
00354:  DATA    E4,24,4B
00356:  DATA    25,E5,8B
00358:  DATA    27,E7,8A
0035A:  DATA    E6,26,4A
0035C:  DATA    22,E2,4E
0035E:  DATA    E3,23,8E
00360:  DATA    E1,21,8F
00362:  DATA    20,E0,4F
00364:  DATA    A0,60,8D
00366:  DATA    61,A1,4D
00368:  DATA    63,A3,4C
0036A:  DATA    A2,62,8C
0036C:  DATA    66,A6,44
0036E:  DATA    A7,67,84
00370:  DATA    A5,65,85
00372:  DATA    64,A4,45
00374:  DATA    6C,AC,87
00376:  DATA    AD,6D,47
00378:  DATA    AF,6F,46
0037A:  DATA    6E,AE,86
0037C:  DATA    AA,6A,82
0037E:  DATA    6B,AB,42
00380:  DATA    69,A9,43
00382:  DATA    A8,68,83
00384:  DATA    78,B8,41
00386:  DATA    B9,79,81
00388:  DATA    BB,7B,80
0038A:  DATA    7A,BA,40
0038C:  DATA    BE,7E,00
0038E:  DATA    7F,BF,00
00390:  CLR     54
00392:  MOV     #39C,W3
00394:  ADD     W3,W0,W0
00396:  TBLRDL.B[W0],W0L
00398:  CLR.B   1
0039A:  RETURN  
0039C:  DATA    50,6F,00
0039E:  DATA    77,65,00
003A0:  DATA    72,20,00
003A2:  DATA    4F,6E,00
003A4:  DATA    20,4D,00
003A6:  DATA    6F,64,00
003A8:  DATA    75,6C,00
003AA:  DATA    65,20,00
003AC:  DATA    53,49,00
003AE:  DATA    4D,20,00
003B0:  DATA    4D,39,00
003B2:  DATA    35,0D,00
003B4:  DATA    0A,00,00
003B6:  CLR     54
003B8:  MOV     #3C2,W3
003BA:  ADD     W3,W0,W0
003BC:  TBLRDL.B[W0],W0L
003BE:  CLR.B   1
003C0:  RETURN  
003C2:  DATA    4F,4B,00
003C4:  DATA    00,00,00
003C6:  CLR     54
003C8:  MOV     #3D2,W3
003CA:  ADD     W3,W0,W0
003CC:  TBLRDL.B[W0],W0L
003CE:  CLR.B   1
003D0:  RETURN  
003D2:  DATA    45,52,00
003D4:  DATA    52,4F,00
003D6:  DATA    52,00,00
003D8:  CLR     54
003DA:  MOV     #3E4,W3
003DC:  ADD     W3,W0,W0
003DE:  TBLRDL.B[W0],W0L
003E0:  CLR.B   1
003E2:  RETURN  
003E4:  DATA    2E,00,00
003E6:  CLR     54
003E8:  MOV     #3F2,W3
003EA:  ADD     W3,W0,W0
003EC:  TBLRDL.B[W0],W0L
003EE:  CLR.B   1
003F0:  RETURN  
003F2:  DATA    43,4F,00
003F4:  DATA    4E,4E,00
003F6:  DATA    45,43,00
003F8:  DATA    54,20,00
003FA:  DATA    46,41,00
003FC:  DATA    49,4C,00
003FE:  DATA    00,00,00
00400:  CLR     54
00402:  MOV     #40C,W3
00404:  ADD     W3,W0,W0
00406:  TBLRDL.B[W0],W0L
00408:  CLR.B   1
0040A:  RETURN  
0040C:  DATA    43,4F,00
0040E:  DATA    4E,4E,00
00410:  DATA    45,43,00
00412:  DATA    54,20,00
00414:  DATA    4F,4B,00
00416:  DATA    00,00,00
00418:  CLR     54
0041A:  MOV     #424,W3
0041C:  ADD     W3,W0,W0
0041E:  TBLRDL.B[W0],W0L
00420:  CLR.B   1
00422:  RETURN  
00424:  DATA    54,43,00
00426:  DATA    50,20,00
00428:  DATA    43,6F,00
0042A:  DATA    6E,6E,00
0042C:  DATA    65,63,00
0042E:  DATA    74,65,00
00430:  DATA    64,0D,00
00432:  DATA    0A,00,00
00434:  CLR     54
00436:  MOV     #440,W3
00438:  ADD     W3,W0,W0
0043A:  TBLRDL.B[W0],W0L
0043C:  CLR.B   1
0043E:  RETURN  
00440:  DATA    43,4F,00
00442:  DATA    4E,4E,00
00444:  DATA    45,43,00
00446:  DATA    54,0D,00
00448:  DATA    0A,00,00
0044A:  CLR     54
0044C:  MOV     #456,W3
0044E:  ADD     W3,W0,W0
00450:  TBLRDL.B[W0],W0L
00452:  CLR.B   1
00454:  RETURN  
00456:  DATA    43,4C,00
00458:  DATA    4F,53,00
0045A:  DATA    45,44,00
0045C:  DATA    00,00,00
0045E:  CLR     54
00460:  MOV     #46A,W3
00462:  ADD     W3,W0,W0
00464:  TBLRDL.B[W0],W0L
00466:  CLR.B   1
00468:  RETURN  
0046A:  DATA    54,43,00
0046C:  DATA    50,20,00
0046E:  DATA    44,69,00
00470:  DATA    73,63,00
00472:  DATA    6F,6E,00
00474:  DATA    6E,65,00
00476:  DATA    63,74,00
00478:  DATA    65,64,00
0047A:  DATA    0D,0A,00
0047C:  DATA    00,00,00
0047E:  CLR     54
00480:  MOV     #48A,W3
00482:  ADD     W3,W0,W0
00484:  TBLRDL.B[W0],W0L
00486:  CLR.B   1
00488:  RETURN  
0048A:  DATA    3E,00,00
0048C:  CLR     54
0048E:  MOV     #498,W3
00490:  ADD     W3,W0,W0
00492:  TBLRDL.B[W0],W0L
00494:  CLR.B   1
00496:  RETURN  
00498:  DATA    63,6F,00
0049A:  DATA    6E,74,00
0049C:  DATA    65,6E,00
0049E:  DATA    74,20,00
004A0:  DATA    6D,65,00
004A2:  DATA    73,73,00
004A4:  DATA    61,67,00
004A6:  DATA    65,3A,00
004A8:  DATA    0D,0A,00
004AA:  DATA    00,00,00
004AC:  CLR     54
004AE:  MOV     #4B8,W3
004B0:  ADD     W3,W0,W0
004B2:  TBLRDL.B[W0],W0L
004B4:  CLR.B   1
004B6:  RETURN  
004B8:  DATA    20,49,00
004BA:  DATA    4E,49,00
004BC:  DATA    54,49,00
004BE:  DATA    41,4C,00
004C0:  DATA    00,00,00
004C2:  CLR     54
004C4:  MOV     #4CE,W3
004C6:  ADD     W3,W0,W0
004C8:  TBLRDL.B[W0],W0L
004CA:  CLR.B   1
004CC:  RETURN  
004CE:  DATA    20,53,00
004D0:  DATA    54,41,00
004D2:  DATA    52,54,00
004D4:  DATA    00,00,00
004D6:  CLR     54
004D8:  MOV     #4E2,W3
004DA:  ADD     W3,W0,W0
004DC:  TBLRDL.B[W0],W0L
004DE:  CLR.B   1
004E0:  RETURN  
004E2:  DATA    20,43,00
004E4:  DATA    4F,4E,00
004E6:  DATA    46,49,00
004E8:  DATA    47,00,00
004EA:  CLR     54
004EC:  MOV     #4F6,W3
004EE:  ADD     W3,W0,W0
004F0:  TBLRDL.B[W0],W0L
004F2:  CLR.B   1
004F4:  RETURN  
004F6:  DATA    20,47,00
004F8:  DATA    50,52,00
004FA:  DATA    53,41,00
004FC:  DATA    43,54,00
004FE:  DATA    00,00,00
00500:  CLR     54
00502:  MOV     #50C,W3
00504:  ADD     W3,W0,W0
00506:  TBLRDL.B[W0],W0L
00508:  CLR.B   1
0050A:  RETURN  
0050C:  DATA    20,53,00
0050E:  DATA    54,41,00
00510:  DATA    54,55,00
00512:  DATA    53,00,00
00514:  CLR     54
00516:  MOV     #520,W3
00518:  ADD     W3,W0,W0
0051A:  TBLRDL.B[W0],W0L
0051C:  CLR.B   1
0051E:  RETURN  
00520:  DATA    20,43,00
00522:  DATA    4C,4F,00
00524:  DATA    53,45,00
00526:  DATA    00,00,00
00528:  CLR     54
0052A:  MOV     #534,W3
0052C:  ADD     W3,W0,W0
0052E:  TBLRDL.B[W0],W0L
00530:  CLR.B   1
00532:  RETURN  
00534:  DATA    54,43,00
00536:  DATA    50,20,00
00538:  DATA    43,4F,00
0053A:  DATA    4E,4E,00
0053C:  DATA    45,43,00
0053E:  DATA    54,49,00
00540:  DATA    4E,47,00
00542:  DATA    00,00,00
00544:  CLR     54
00546:  MOV     #550,W3
00548:  ADD     W3,W0,W0
0054A:  TBLRDL.B[W0],W0L
0054C:  CLR.B   1
0054E:  RETURN  
00550:  DATA    20,43,00
00552:  DATA    4F,4E,00
00554:  DATA    4E,45,00
00556:  DATA    43,54,00
00558:  DATA    20,4F,00
0055A:  DATA    4B,00,00
0055C:  CLR     54
0055E:  MOV     #568,W3
00560:  ADD     W3,W0,W0
00562:  TBLRDL.B[W0],W0L
00564:  CLR.B   1
00566:  RETURN  
00568:  DATA    20,43,00
0056A:  DATA    4F,4E,00
0056C:  DATA    4E,45,00
0056E:  DATA    43,54,00
00570:  DATA    20,46,00
00572:  DATA    41,49,00
00574:  DATA    4C,00,00
00576:  CLR     54
00578:  MOV     #582,W3
0057A:  ADD     W3,W0,W0
0057C:  TBLRDL.B[W0],W0L
0057E:  CLR.B   1
00580:  RETURN  
00582:  DATA    20,50,00
00584:  DATA    44,50,00
00586:  DATA    20,44,00
00588:  DATA    45,41,00
0058A:  DATA    43,54,00
0058C:  DATA    00,00,00
0058E:  CLR     54
00590:  MOV     #59A,W3
00592:  ADD     W3,W0,W0
00594:  TBLRDL.B[W0],W0L
00596:  CLR.B   1
00598:  RETURN  
0059A:  DATA    69,6E,00
0059C:  DATA    70,75,00
0059E:  DATA    74,53,00
005A0:  DATA    74,72,00
005A2:  DATA    69,6E,00
005A4:  DATA    67,3A,00
005A6:  DATA    20,25,00
005A8:  DATA    64,0D,00
005AA:  DATA    0A,00,00
005AC:  CLR     54
005AE:  MOV     #5B8,W3
005B0:  ADD     W3,W0,W0
005B2:  TBLRDL.B[W0],W0L
005B4:  CLR.B   1
005B6:  RETURN  
005B8:  DATA    72,65,00
005BA:  DATA    70,6F,00
005BC:  DATA    6E,73,00
005BE:  DATA    65,20,00
005C0:  DATA    43,4F,00
005C2:  DATA    4E,4E,00
005C4:  DATA    41,43,00
005C6:  DATA    4B,3A,00
005C8:  DATA    20,25,00
005CA:  DATA    64,0D,00
005CC:  DATA    0A,00,00
005CE:  CLR     54
005D0:  MOV     #5DA,W3
005D2:  ADD     W3,W0,W0
005D4:  TBLRDL.B[W0],W0L
005D6:  CLR.B   1
005D8:  RETURN  
005DA:  DATA    69,6E,00
005DC:  DATA    70,75,00
005DE:  DATA    74,53,00
005E0:  DATA    74,72,00
005E2:  DATA    69,6E,00
005E4:  DATA    67,5B,00
005E6:  DATA    30,5D,00
005E8:  DATA    3A,20,00
005EA:  DATA    25,64,00
005EC:  DATA    0D,0A,00
005EE:  DATA    00,00,00
005F0:  CLR     54
005F2:  MOV     #5FC,W3
005F4:  ADD     W3,W0,W0
005F6:  TBLRDL.B[W0],W0L
005F8:  CLR.B   1
005FA:  RETURN  
005FC:  DATA    69,6E,00
005FE:  DATA    70,75,00
00600:  DATA    74,53,00
00602:  DATA    74,72,00
00604:  DATA    69,6E,00
00606:  DATA    67,5B,00
00608:  DATA    31,5D,00
0060A:  DATA    3A,20,00
0060C:  DATA    25,64,00
0060E:  DATA    0D,0A,00
00610:  DATA    00,00,00
00612:  CLR     54
00614:  MOV     #61E,W3
00616:  ADD     W3,W0,W0
00618:  TBLRDL.B[W0],W0L
0061A:  CLR.B   1
0061C:  RETURN  
0061E:  DATA    72,65,00
00620:  DATA    70,6F,00
00622:  DATA    6E,73,00
00624:  DATA    65,20,00
00626:  DATA    50,55,00
00628:  DATA    42,4C,00
0062A:  DATA    49,53,00
0062C:  DATA    48,3A,00
0062E:  DATA    20,25,00
00630:  DATA    64,0D,00
00632:  DATA    0A,00,00
00634:  CLR     54
00636:  MOV     #640,W3
00638:  ADD     W3,W0,W0
0063A:  TBLRDL.B[W0],W0L
0063C:  CLR.B   1
0063E:  RETURN  
00640:  DATA    74,6F,00
00642:  DATA    70,69,00
00644:  DATA    63,4C,00
00646:  DATA    65,6E,00
00648:  DATA    67,74,00
0064A:  DATA    68,3A,00
0064C:  DATA    20,25,00
0064E:  DATA    64,0D,00
00650:  DATA    0A,00,00
00652:  CLR     54
00654:  MOV     #65E,W3
00656:  ADD     W3,W0,W0
00658:  TBLRDL.B[W0],W0L
0065A:  CLR.B   1
0065C:  RETURN  
0065E:  DATA    74,6F,00
00660:  DATA    70,69,00
00662:  DATA    63,20,00
00664:  DATA    6C,65,00
00666:  DATA    6E,67,00
00668:  DATA    74,68,00
0066A:  DATA    20,69,00
0066C:  DATA    73,20,00
0066E:  DATA    6C,61,00
00670:  DATA    72,67,00
00672:  DATA    65,0D,00
00674:  DATA    0A,00,00
00676:  CLR     54
00678:  MOV     #682,W3
0067A:  ADD     W3,W0,W0
0067C:  TBLRDL.B[W0],W0L
0067E:  CLR.B   1
00680:  RETURN  
00682:  DATA    74,5F,00
00684:  DATA    74,70,00
00686:  DATA    6F,69,00
00688:  DATA    63,31,00
0068A:  DATA    3A,20,00
0068C:  DATA    25,73,00
0068E:  DATA    0D,0A,00
00690:  DATA    00,00,00
00692:  CLR     54
00694:  MOV     #69E,W3
00696:  ADD     W3,W0,W0
00698:  TBLRDL.B[W0],W0L
0069A:  CLR.B   1
0069C:  RETURN  
0069E:  DATA    6D,65,00
006A0:  DATA    73,73,00
006A2:  DATA    61,67,00
006A4:  DATA    65,49,00
006A6:  DATA    44,3A,00
006A8:  DATA    20,25,00
006AA:  DATA    64,0D,00
006AC:  DATA    0A,00,00
006AE:  CLR     54
006B0:  MOV     #6BA,W3
006B2:  ADD     W3,W0,W0
006B4:  TBLRDL.B[W0],W0L
006B6:  CLR.B   1
006B8:  RETURN  
006BA:  DATA    74,5F,00
006BC:  DATA    6D,65,00
006BE:  DATA    73,73,00
006C0:  DATA    61,67,00
006C2:  DATA    65,32,00
006C4:  DATA    3A,20,00
006C6:  DATA    25,73,00
006C8:  DATA    0D,0A,00
006CA:  DATA    00,00,00
006CC:  CLR     54
006CE:  MOV     #6D8,W3
006D0:  ADD     W3,W0,W0
006D2:  TBLRDL.B[W0],W0L
006D4:  CLR.B   1
006D6:  RETURN  
006D8:  DATA    51,6F,00
006DA:  DATA    53,3A,00
006DC:  DATA    20,25,00
006DE:  DATA    64,0D,00
006E0:  DATA    0A,00,00
006E2:  CLR     54
006E4:  MOV     #6EE,W3
006E6:  ADD     W3,W0,W0
006E8:  TBLRDL.B[W0],W0L
006EA:  CLR.B   1
006EC:  RETURN  
006EE:  DATA    6D,65,00
006F0:  DATA    73,73,00
006F2:  DATA    61,67,00
006F4:  DATA    65,49,00
006F6:  DATA    44,3A,00
006F8:  DATA    20,25,00
006FA:  DATA    73,0D,00
006FC:  DATA    0A,00,00
006FE:  CLR     54
00700:  MOV     #70A,W3
00702:  ADD     W3,W0,W0
00704:  TBLRDL.B[W0],W0L
00706:  CLR.B   1
00708:  RETURN  
0070A:  DATA    72,65,00
0070C:  DATA    73,70,00
0070E:  DATA    6F,6E,00
00710:  DATA    73,65,00
00712:  DATA    20,50,00
00714:  DATA    55,42,00
00716:  DATA    41,43,00
00718:  DATA    4B,3A,00
0071A:  DATA    20,25,00
0071C:  DATA    64,0D,00
0071E:  DATA    0A,00,00
00720:  CLR     54
00722:  MOV     #72C,W3
00724:  ADD     W3,W0,W0
00726:  TBLRDL.B[W0],W0L
00728:  CLR.B   1
0072A:  RETURN  
0072C:  DATA    70,61,00
0072E:  DATA    63,6B,00
00730:  DATA    65,74,00
00732:  DATA    20,49,00
00734:  DATA    44,3A,00
00736:  DATA    20,25,00
00738:  DATA    64,0D,00
0073A:  DATA    0A,00,00
0073C:  CLR     54
0073E:  MOV     #748,W3
00740:  ADD     W3,W0,W0
00742:  TBLRDL.B[W0],W0L
00744:  CLR.B   1
00746:  RETURN  
00748:  DATA    72,65,00
0074A:  DATA    73,70,00
0074C:  DATA    6F,6E,00
0074E:  DATA    73,65,00
00750:  DATA    20,50,00
00752:  DATA    55,43,00
00754:  DATA    4F,4D,00
00756:  DATA    50,3A,00
00758:  DATA    20,25,00
0075A:  DATA    64,0D,00
0075C:  DATA    0A,00,00
0075E:  CLR     54
00760:  MOV     #76A,W3
00762:  ADD     W3,W0,W0
00764:  TBLRDL.B[W0],W0L
00766:  CLR.B   1
00768:  RETURN  
0076A:  DATA    72,65,00
0076C:  DATA    73,70,00
0076E:  DATA    6F,6E,00
00770:  DATA    73,65,00
00772:  DATA    20,53,00
00774:  DATA    55,42,00
00776:  DATA    41,43,00
00778:  DATA    4B,20,00
0077A:  DATA    3A,20,00
0077C:  DATA    25,64,00
0077E:  DATA    0D,0A,00
00780:  DATA    00,00,00
00782:  CLR     54
00784:  MOV     #78E,W3
00786:  ADD     W3,W0,W0
00788:  TBLRDL.B[W0],W0L
0078A:  CLR.B   1
0078C:  RETURN  
0078E:  DATA    72,65,00
00790:  DATA    70,6F,00
00792:  DATA    6E,73,00
00794:  DATA    65,20,00
00796:  DATA    55,4E,00
00798:  DATA    53,55,00
0079A:  DATA    42,41,00
0079C:  DATA    43,4B,00
0079E:  DATA    3A,20,00
007A0:  DATA    25,64,00
007A2:  DATA    0D,0A,00
007A4:  DATA    00,00,00
007A6:  CLR     54
007A8:  MOV     #7B2,W3
007AA:  ADD     W3,W0,W0
007AC:  TBLRDL.B[W0],W0L
007AE:  CLR.B   1
007B0:  RETURN  
007B2:  DATA    69,6E,00
007B4:  DATA    70,75,00
007B6:  DATA    74,53,00
007B8:  DATA    74,72,00
007BA:  DATA    69,6E,00
007BC:  DATA    67,5B,00
007BE:  DATA    32,5D,00
007C0:  DATA    3A,20,00
007C2:  DATA    25,64,00
007C4:  DATA    0D,0A,00
007C6:  DATA    00,00,00
007C8:  CLR     54
007CA:  MOV     #7D4,W3
007CC:  ADD     W3,W0,W0
007CE:  TBLRDL.B[W0],W0L
007D0:  CLR.B   1
007D2:  RETURN  
007D4:  DATA    69,6E,00
007D6:  DATA    70,75,00
007D8:  DATA    74,53,00
007DA:  DATA    74,72,00
007DC:  DATA    69,6E,00
007DE:  DATA    67,5B,00
007E0:  DATA    33,5D,00
007E2:  DATA    3A,20,00
007E4:  DATA    25,64,00
007E6:  DATA    0D,0A,00
007E8:  DATA    00,00,00
007EA:  CLR     54
007EC:  MOV     #7F6,W3
007EE:  ADD     W3,W0,W0
007F0:  TBLRDL.B[W0],W0L
007F2:  CLR.B   1
007F4:  RETURN  
007F6:  DATA    72,65,00
007F8:  DATA    70,6F,00
007FA:  DATA    6E,73,00
007FC:  DATA    65,20,00
007FE:  DATA    50,55,00
00800:  DATA    42,52,00
00802:  DATA    45,43,00
00804:  DATA    3A,20,00
00806:  DATA    25,64,00
00808:  DATA    0D,0A,00
0080A:  DATA    00,00,00
0080C:  CLR     54
0080E:  MOV     #818,W3
00810:  ADD     W3,W0,W0
00812:  TBLRDL.B[W0],W0L
00814:  CLR.B   1
00816:  RETURN  
00818:  DATA    72,65,00
0081A:  DATA    70,6F,00
0081C:  DATA    6E,73,00
0081E:  DATA    65,20,00
00820:  DATA    50,55,00
00822:  DATA    42,52,00
00824:  DATA    45,4C,00
00826:  DATA    3A,20,00
00828:  DATA    25,64,00
0082A:  DATA    0D,0A,00
0082C:  DATA    00,00,00
0082E:  CLR     54
00830:  MOV     #83A,W3
00832:  ADD     W3,W0,W0
00834:  TBLRDL.B[W0],W0L
00836:  CLR.B   1
00838:  RETURN  
0083A:  DATA    72,65,00
0083C:  DATA    70,6F,00
0083E:  DATA    6E,73,00
00840:  DATA    65,20,00
00842:  DATA    50,49,00
00844:  DATA    4E,47,00
00846:  DATA    52,45,00
00848:  DATA    51,55,00
0084A:  DATA    45,53,00
0084C:  DATA    54,3A,00
0084E:  DATA    20,25,00
00850:  DATA    64,0D,00
00852:  DATA    0A,00,00
00854:  CLR     54
00856:  MOV     #860,W3
00858:  ADD     W3,W0,W0
0085A:  TBLRDL.B[W0],W0L
0085C:  CLR.B   1
0085E:  RETURN  
00860:  DATA    44,69,00
00862:  DATA    73,63,00
00864:  DATA    6F,6E,00
00866:  DATA    6E,65,00
00868:  DATA    63,74,00
0086A:  DATA    69,6E,00
0086C:  DATA    67,2E,00
0086E:  DATA    2E,2E,00
00870:  DATA    0D,0A,00
00872:  DATA    00,00,00
00874:  CLR     54
00876:  MOV     #880,W3
00878:  ADD     W3,W0,W0
0087A:  TBLRDL.B[W0],W0L
0087C:  CLR.B   1
0087E:  RETURN  
00880:  DATA    72,65,00
00882:  DATA    73,70,00
00884:  DATA    6F,6E,00
00886:  DATA    73,65,00
00888:  DATA    20,50,00
0088A:  DATA    49,4E,00
0088C:  DATA    47,52,00
0088E:  DATA    45,53,00
00890:  DATA    50,4F,00
00892:  DATA    4E,53,00
00894:  DATA    45,3A,00
00896:  DATA    20,25,00
00898:  DATA    64,0D,00
0089A:  DATA    0A,00,00
0089C:  CLR     54
0089E:  MOV     #8A8,W3
008A0:  ADD     W3,W0,W0
008A2:  TBLRDL.B[W0],W0L
008A4:  CLR.B   1
008A6:  RETURN  
008A8:  DATA    43,6F,00
008AA:  DATA    6E,6E,00
008AC:  DATA    65,63,00
008AE:  DATA    74,20,00
008B0:  DATA    52,65,00
008B2:  DATA    74,75,00
008B4:  DATA    72,6E,00
008B6:  DATA    20,43,00
008B8:  DATA    6F,64,00
008BA:  DATA    65,3A,00
008BC:  DATA    20,30,00
008BE:  DATA    78,25,00
008C0:  DATA    32,78,00
008C2:  DATA    0D,0A,00
008C4:  DATA    00,00,00
008C6:  CLR     54
008C8:  MOV     #8D2,W3
008CA:  ADD     W3,W0,W0
008CC:  TBLRDL.B[W0],W0L
008CE:  CLR.B   1
008D0:  RETURN  
008D2:  DATA    43,6F,00
008D4:  DATA    6E,6E,00
008D6:  DATA    65,63,00
008D8:  DATA    74,20,00
008DA:  DATA    41,63,00
008DC:  DATA    63,65,00
008DE:  DATA    70,74,00
008E0:  DATA    65,64,00
008E2:  DATA    2E,0D,00
008E4:  DATA    0A,00,00
008E6:  CLR     54
008E8:  MOV     #28,W3
008EA:  SUB     W0,W3,W3
008EC:  BRA     C,8F8
008EE:  MOV     #902,W3
008F0:  ADD     W3,W0,W0
008F2:  TBLRDL.B[W0],W0L
008F4:  CLR.B   1
008F6:  RETURN  
008F8:  MOV     #902,W0
008FA:  ADD     W3,W3,W3
008FC:  ADD     W3,W0,W3
008FE:  TBLRDH  [W3],W0
00900:  RETURN  
00902:  DATA    43,6F,50
00904:  DATA    6E,6E,72
00906:  DATA    65,63,6F
00908:  DATA    74,69,74
0090A:  DATA    6F,6E,6F
0090C:  DATA    20,52,63
0090E:  DATA    65,66,6F
00910:  DATA    75,73,6C
00912:  DATA    65,64,20
00914:  DATA    2C,20,56
00916:  DATA    72,65,65
00918:  DATA    61,73,72
0091A:  DATA    6F,6E,73
0091C:  DATA    3A,20,69
0091E:  DATA    55,6E,6F
00920:  DATA    61,63,6E
00922:  DATA    63,65,0D
00924:  DATA    70,74,0A
00926:  DATA    61,6C,00
00928:  DATA    65,20,00
0092A:  CLR     54
0092C:  MOV     #22,W3
0092E:  SUB     W0,W3,W3
00930:  BRA     C,93C
00932:  MOV     #946,W3
00934:  ADD     W3,W0,W0
00936:  TBLRDL.B[W0],W0L
00938:  CLR.B   1
0093A:  RETURN  
0093C:  MOV     #946,W0
0093E:  ADD     W3,W3,W3
00940:  ADD     W3,W0,W3
00942:  TBLRDH  [W3],W0
00944:  RETURN  
00946:  DATA    43,6F,66
00948:  DATA    6E,6E,69
0094A:  DATA    65,63,65
0094C:  DATA    74,69,72
0094E:  DATA    6F,6E,20
00950:  DATA    20,52,52
00952:  DATA    65,66,65
00954:  DATA    75,73,6A
00956:  DATA    65,64,65
00958:  DATA    2C,20,63
0095A:  DATA    72,65,74
0095C:  DATA    61,73,65
0095E:  DATA    6F,6E,64
00960:  DATA    3A,20,0D
00962:  DATA    49,64,0A
00964:  DATA    65,6E,00
00966:  DATA    74,69,00
00968:  CLR     54
0096A:  MOV     #22,W3
0096C:  SUB     W0,W3,W3
0096E:  BRA     C,97A
00970:  MOV     #984,W3
00972:  ADD     W3,W0,W0
00974:  TBLRDL.B[W0],W0L
00976:  CLR.B   1
00978:  RETURN  
0097A:  MOV     #984,W0
0097C:  ADD     W3,W3,W3
0097E:  ADD     W3,W0,W3
00980:  TBLRDH  [W3],W0
00982:  RETURN  
00984:  DATA    43,6F,20
00986:  DATA    6E,6E,55
00988:  DATA    65,63,6E
0098A:  DATA    74,69,61
0098C:  DATA    6F,6E,76
0098E:  DATA    20,52,61
00990:  DATA    65,66,69
00992:  DATA    75,73,6C
00994:  DATA    65,64,61
00996:  DATA    2C,20,62
00998:  DATA    72,65,6C
0099A:  DATA    61,73,65
0099C:  DATA    6F,6E,0D
0099E:  DATA    3A,20,0A
009A0:  DATA    53,65,00
009A2:  DATA    72,76,00
009A4:  DATA    65,72,00
009A6:  CLR     54
009A8:  MOV     #26,W3
009AA:  SUB     W0,W3,W3
009AC:  BRA     C,9B8
009AE:  MOV     #9C2,W3
009B0:  ADD     W3,W0,W0
009B2:  TBLRDL.B[W0],W0L
009B4:  CLR.B   1
009B6:  RETURN  
009B8:  MOV     #9C2,W0
009BA:  ADD     W3,W3,W3
009BC:  ADD     W3,W0,W3
009BE:  TBLRDH  [W3],W0
009C0:  RETURN  
009C2:  DATA    43,6F,61
009C4:  DATA    6E,6E,6D
009C6:  DATA    65,63,65
009C8:  DATA    74,69,20
009CA:  DATA    6F,6E,6F
009CC:  DATA    20,52,66
009CE:  DATA    65,66,20
009D0:  DATA    75,73,50
009D2:  DATA    65,64,61
009D4:  DATA    2C,20,73
009D6:  DATA    72,65,73
009D8:  DATA    61,73,77
009DA:  DATA    6F,6E,6F
009DC:  DATA    3A,20,72
009DE:  DATA    42,61,64
009E0:  DATA    64,20,0D
009E2:  DATA    55,73,0A
009E4:  DATA    65,72,00
009E6:  DATA    20,4E,00
009E8:  CLR     54
009EA:  MOV     #1E,W3
009EC:  SUB     W0,W3,W3
009EE:  BRA     C,9FA
009F0:  MOV     #A04,W3
009F2:  ADD     W3,W0,W0
009F4:  TBLRDL.B[W0],W0L
009F6:  CLR.B   1
009F8:  RETURN  
009FA:  MOV     #A04,W0
009FC:  ADD     W3,W3,W3
009FE:  ADD     W3,W0,W3
00A00:  TBLRDH  [W3],W0
00A02:  RETURN  
00A04:  DATA    43,6F,74
00A06:  DATA    6E,6E,20
00A08:  DATA    65,63,41
00A0A:  DATA    74,69,75
00A0C:  DATA    6F,6E,74
00A0E:  DATA    20,52,68
00A10:  DATA    65,66,6F
00A12:  DATA    75,73,72
00A14:  DATA    65,64,69
00A16:  DATA    2C,20,7A
00A18:  DATA    72,65,65
00A1A:  DATA    61,73,64
00A1C:  DATA    6F,6E,00
00A1E:  DATA    3A,20,00
00A20:  DATA    4E,6F,00
00A22:  CLR     54
00A24:  MOV     #A2E,W3
00A26:  ADD     W3,W0,W0
00A28:  TBLRDL.B[W0],W0L
00A2A:  CLR.B   1
00A2C:  RETURN  
00A2E:  DATA    52,65,00
00A30:  DATA    73,65,00
00A32:  DATA    72,76,00
00A34:  DATA    65,64,00
00A36:  DATA    20,66,00
00A38:  DATA    6F,72,00
00A3A:  DATA    20,66,00
00A3C:  DATA    75,74,00
00A3E:  DATA    75,72,00
00A40:  DATA    65,20,00
00A42:  DATA    75,73,00
00A44:  DATA    65,0D,00
00A46:  DATA    0A,00,00
00A48:  CLR     54
00A4A:  MOV     #A54,W3
00A4C:  ADD     W3,W0,W0
00A4E:  TBLRDL.B[W0],W0L
00A50:  CLR.B   1
00A52:  RETURN  
00A54:  DATA    53,65,00
00A56:  DATA    6E,64,00
00A58:  DATA    20,43,00
00A5A:  DATA    6F,6D,00
00A5C:  DATA    6D,61,00
00A5E:  DATA    6E,64,00
00A60:  DATA    3A,00,00
00A62:  CLR     54
00A64:  MOV     #A6E,W3
00A66:  ADD     W3,W0,W0
00A68:  TBLRDL.B[W0],W0L
00A6A:  CLR.B   1
00A6C:  RETURN  
00A6E:  DATA    72,65,00
00A70:  DATA    73,70,00
00A72:  DATA    6F,6E,00
00A74:  DATA    73,65,00
00A76:  DATA    20,66,00
00A78:  DATA    75,6E,00
00A7A:  DATA    63,74,00
00A7C:  DATA    69,6F,00
00A7E:  DATA    6E,3A,00
00A80:  DATA    00,00,00
00A82:  CLR     54
00A84:  MOV     #A8E,W3
00A86:  ADD     W3,W0,W0
00A88:  TBLRDL.B[W0],W0L
00A8A:  CLR.B   1
00A8C:  RETURN  
00A8E:  DATA    53,65,00
00A90:  DATA    6E,64,00
00A92:  DATA    20,4C,00
00A94:  DATA    65,6E,00
00A96:  DATA    67,74,00
00A98:  DATA    68,3A,00
00A9A:  DATA    20,25,00
00A9C:  DATA    64,00,00
00A9E:  CLR     54
00AA0:  MOV     #AAA,W3
00AA2:  ADD     W3,W0,W0
00AA4:  TBLRDL.B[W0],W0L
00AA6:  CLR.B   1
00AA8:  RETURN  
00AAA:  DATA    53,65,00
00AAC:  DATA    6E,64,00
00AAE:  DATA    20,4C,00
00AB0:  DATA    65,6E,00
00AB2:  DATA    67,74,00
00AB4:  DATA    68,20,00
00AB6:  DATA    53,74,00
00AB8:  DATA    72,69,00
00ABA:  DATA    6E,67,00
00ABC:  DATA    3A,20,00
00ABE:  DATA    25,64,00
00AC0:  DATA    0D,0A,00
00AC2:  DATA    00,00,00
00AC4:  CLR     54
00AC6:  MOV     #AD0,W3
00AC8:  ADD     W3,W0,W0
00ACA:  TBLRDL.B[W0],W0L
00ACC:  CLR.B   1
00ACE:  RETURN  
00AD0:  DATA    53,65,00
00AD2:  DATA    6E,64,00
00AD4:  DATA    55,54,00
00AD6:  DATA    46,38,00
00AD8:  DATA    53,74,00
00ADA:  DATA    72,69,00
00ADC:  DATA    6E,67,00
00ADE:  DATA    3A,20,00
00AE0:  DATA    25,73,00
00AE2:  DATA    0D,0A,00
00AE4:  DATA    00,00,00
00AE6:  CLR     54
00AE8:  MOV     #AF2,W3
00AEA:  ADD     W3,W0,W0
00AEC:  TBLRDL.B[W0],W0L
00AEE:  CLR.B   1
00AF0:  RETURN  
00AF2:  DATA    70,75,00
00AF4:  DATA    62,6C,00
00AF6:  DATA    69,73,00
00AF8:  DATA    68,41,00
00AFA:  DATA    43,4B,00
00AFC:  DATA    3A,20,00
00AFE:  DATA    00,00,00
00B00:  CLR     54
00B02:  MOV     #B0C,W3
00B04:  ADD     W3,W0,W0
00B06:  TBLRDL.B[W0],W0L
00B08:  CLR.B   1
00B0A:  RETURN  
00B0C:  DATA    70,75,00
00B0E:  DATA    62,6C,00
00B10:  DATA    69,73,00
00B12:  DATA    68,52,00
00B14:  DATA    45,43,00
00B16:  DATA    3A,20,00
00B18:  DATA    00,00,00
00B1A:  CLR     54
00B1C:  MOV     #B26,W3
00B1E:  ADD     W3,W0,W0
00B20:  TBLRDL.B[W0],W0L
00B22:  CLR.B   1
00B24:  RETURN  
00B26:  DATA    70,75,00
00B28:  DATA    62,6C,00
00B2A:  DATA    69,73,00
00B2C:  DATA    68,52,00
00B2E:  DATA    45,4C,00
00B30:  DATA    3A,20,00
00B32:  DATA    00,00,00
00B34:  CLR     54
00B36:  MOV     #B40,W3
00B38:  ADD     W3,W0,W0
00B3A:  TBLRDL.B[W0],W0L
00B3C:  CLR.B   1
00B3E:  RETURN  
00B40:  DATA    70,75,00
00B42:  DATA    62,6C,00
00B44:  DATA    69,73,00
00B46:  DATA    68,43,00
00B48:  DATA    4F,4D,00
00B4A:  DATA    50,3A,00
00B4C:  DATA    20,00,00
00B4E:  CLR     54
00B50:  MOV     #B5A,W3
00B52:  ADD     W3,W0,W0
00B54:  TBLRDL.B[W0],W0L
00B56:  CLR.B   1
00B58:  RETURN  
00B5A:  DATA    70,69,00
00B5C:  DATA    6E,67,00
00B5E:  DATA    52,65,00
00B60:  DATA    71,75,00
00B62:  DATA    65,73,00
00B64:  DATA    74,3A,00
00B66:  DATA    20,0D,00
00B68:  DATA    0A,00,00
00B6A:  CLR     54
00B6C:  MOV     #B76,W3
00B6E:  ADD     W3,W0,W0
00B70:  TBLRDL.B[W0],W0L
00B72:  CLR.B   1
00B74:  RETURN  
00B76:  DATA    4D,51,00
00B78:  DATA    54,54,00
00B7A:  DATA    20,53,00
00B7C:  DATA    55,42,00
00B7E:  DATA    53,43,00
00B80:  DATA    52,49,00
00B82:  DATA    42,45,00
00B84:  DATA    3A,20,00
00B86:  DATA    00,00,00
00B88:  CLR     54
00B8A:  MOV     #B94,W3
00B8C:  ADD     W3,W0,W0
00B8E:  TBLRDL.B[W0],W0L
00B90:  CLR.B   1
00B92:  RETURN  
00B94:  DATA    4D,51,00
00B96:  DATA    54,54,00
00B98:  DATA    20,50,00
00B9A:  DATA    55,42,00
00B9C:  DATA    4C,49,00
00B9E:  DATA    53,48,00
00BA0:  DATA    3A,20,00
00BA2:  DATA    00,00,00
00BA4:  CLR     54
00BA6:  MOV     #BB0,W3
00BA8:  ADD     W3,W0,W0
00BAA:  TBLRDL.B[W0],W0L
00BAC:  CLR.B   1
00BAE:  RETURN  
00BB0:  DATA    50,75,00
00BB2:  DATA    62,54,00
00BB4:  DATA    6F,70,00
00BB6:  DATA    69,63,00
00BB8:  DATA    3A,20,00
00BBA:  DATA    25,73,00
00BBC:  DATA    0D,0A,00
00BBE:  DATA    00,00,00
00BC0:  CLR     54
00BC2:  MOV     #BCC,W3
00BC4:  ADD     W3,W0,W0
00BC6:  TBLRDL.B[W0],W0L
00BC8:  CLR.B   1
00BCA:  RETURN  
00BCC:  DATA    4D,65,00
00BCE:  DATA    73,73,00
00BD0:  DATA    61,67,00
00BD2:  DATA    65,20,00
00BD4:  DATA    50,75,00
00BD6:  DATA    62,6C,00
00BD8:  DATA    69,73,00
00BDA:  DATA    68,3A,00
00BDC:  DATA    20,25,00
00BDE:  DATA    73,0D,00
00BE0:  DATA    0A,00,00
00BE2:  CLR     54
00BE4:  MOV     #BEE,W3
00BE6:  ADD     W3,W0,W0
00BE8:  TBLRDL.B[W0],W0L
00BEA:  CLR.B   1
00BEC:  RETURN  
00BEE:  DATA    43,6F,00
00BF0:  DATA    6E,6E,00
00BF2:  DATA    65,63,00
00BF4:  DATA    74,20,00
00BF6:  DATA    73,65,00
00BF8:  DATA    6E,64,00
00BFA:  DATA    0D,0A,00
00BFC:  DATA    00,00,00
00BFE:  CLR     54
00C00:  MOV     #C0A,W3
00C02:  ADD     W3,W0,W0
00C04:  TBLRDL.B[W0],W0L
00C06:  CLR.B   1
00C08:  RETURN  
00C0A:  DATA    43,6C,00
00C0C:  DATA    69,65,00
00C0E:  DATA    6E,74,00
00C10:  DATA    20,49,00
00C12:  DATA    44,3A,00
00C14:  DATA    20,25,00
00C16:  DATA    73,0D,00
00C18:  DATA    0A,00,00
00C1A:  CLR     54
00C1C:  MOV     #C26,W3
00C1E:  ADD     W3,W0,W0
00C20:  TBLRDL.B[W0],W0L
00C22:  CLR.B   1
00C24:  RETURN  
00C26:  DATA    57,69,00
00C28:  DATA    6C,6C,00
00C2A:  DATA    20,46,00
00C2C:  DATA    6C,61,00
00C2E:  DATA    67,3A,00
00C30:  DATA    20,30,00
00C32:  DATA    78,25,00
00C34:  DATA    32,78,00
00C36:  DATA    0D,0A,00
00C38:  DATA    00,00,00
00C3A:  CLR     54
00C3C:  MOV     #C46,W3
00C3E:  ADD     W3,W0,W0
00C40:  TBLRDL.B[W0],W0L
00C42:  CLR.B   1
00C44:  RETURN  
00C46:  DATA    55,73,00
00C48:  DATA    65,72,00
00C4A:  DATA    4E,61,00
00C4C:  DATA    6D,65,00
00C4E:  DATA    20,46,00
00C50:  DATA    6C,61,00
00C52:  DATA    67,3A,00
00C54:  DATA    20,30,00
00C56:  DATA    78,25,00
00C58:  DATA    32,78,00
00C5A:  DATA    0D,0A,00
00C5C:  DATA    00,00,00
00C5E:  CLR     54
00C60:  MOV     #C6A,W3
00C62:  ADD     W3,W0,W0
00C64:  TBLRDL.B[W0],W0L
00C66:  CLR.B   1
00C68:  RETURN  
00C6A:  DATA    4B,65,00
00C6C:  DATA    65,70,00
00C6E:  DATA    41,6C,00
00C70:  DATA    69,76,00
00C72:  DATA    65,54,00
00C74:  DATA    69,6D,00
00C76:  DATA    65,6F,00
00C78:  DATA    75,74,00
00C7A:  DATA    3A,20,00
00C7C:  DATA    25,64,00
00C7E:  DATA    0D,0A,00
00C80:  DATA    00,00,00
00C82:  CLR     54
00C84:  MOV     #C8E,W3
00C86:  ADD     W3,W0,W0
00C88:  TBLRDL.B[W0],W0L
00C8A:  CLR.B   1
00C8C:  RETURN  
00C8E:  DATA    2B,2B,00
00C90:  DATA    2B,00,00
00C92:  CLR     54
00C94:  MOV     #C9E,W3
00C96:  ADD     W3,W0,W0
00C98:  TBLRDL.B[W0],W0L
00C9A:  CLR.B   1
00C9C:  RETURN  
00C9E:  DATA    53,65,00
00CA0:  DATA    6E,64,00
00CA2:  DATA    69,6E,00
00CA4:  DATA    67,20,00
00CA6:  DATA    41,54,00
00CA8:  DATA    0D,0A,00
00CAA:  DATA    00,00,00
00CAC:  CLR     54
00CAE:  MOV     #CB8,W3
00CB0:  ADD     W3,W0,W0
00CB2:  TBLRDL.B[W0],W0L
00CB4:  CLR.B   1
00CB6:  RETURN  
00CB8:  DATA    41,54,00
00CBA:  DATA    0D,0A,00
00CBC:  DATA    00,00,00
00CBE:  CLR     54
00CC0:  MOV     #CCA,W3
00CC2:  ADD     W3,W0,W0
00CC4:  TBLRDL.B[W0],W0L
00CC6:  CLR.B   1
00CC8:  RETURN  
00CCA:  DATA    41,54,00
00CCC:  DATA    45,30,00
00CCE:  DATA    0D,0A,00
00CD0:  DATA    00,00,00
00CD2:  CLR     54
00CD4:  MOV     #CDE,W3
00CD6:  ADD     W3,W0,W0
00CD8:  TBLRDL.B[W0],W0L
00CDA:  CLR.B   1
00CDC:  RETURN  
00CDE:  DATA    41,54,00
00CE0:  DATA    2B,43,00
00CE2:  DATA    52,45,00
00CE4:  DATA    47,3F,00
00CE6:  DATA    0D,0A,00
00CE8:  DATA    00,00,00
00CEA:  CLR     54
00CEC:  MOV     #CF6,W3
00CEE:  ADD     W3,W0,W0
00CF0:  TBLRDL.B[W0],W0L
00CF2:  CLR.B   1
00CF4:  RETURN  
00CF6:  DATA    2B,43,00
00CF8:  DATA    52,45,00
00CFA:  DATA    47,3A,00
00CFC:  DATA    20,30,00
00CFE:  DATA    2C,31,00
00D00:  DATA    00,00,00
00D02:  CLR     54
00D04:  MOV     #D0E,W3
00D06:  ADD     W3,W0,W0
00D08:  TBLRDL.B[W0],W0L
00D0A:  CLR.B   1
00D0C:  RETURN  
00D0E:  DATA    41,54,00
00D10:  DATA    2B,51,00
00D12:  DATA    49,46,00
00D14:  DATA    47,43,00
00D16:  DATA    4E,54,00
00D18:  DATA    3D,30,00
00D1A:  DATA    0D,0A,00
00D1C:  DATA    00,00,00
00D1E:  CLR     54
00D20:  MOV     #D2A,W3
00D22:  ADD     W3,W0,W0
00D24:  TBLRDL.B[W0],W0L
00D26:  CLR.B   1
00D28:  RETURN  
00D2A:  DATA    41,54,00
00D2C:  DATA    2B,51,00
00D2E:  DATA    49,44,00
00D30:  DATA    4E,53,00
00D32:  DATA    49,50,00
00D34:  DATA    3D,30,00
00D36:  DATA    0D,0A,00
00D38:  DATA    00,00,00
00D3A:  CLR     54
00D3C:  MOV     #D46,W3
00D3E:  ADD     W3,W0,W0
00D40:  TBLRDL.B[W0],W0L
00D42:  CLR.B   1
00D44:  RETURN  
00D46:  DATA    41,54,00
00D48:  DATA    2B,51,00
00D4A:  DATA    49,4E,00
00D4C:  DATA    44,49,00
00D4E:  DATA    3D,31,00
00D50:  DATA    0D,0A,00
00D52:  DATA    00,00,00
00D54:  CLR     54
00D56:  MOV     #D60,W3
00D58:  ADD     W3,W0,W0
00D5A:  TBLRDL.B[W0],W0L
00D5C:  CLR.B   1
00D5E:  RETURN  
00D60:  DATA    41,54,00
00D62:  DATA    2B,51,00
00D64:  DATA    49,4D,00
00D66:  DATA    55,58,00
00D68:  DATA    3D,30,00
00D6A:  DATA    0D,0A,00
00D6C:  DATA    00,00,00
00D6E:  CLR     54
00D70:  MOV     #D7A,W3
00D72:  ADD     W3,W0,W0
00D74:  TBLRDL.B[W0],W0L
00D76:  CLR.B   1
00D78:  RETURN  
00D7A:  DATA    41,54,00
00D7C:  DATA    2B,51,00
00D7E:  DATA    49,4D,00
00D80:  DATA    4F,44,00
00D82:  DATA    45,3D,00
00D84:  DATA    31,0D,00
00D86:  DATA    0A,00,00
00D88:  CLR     54
00D8A:  MOV     #D94,W3
00D8C:  ADD     W3,W0,W0
00D8E:  TBLRDL.B[W0],W0L
00D90:  CLR.B   1
00D92:  RETURN  
00D94:  DATA    41,54,00
00D96:  DATA    2B,43,00
00D98:  DATA    47,41,00
00D9A:  DATA    54,54,00
00D9C:  DATA    3F,0D,00
00D9E:  DATA    0A,00,00
00DA0:  CLR     54
00DA2:  MOV     #DAC,W3
00DA4:  ADD     W3,W0,W0
00DA6:  TBLRDL.B[W0],W0L
00DA8:  CLR.B   1
00DAA:  RETURN  
00DAC:  DATA    2B,43,00
00DAE:  DATA    47,41,00
00DB0:  DATA    54,54,00
00DB2:  DATA    3A,20,00
00DB4:  DATA    31,00,00
00DB6:  CLR     54
00DB8:  MOV     #DC2,W3
00DBA:  ADD     W3,W0,W0
00DBC:  TBLRDL.B[W0],W0L
00DBE:  CLR.B   1
00DC0:  RETURN  
00DC2:  DATA    41,54,00
00DC4:  DATA    2B,43,00
00DC6:  DATA    47,41,00
00DC8:  DATA    54,54,00
00DCA:  DATA    3D,31,00
00DCC:  DATA    0D,0A,00
00DCE:  DATA    00,00,00
00DD0:  CLR     54
00DD2:  MOV     #DDC,W3
00DD4:  ADD     W3,W0,W0
00DD6:  TBLRDL.B[W0],W0L
00DD8:  CLR.B   1
00DDA:  RETURN  
00DDC:  DATA    41,54,00
00DDE:  DATA    2B,51,00
00DE0:  DATA    49,53,00
00DE2:  DATA    54,41,00
00DE4:  DATA    54,0D,00
00DE6:  DATA    0A,00,00
00DE8:  CLR     54
00DEA:  MOV     #DF4,W3
00DEC:  ADD     W3,W0,W0
00DEE:  TBLRDL.B[W0],W0L
00DF0:  CLR.B   1
00DF2:  RETURN  
00DF4:  DATA    53,54,00
00DF6:  DATA    41,54,00
00DF8:  DATA    45,3A,00
00DFA:  DATA    00,00,00
00DFC:  CLR     54
00DFE:  MOV     #E08,W3
00E00:  ADD     W3,W0,W0
00E02:  TBLRDL.B[W0],W0L
00E04:  CLR.B   1
00E06:  RETURN  
00E08:  DATA    41,54,00
00E0A:  DATA    2B,51,00
00E0C:  DATA    49,52,00
00E0E:  DATA    45,47,00
00E10:  DATA    41,50,00
00E12:  DATA    50,3D,00
00E14:  DATA    22,43,00
00E16:  DATA    4D,4E,00
00E18:  DATA    45,54,00
00E1A:  DATA    22,0D,00
00E1C:  DATA    0A,00,00
00E1E:  CLR     54
00E20:  MOV     #E2A,W3
00E22:  ADD     W3,W0,W0
00E24:  TBLRDL.B[W0],W0L
00E26:  CLR.B   1
00E28:  RETURN  
00E2A:  DATA    41,54,00
00E2C:  DATA    2B,51,00
00E2E:  DATA    49,41,00
00E30:  DATA    43,54,00
00E32:  DATA    0D,0A,00
00E34:  DATA    00,00,00
00E36:  CLR     54
00E38:  MOV     #E42,W3
00E3A:  ADD     W3,W0,W0
00E3C:  TBLRDL.B[W0],W0L
00E3E:  CLR.B   1
00E40:  RETURN  
00E42:  DATA    41,54,00
00E44:  DATA    2B,51,00
00E46:  DATA    49,4C,00
00E48:  DATA    4F,43,00
00E4A:  DATA    49,50,00
00E4C:  DATA    0D,0A,00
00E4E:  DATA    00,00,00
00E50:  CLR     54
00E52:  MOV     #E5C,W3
00E54:  ADD     W3,W0,W0
00E56:  TBLRDL.B[W0],W0L
00E58:  CLR.B   1
00E5A:  RETURN  
00E5C:  DATA    31,30,00
00E5E:  DATA    33,2E,00
00E60:  DATA    32,34,00
00E62:  DATA    39,2E,00
00E64:  DATA    31,30,00
00E66:  DATA    30,2E,00
00E68:  DATA    34,38,00
00E6A:  DATA    00,00,00
00E6C:  CLR     54
00E6E:  MOV     #E78,W3
00E70:  ADD     W3,W0,W0
00E72:  TBLRDL.B[W0],W0L
00E74:  CLR.B   1
00E76:  RETURN  
00E78:  DATA    31,38,00
00E7A:  DATA    38,33,00
00E7C:  DATA    00,00,00
00E7E:  CLR     54
00E80:  MOV     #E8A,W3
00E82:  ADD     W3,W0,W0
00E84:  TBLRDL.B[W0],W0L
00E86:  CLR.B   1
00E88:  RETURN  
00E8A:  DATA    41,54,00
00E8C:  DATA    2B,51,00
00E8E:  DATA    49,4F,00
00E90:  DATA    50,45,00
00E92:  DATA    4E,3D,00
00E94:  DATA    22,54,00
00E96:  DATA    43,50,00
00E98:  DATA    22,2C,00
00E9A:  DATA    22,25,00
00E9C:  DATA    73,22,00
00E9E:  DATA    2C,22,00
00EA0:  DATA    25,73,00
00EA2:  DATA    22,0D,00
00EA4:  DATA    0A,00,00
00EA6:  CLR     54
00EA8:  MOV     #EB2,W3
00EAA:  ADD     W3,W0,W0
00EAC:  TBLRDL.B[W0],W0L
00EAE:  CLR.B   1
00EB0:  RETURN  
00EB2:  DATA    6E,6F,00
00EB4:  DATA    6E,65,00
00EB6:  DATA    00,00,00
00EB8:  CLR     54
00EBA:  MOV     #EC4,W3
00EBC:  ADD     W3,W0,W0
00EBE:  TBLRDL.B[W0],W0L
00EC0:  CLR.B   1
00EC2:  RETURN  
00EC4:  DATA    57,61,00
00EC6:  DATA    69,74,00
00EC8:  DATA    69,6E,00
00ECA:  DATA    67,20,00
00ECC:  DATA    72,65,00
00ECE:  DATA    63,6F,00
00ED0:  DATA    6E,6E,00
00ED2:  DATA    65,63,00
00ED4:  DATA    74,2E,00
00ED6:  DATA    2E,2E,00
00ED8:  DATA    0D,0A,00
00EDA:  DATA    00,00,00
00EDC:  CLR     54
00EDE:  MOV     #EE8,W3
00EE0:  ADD     W3,W0,W0
00EE2:  TBLRDL.B[W0],W0L
00EE4:  CLR.B   1
00EE6:  RETURN  
00EE8:  DATA    41,54,00
00EEA:  DATA    2B,51,00
00EEC:  DATA    49,44,00
00EEE:  DATA    45,41,00
00EF0:  DATA    43,54,00
00EF2:  DATA    0D,0A,00
00EF4:  DATA    00,00,00
00EF6:  CLR     54
00EF8:  MOV     #F02,W3
00EFA:  ADD     W3,W0,W0
00EFC:  TBLRDL.B[W0],W0L
00EFE:  CLR.B   1
00F00:  RETURN  
00F02:  DATA    72,65,00
00F04:  DATA    63,65,00
00F06:  DATA    69,76,00
00F08:  DATA    65,64,00
00F0A:  DATA    20,74,00
00F0C:  DATA    6F,70,00
00F0E:  DATA    69,63,00
00F10:  DATA    3A,20,00
00F12:  DATA    25,73,00
00F14:  DATA    0D,0A,00
00F16:  DATA    00,00,00
00F18:  CLR     54
00F1A:  MOV     #F24,W3
00F1C:  ADD     W3,W0,W0
00F1E:  TBLRDL.B[W0],W0L
00F20:  CLR.B   1
00F22:  RETURN  
00F24:  DATA    4F,4E,00
00F26:  DATA    00,00,00
00F28:  CLR     54
00F2A:  MOV     #F34,W3
00F2C:  ADD     W3,W0,W0
00F2E:  TBLRDL.B[W0],W0L
00F30:  CLR.B   1
00F32:  RETURN  
00F34:  DATA    4C,61,00
00F36:  DATA    6D,70,00
00F38:  DATA    20,53,00
00F3A:  DATA    74,61,00
00F3C:  DATA    74,75,00
00F3E:  DATA    73,31,00
00F40:  DATA    3A,20,00
00F42:  DATA    25,73,00
00F44:  DATA    0D,0A,00
00F46:  DATA    00,00,00
00F48:  CLR     54
00F4A:  MOV     #F54,W3
00F4C:  ADD     W3,W0,W0
00F4E:  TBLRDL.B[W0],W0L
00F50:  CLR.B   1
00F52:  RETURN  
00F54:  DATA    4F,46,00
00F56:  DATA    46,00,00
00F58:  CLR     54
00F5A:  MOV     #F64,W3
00F5C:  ADD     W3,W0,W0
00F5E:  TBLRDL.B[W0],W0L
00F60:  CLR.B   1
00F62:  RETURN  
00F64:  DATA    4C,61,00
00F66:  DATA    6D,70,00
00F68:  DATA    20,53,00
00F6A:  DATA    74,61,00
00F6C:  DATA    74,75,00
00F6E:  DATA    73,32,00
00F70:  DATA    3A,20,00
00F72:  DATA    25,73,00
00F74:  DATA    0D,0A,00
00F76:  DATA    00,00,00
00F78:  CLR     54
00F7A:  MOV     #F84,W3
00F7C:  ADD     W3,W0,W0
00F7E:  TBLRDL.B[W0],W0L
00F80:  CLR.B   1
00F82:  RETURN  
00F84:  DATA    44,65,00
00F86:  DATA    76,69,00
00F88:  DATA    63,65,00
00F8A:  DATA    4E,6F,00
00F8C:  DATA    2E,31,00
00F8E:  DATA    00,00,00
00F90:  CLR     54
00F92:  MOV     #F9C,W3
00F94:  ADD     W3,W0,W0
00F96:  TBLRDL.B[W0],W0L
00F98:  CLR.B   1
00F9A:  RETURN  
00F9C:  DATA    53,65,00
00F9E:  DATA    74,74,00
00FA0:  DATA    69,6E,00
00FA2:  DATA    67,20,00
00FA4:  DATA    42,72,00
00FA6:  DATA    6F,6B,00
00FA8:  DATA    65,72,00
00FAA:  DATA    0D,0A,00
00FAC:  DATA    00,00,00
00FAE:  CLR     54
00FB0:  MOV     #FBA,W3
00FB2:  ADD     W3,W0,W0
00FB4:  TBLRDL.B[W0],W0L
00FB6:  CLR.B   1
00FB8:  RETURN  
00FBA:  DATA    42,72,00
00FBC:  DATA    6F,6B,00
00FBE:  DATA    65,72,00
00FC0:  DATA    3A,20,00
00FC2:  DATA    25,73,00
00FC4:  DATA    0D,0A,00
00FC6:  DATA    00,00,00
00FC8:  CLR     54
00FCA:  MOV     #FD4,W3
00FCC:  ADD     W3,W0,W0
00FCE:  TBLRDL.B[W0],W0L
00FD0:  CLR.B   1
00FD2:  RETURN  
00FD4:  DATA    70,6F,00
00FD6:  DATA    72,74,00
00FD8:  DATA    3A,20,00
00FDA:  DATA    25,73,00
00FDC:  DATA    0D,0A,00
00FDE:  DATA    00,00,00
00FE0:  CLR     54
00FE2:  MOV     #FEC,W3
00FE4:  ADD     W3,W0,W0
00FE6:  TBLRDL.B[W0],W0L
00FE8:  CLR.B   1
00FEA:  RETURN  
00FEC:  DATA    53,65,00
00FEE:  DATA    74,74,00
00FF0:  DATA    69,6E,00
00FF2:  DATA    67,20,00
00FF4:  DATA    42,72,00
00FF6:  DATA    6F,6B,00
00FF8:  DATA    65,72,00
00FFA:  DATA    20,4F,00
00FFC:  DATA    4B,0D,00
00FFE:  DATA    0A,00,00
01000:  CLR     54
01002:  MOV     #100C,W3
01004:  ADD     W3,W0,W0
01006:  TBLRDL.B[W0],W0L
01008:  CLR.B   1
0100A:  RETURN  
0100C:  DATA    6D,71,00
0100E:  DATA    74,74,00
01010:  DATA    20,43,00
01012:  DATA    6F,6E,00
01014:  DATA    74,72,00
01016:  DATA    6F,6C,00
01018:  DATA    20,50,00
0101A:  DATA    61,63,00
0101C:  DATA    6B,65,00
0101E:  DATA    74,20,00
01020:  DATA    54,79,00
01022:  DATA    70,65,00
01024:  DATA    3A,20,00
01026:  DATA    25,64,00
01028:  DATA    0D,0A,00
0102A:  DATA    00,00,00
0102C:  CLR     54
0102E:  MOV     #1038,W3
01030:  ADD     W3,W0,W0
01032:  TBLRDL.B[W0],W0L
01034:  CLR.B   1
01036:  RETURN  
01038:  DATA    2F,64,00
0103A:  DATA    65,76,00
0103C:  DATA    69,63,00
0103E:  DATA    65,73,00
01040:  DATA    2F,74,00
01042:  DATA    65,6D,00
01044:  DATA    70,65,00
01046:  DATA    72,61,00
01048:  DATA    74,75,00
0104A:  DATA    72,65,00
0104C:  DATA    2F,76,00
0104E:  DATA    61,6C,00
01050:  DATA    75,65,00
01052:  DATA    00,00,00
01054:  CLR     54
01056:  MOV     #1060,W3
01058:  ADD     W3,W0,W0
0105A:  TBLRDL.B[W0],W0L
0105C:  CLR.B   1
0105E:  RETURN  
01060:  DATA    7B,22,00
01062:  DATA    54,65,00
01064:  DATA    6D,70,00
01066:  DATA    22,3A,00
01068:  DATA    22,25,00
0106A:  DATA    64,2E,00
0106C:  DATA    25,64,00
0106E:  DATA    22,7D,00
01070:  DATA    00,00,00
01072:  CLR     54
01074:  MOV     #107E,W3
01076:  ADD     W3,W0,W0
01078:  TBLRDL.B[W0],W0L
0107A:  CLR.B   1
0107C:  RETURN  
0107E:  DATA    0D,0A,00
01080:  DATA    6E,75,00
01082:  DATA    6D,4F,00
01084:  DATA    66,52,00
01086:  DATA    65,67,00
01088:  DATA    3A,20,00
0108A:  DATA    25,64,00
0108C:  DATA    0D,0A,00
0108E:  DATA    00,00,00
01090:  CLR     54
01092:  MOV     #109C,W3
01094:  ADD     W3,W0,W0
01096:  TBLRDL.B[W0],W0L
01098:  CLR.B   1
0109A:  RETURN  
0109C:  DATA    2A,2A,00
0109E:  DATA    2A,20,00
010A0:  DATA    45,78,00
010A2:  DATA    63,65,00
010A4:  DATA    70,74,00
010A6:  DATA    69,6F,00
010A8:  DATA    6E,3A,00
010AA:  DATA    20,25,00
010AC:  DATA    64,20,00
010AE:  DATA    2A,2A,00
010B0:  DATA    2A,0D,00
010B2:  DATA    0A,00,00
*
012DE:  MOV     W1,[W15++]
012E0:  MOV     1476,W1
012E2:  MOV.B   W0L,[W1++]
012E4:  CLR.B   [W1]
012E6:  MOV     [--W15],W1
012E8:  INC     1476
012EA:  RETURN  
*
013C8:  MOV     W0,W3
013CA:  SWAP    W1
013CC:  MOV.B   #5,W4L
013CE:  DEC.B   0003
013D0:  DEC.B   0008
013D2:  BRA     Z,13FA
013D4:  MOV     W3,W0
013D6:  SL      W3,#4,W3
013D8:  LSR     W0,#C,W0
013DA:  AND     #F,W0
013DC:  BRA     NZ,13E6
013DE:  CP.B    W4L,#1
013E0:  BRA     Z,13E6
013E2:  BTSS.B  3.7
013E4:  BRA     13CE
013E6:  ADD     #30,W0
013E8:  MOV     #3A,W2
013EA:  CP      W0,W2
013EC:  BRA     NC,13F0
013EE:  ADD.B   2,W0L
013F0:  BTSC.B  223.1
013F2:  BRA     13F0
013F4:  MOV     W0,224
013F6:  BSET.B  3.7
013F8:  BRA     13CE
013FA:  RETURN  
013FC:  MOV     W6,[W15++]
013FE:  MOV     W7,[W15++]
01400:  MOV     W8,[W15++]
01402:  MOV     W9,[W15++]
01404:  CLR     W4
01406:  CLR     W5
01408:  CLR     W6
0140A:  CLR     W7
0140C:  XOR     W2,W3,W8
0140E:  BRA     Z,1432
01410:  MOV     #20,W8
01412:  BCLR.B  42.0
01414:  RLC     W0,W0
01416:  RLC     W1,W1
01418:  RLC     W4,W4
0141A:  RLC     W5,W5
0141C:  CP      W5,W3
0141E:  BRA     NZ,1422
01420:  CPB     W4,W2
01422:  BRA     NC,142A
01424:  SUB     W4,W2,W4
01426:  SUBB    W5,W3,W5
01428:  BSET.B  42.0
0142A:  RLC     W6,W6
0142C:  RLC     W7,W7
0142E:  DEC     W8,W8
01430:  BRA     NZ,1412
01432:  MOV     W7,W1
01434:  MOV     W6,W0
01436:  MOV     [--W15],W9
01438:  MOV     [--W15],W8
0143A:  MOV     [--W15],W7
0143C:  MOV     [--W15],W6
0143E:  RETURN  
01440:  MOV     W5,[W15++]
01442:  MOV     #C,W5
01444:  REPEAT  #7
01446:  MOV     [W5++],[W15++]
01448:  BTSS    W1.F
0144A:  BRA     145A
0144C:  NEG     W0,W0
0144E:  BRA     Z,1452
01450:  BRA     NZ,1456
01452:  NEG     W1,W1
01454:  BRA     1458
01456:  COM     W1,W1
01458:  BSET    W4.8
0145A:  CLR     W5
0145C:  MOV     W0,W6
0145E:  MOV     W1,W7
01460:  MOV     W4,W12
01462:  BCLR    W4.F
01464:  CP0.B   W4L
01466:  BRA     NZ,146A
01468:  BRA     149A
0146A:  SUB.B   W4L,#B,W5L
0146C:  BRA     NC,149A
0146E:  SUB.B   W4L,W5L,W4L
01470:  BTSS    W12.F
01472:  BRA     148A
01474:  BTSS    W4.8
01476:  BRA     1486
01478:  MOV     #2D,W0
0147A:  BTSC.B  223.1
0147C:  BRA     147A
0147E:  MOV     W0,224
01480:  BCLR    W4.8
01482:  DEC     W5,W5
01484:  BRA     N,149A
01486:  MOV     #30,W0
01488:  BRA     148C
0148A:  MOV     #20,W0
0148C:  BTSC.B  223.1
0148E:  BRA     148C
01490:  MOV     W0,224
01492:  DEC     W5,W5
01494:  BRA     NN,148C
01496:  BTSC    W4.8
01498:  DEC.B   W4L,W4L
0149A:  MOV     #E,W8
0149C:  MOV     #0,W9
0149E:  LNK     #10
014A0:  MOV     W12,[W14+W8]
014A2:  DEC2    W8,W8
014A4:  BRA     NN,14A0
014A6:  MOV     W4,W5
014A8:  MOV     #A,W4
014AA:  BTSC    W5.8
014AC:  INC     W4,W4
014AE:  BSET    W5.E
014B0:  BTSC    W12.F
014B2:  BSET    W5.F
014B4:  CP0.B   W5L
014B6:  BRA     Z,14BA
014B8:  DEC.B   W5L,W5L
014BA:  MOV     W4,[W14]
014BC:  MOV     W5,[W14+#2]
014BE:  MOV     W6,W0
014C0:  MOV     W7,W1
014C2:  MOV     #CA00,W2
014C4:  MOV     #3B9A,W3
014C6:  MOV     #2710,W8
014C8:  BCLR    W13.F
014CA:  BCLR.B  43.0
014CC:  CALL    13FC
014D0:  BTG     W13.F
014D2:  BTSC    W13.F
014D4:  BRA     14E4
014D6:  MOV     W0,[W14+#8]
014D8:  MOV     W1,[W14+#A]
014DA:  MOV     W0,W2
014DC:  MOV     W1,W3
014DE:  MOV     [W14+#4],W0
014E0:  MOV     [W14+#6],W1
014E2:  BRA     14CA
014E4:  MOV     W2,[W14+#8]
014E6:  MOV     W3,[W14+#A]
014E8:  MOV     W4,[W14+#4]
014EA:  MOV     W5,[W14+#6]
014EC:  MOV     [W14],W4
014EE:  MOV     [W14+#2],W5
014F0:  MOV     #30,W6
014F2:  CP0     W0
014F4:  BRA     NZ,1518
014F6:  BTSS    W5.E
014F8:  BRA     151C
014FA:  DEC     W4,W4
014FC:  MOV     W4,[W14]
014FE:  CP0     W4
01500:  BRA     Z,151C
01502:  CP.B    W4L,W5L
01504:  BRA     Z,150A
01506:  BTSC.B  42.0
01508:  BRA     153A
0150A:  BTSS    W5.F
0150C:  BRA     1514
0150E:  BTSS    W5.8
01510:  BRA     1532
01512:  BRA     1522
01514:  MOV     #20,W6
01516:  BRA     1532
01518:  BCLR    W5.E
0151A:  MOV     W5,[W14+#2]
0151C:  MOV     [W14+#2],W5
0151E:  BTSS    W5.8
01520:  BRA     1532
01522:  BCLR    W5.8
01524:  MOV     W5,[W14+#2]
01526:  MOV     W0,W10
01528:  MOV     #2D,W0
0152A:  BTSC.B  223.1
0152C:  BRA     152A
0152E:  MOV     W0,224
01530:  MOV     W10,W0
01532:  ADD.B   W6L,W0L,W0L
01534:  BTSC.B  223.1
01536:  BRA     1534
01538:  MOV     W0,224
0153A:  MOV     [W14+#8],W0
0153C:  MOV     [W14+#A],W1
0153E:  MOV     #A,W2
01540:  CLR     W3
01542:  CP      W0,#1
01544:  BRA     Z,1548
01546:  BRA     14CA
01548:  ULNK    
0154A:  MOV     #1A,W5
0154C:  REPEAT  #7
0154E:  MOV     [--W15],[W5--]
01550:  MOV     [--W15],W5
01552:  RETURN  
*
01620:  MOV     W5,[W15++]
01622:  MOV     #C,W5
01624:  REPEAT  #3
01626:  MOV     [W5++],[W15++]
01628:  BTSS    W0.F
0162A:  BRA     1644
0162C:  NEG     W0,W0
0162E:  BSET    W4.8
01630:  BTSS    W4.F
01632:  BRA     1644
01634:  MOV     W0,[W15++]
01636:  MOV     #2D,W0
01638:  BTSC.B  223.1
0163A:  BRA     1638
0163C:  MOV     W0,224
0163E:  MOV     [--W15],W0
01640:  BCLR    W4.8
01642:  DEC.B   0008
01644:  CLR     W5
01646:  MOV     W0,W7
01648:  MOV     W4,W9
0164A:  BCLR    W4.F
0164C:  CP0.B   W4L
0164E:  BRA     NZ,165C
01650:  BTSC    W9.F
01652:  BRA     1658
01654:  MOV     #0,W5
01656:  BRA     1676
01658:  MOV     #0,W5
0165A:  BRA     1676
0165C:  SUB.B   W4L,#6,W5L
0165E:  BRA     NC,1674
01660:  MOV     #30,W0
01662:  BTSS    W9.F
01664:  MOV     #20,W0
01666:  BTSC.B  223.1
01668:  BRA     1666
0166A:  MOV     W0,224
0166C:  DEC     W5,W5
0166E:  BRA     NN,1666
01670:  MOV     #5,W5
01672:  BRA     1676
01674:  MOV     W4,W5
01676:  MOV     #6,W4
01678:  BTSC    W5.8
0167A:  INC     W4,W4
0167C:  BSET    W5.E
0167E:  BTSC    W9.F
01680:  BSET    W5.F
01682:  MOV     #2710,W8
01684:  REPEAT  #11
01686:  DIV.U   W7,W8
01688:  CALL    16CC
0168C:  MOV     W1,W7
0168E:  MOV     #3E8,W8
01690:  REPEAT  #11
01692:  DIV.U   W7,W8
01694:  CALL    16CC
01698:  MOV     W1,W7
0169A:  MOV     #64,W8
0169C:  REPEAT  #11
0169E:  DIV.U   W7,W8
016A0:  CALL    16CC
016A4:  MOV     W1,W7
016A6:  MOV     #A,W8
016A8:  REPEAT  #11
016AA:  DIV.U   W7,W8
016AC:  CALL    16CC
016B0:  BTSS    W9.8
016B2:  BRA     16BE
016B4:  MOV     #2D,W0
016B6:  BTSC.B  223.1
016B8:  BRA     16B6
016BA:  MOV     W0,224
016BC:  BCLR    W9.8
016BE:  MOV     #30,W0
016C0:  ADD.B   W1L,W0L,W0L
016C2:  MOV     W0,2A
016C4:  BTSC.B  223.1
016C6:  BRA     16C4
016C8:  MOV     W0,224
016CA:  BRA     170C
016CC:  MOV     #30,W6
016CE:  CP0     W0
016D0:  BRA     NZ,16EE
016D2:  BTSS    W5.E
016D4:  BRA     1702
016D6:  DEC     W4,W4
016D8:  CP.B    W4L,W5L
016DA:  BRA     Z,16E0
016DC:  BTSC.B  42.0
016DE:  RETURN  
016E0:  CP0     W0
016E2:  BRA     NZ,16EE
016E4:  BTSS    W5.E
016E6:  BRA     1702
016E8:  BTSS    W5.F
016EA:  MOV     #20,W6
016EC:  BRA     1702
016EE:  BCLR    W5.E
016F0:  BTSS    W9.8
016F2:  BRA     1702
016F4:  MOV     W0,W10
016F6:  MOV     #2D,W0
016F8:  BTSC.B  223.1
016FA:  BRA     16F8
016FC:  MOV     W0,224
016FE:  BCLR    W9.8
01700:  MOV     W10,W0
01702:  ADD.B   W6L,W0L,W0L
01704:  BTSC.B  223.1
01706:  BRA     1704
01708:  MOV     W0,224
0170A:  RETURN  
0170C:  MOV     #12,W5
0170E:  REPEAT  #3
01710:  MOV     [--W15],[W5--]
01712:  MOV     [--W15],W5
01714:  RETURN  
*
01AFA:  MOV     W5,[W15++]
01AFC:  MOV     #C,W5
01AFE:  REPEAT  #3
01B00:  MOV     [W5++],[W15++]
01B02:  MUL.UU  W0,W2,W4
01B04:  BTSS    W3.F
01B06:  BRA     1B0C
01B08:  MUL.SS  W0,W3,W6
01B0A:  BRA     1B0E
01B0C:  MUL.UU  W0,W3,W6
01B0E:  BCLR.B  42.0
01B10:  ADD     W6,W5,W5
01B12:  ADDC    W7,#0,W8
01B14:  BTSS    W1.F
01B16:  BRA     1B1C
01B18:  MUL.SS  W1,W2,W6
01B1A:  BRA     1B1E
01B1C:  MUL.UU  W1,W2,W6
01B1E:  ADDC    W6,W5,W5
01B20:  ADDC    W7,W8,W8
01B22:  ADDC    #0,W9
01B24:  MUL.SS  W1,W3,W6
01B26:  ADDC    W6,W8,W8
01B28:  ADDC    W9,W7,W7
01B2A:  MOV     W7,W3
01B2C:  MOV     W8,W2
01B2E:  MOV     W5,W1
01B30:  MOV     W4,W0
01B32:  MOV     #12,W5
01B34:  REPEAT  #3
01B36:  MOV     [--W15],[W5--]
01B38:  MOV     [--W15],W5
01B3A:  RETURN  
*
03782:  MOV     W5,[W15++]
03784:  MOV     #C,W5
03786:  REPEAT  #3
03788:  MOV     [W5++],[W15++]
0378A:  BTSS    W0.F
0378C:  BRA     37A8
0378E:  NEG     W0,W0
03790:  BSET    W4.8
03792:  BTSS    W4.F
03794:  BRA     37A8
03796:  MOV     W0,[W15++]
03798:  MOV     #2D,W0
0379A:  MOV     W0,[W15++]
0379C:  MOV     [--W15],W0
0379E:  CALL    12DE
037A2:  MOV     [--W15],W0
037A4:  BCLR    W4.8
037A6:  DEC.B   0008
037A8:  CLR     W5
037AA:  MOV     W0,W7
037AC:  MOV     W4,W9
037AE:  BCLR    W4.F
037B0:  CP0.B   W4L
037B2:  BRA     NZ,37C0
037B4:  BTSC    W9.F
037B6:  BRA     37BC
037B8:  MOV     #0,W5
037BA:  BRA     37DC
037BC:  MOV     #0,W5
037BE:  BRA     37DC
037C0:  SUB.B   W4L,#6,W5L
037C2:  BRA     NC,37DA
037C4:  MOV     #30,W0
037C6:  BTSS    W9.F
037C8:  MOV     #20,W0
037CA:  MOV     W0,[W15++]
037CC:  MOV     [--W15],W0
037CE:  CALL    12DE
037D2:  DEC     W5,W5
037D4:  BRA     NN,37CA
037D6:  MOV     #5,W5
037D8:  BRA     37DC
037DA:  MOV     W4,W5
037DC:  MOV     #6,W4
037DE:  BTSC    W5.8
037E0:  INC     W4,W4
037E2:  BSET    W5.E
037E4:  BTSC    W9.F
037E6:  BSET    W5.F
037E8:  MOV     #2710,W8
037EA:  REPEAT  #11
037EC:  DIV.U   W7,W8
037EE:  CALL    3836
037F2:  MOV     W1,W7
037F4:  MOV     #3E8,W8
037F6:  REPEAT  #11
037F8:  DIV.U   W7,W8
037FA:  CALL    3836
037FE:  MOV     W1,W7
03800:  MOV     #64,W8
03802:  REPEAT  #11
03804:  DIV.U   W7,W8
03806:  CALL    3836
0380A:  MOV     W1,W7
0380C:  MOV     #A,W8
0380E:  REPEAT  #11
03810:  DIV.U   W7,W8
03812:  CALL    3836
03816:  BTSS    W9.8
03818:  BRA     3826
0381A:  MOV     #2D,W0
0381C:  MOV     W0,[W15++]
0381E:  MOV     [--W15],W0
03820:  CALL    12DE
03824:  BCLR    W9.8
03826:  MOV     #30,W0
03828:  ADD.B   W1L,W0L,W0L
0382A:  MOV     W0,2A
0382C:  MOV     W0,[W15++]
0382E:  MOV     [--W15],W0
03830:  CALL    12DE
03834:  BRA     387E
03836:  MOV     #30,W6
03838:  CP0     W0
0383A:  BRA     NZ,3858
0383C:  BTSS    W5.E
0383E:  BRA     386E
03840:  DEC     W4,W4
03842:  CP.B    W4L,W5L
03844:  BRA     Z,384A
03846:  BTSC.B  42.0
03848:  RETURN  
0384A:  CP0     W0
0384C:  BRA     NZ,3858
0384E:  BTSS    W5.E
03850:  BRA     386E
03852:  BTSS    W5.F
03854:  MOV     #20,W6
03856:  BRA     386E
03858:  BCLR    W5.E
0385A:  BTSS    W9.8
0385C:  BRA     386E
0385E:  MOV     W0,W10
03860:  MOV     #2D,W0
03862:  MOV     W0,[W15++]
03864:  MOV     [--W15],W0
03866:  CALL    12DE
0386A:  BCLR    W9.8
0386C:  MOV     W10,W0
0386E:  ADD.B   W6L,W0L,W0L
03870:  MOV     W1,[W15++]
03872:  MOV     W0,[W15++]
03874:  MOV     [--W15],W0
03876:  CALL    12DE
0387A:  MOV     [--W15],W1
0387C:  RETURN  
0387E:  MOV     #12,W5
03880:  REPEAT  #3
03882:  MOV     [--W15],[W5--]
03884:  MOV     [--W15],W5
03886:  RETURN  
*
03CD2:  MOV     W5,[W15++]
03CD4:  MOV     #C,W5
03CD6:  REPEAT  #3
03CD8:  MOV     [W5++],[W15++]
03CDA:  MUL.UU  W0,W2,W4
03CDC:  MUL.UU  W0,W3,W6
03CDE:  BCLR.B  42.0
03CE0:  ADD     W6,W5,W5
03CE2:  ADDC    W7,#0,W8
03CE4:  MUL.UU  W1,W2,W6
03CE6:  ADDC    W6,W5,W5
03CE8:  ADDC    W7,W8,W8
03CEA:  MUL.UU  W1,W3,W6
03CEC:  ADD     W6,W8,W8
03CEE:  ADDC    #0,W7
03CF0:  MOV     W7,W3
03CF2:  MOV     W8,W2
03CF4:  MOV     W5,W1
03CF6:  MOV     W4,W0
03CF8:  MOV     #12,W5
03CFA:  REPEAT  #3
03CFC:  MOV     [--W15],[W5--]
03CFE:  MOV     [--W15],W5
03D00:  RETURN  
....................  
.................... #list 
....................  
.................... #device adc = 10 
.................... #fuses noprotect, nobrownout, nowdt, cksfsm, nojtag, icsp1 
.................... #use delay(clock =40000000, crystal = 20000000) 
*
012EC:  CP0     W0
012EE:  BTSC.B  42.1
012F0:  BRA     12FE
012F2:  REPEAT  #E1B
012F4:  NOP     
012F6:  REPEAT  #3FFE
012F8:  NOP     
012FA:  DEC     W0,W0
012FC:  BRA     NZ,12F2
012FE:  RETURN  
....................  
.................... #pin_select U1TX=PIN_E2 
.................... #pin_select U1RX=PIN_E4 
.................... #pin_select U2TX = PIN_F2 
.................... #pin_select U2RX = PIN_F6 
.................... #pin_select U3TX = PIN_E0 
.................... #pin_select U3RX = PIN_F1 
....................  
.................... #use rs232(UART1, errors, brgh1ok, baud= 57600, stream = DEBUG) 
.................... #use rs232(UART3, errors, brgh1ok, baud = 115200, stream = SIMM95) 
*
01376:  BTSS.B  252.0
01378:  BRA     1376
0137A:  PUSH    252
0137C:  POP     1000
0137E:  MOV     256,W0
01380:  BCLR.B  252.1
01382:  RETURN  
.................... #use rs232(UART2, errors, baud = 9600, parity = n, bits = 8, stop = 1, stream = MODBUS) 
*
010B4:  BTSS.B  232.0
010B6:  BRA     10B4
010B8:  PUSH    232
010BA:  POP     1000
010BC:  MOV     236,W0
010BE:  BCLR.B  232.1
010C0:  RETURN  
....................  
.................... #use timer(TIMER = 1, tick = 1ms, bits = 16, noisr, stream = T1) 
*
0132C:  MOV     14DE,W0
0132E:  MOV     #0,W1
01330:  MOV     #6,W3
01332:  BCLR.B  42.0
01334:  RLC     W0,W0
01336:  RLC     W1,W1
01338:  DEC     W3,W3
0133A:  BRA     NZ,1332
0133C:  MOV     W1,1002
0133E:  MOV     W0,100
01340:  RETURN  
01342:  BTSS.B  800.3
01344:  BRA     1354
01346:  INC     1002
01348:  MOV     100,W0
0134A:  INC     W0,W0
0134C:  BTSC.B  42.1
0134E:  CLR     100
01350:  BCLR.B  800.3
01352:  BRA     1366
01354:  MOV     100,W0
01356:  BTSS.B  800.3
01358:  BRA     1368
0135A:  INC     1002
0135C:  MOV     100,W0
0135E:  INC     W0,W0
01360:  BTSC.B  42.1
01362:  CLR     100
01364:  BCLR.B  800.3
01366:  MOV     100,W0
01368:  MOV     1002,W1
0136A:  MOV     #6,W2
0136C:  RRC     W1,W1
0136E:  RRC     W0,W0
01370:  DEC     W2,W2
01372:  BRA     NZ,136C
01374:  RETURN  
.................... #use timer(TIMER = 2, tick = 1ms, bits = 16, noisr, stream = T2) 
*
03C9E:  BTSS.B  800.7
03CA0:  BRA     3CB0
03CA2:  INC     1004
03CA4:  MOV     106,W0
03CA6:  INC     W0,W0
03CA8:  BTSC.B  42.1
03CAA:  CLR     106
03CAC:  BCLR.B  800.7
03CAE:  BRA     3CC2
03CB0:  MOV     106,W0
03CB2:  BTSS.B  800.7
03CB4:  BRA     3CC4
03CB6:  INC     1004
03CB8:  MOV     106,W0
03CBA:  INC     W0,W0
03CBC:  BTSC.B  42.1
03CBE:  CLR     106
03CC0:  BCLR.B  800.7
03CC2:  MOV     106,W0
03CC4:  MOV     1004,W1
03CC6:  MOV     #6,W2
03CC8:  RRC     W1,W1
03CCA:  RRC     W0,W0
03CCC:  DEC     W2,W2
03CCE:  BRA     NZ,3CC8
03CD0:  RETURN  
.................... #use timer(TIMER = 3, tick = 0.1ms, bits = 16, noisr, stream = T3) 
*
010C2:  MOV     15E6,W0
010C4:  MOV     #0,W1
010C6:  MOV     #3,W3
010C8:  BCLR.B  42.0
010CA:  RLC     W0,W0
010CC:  RLC     W1,W1
010CE:  DEC     W3,W3
010D0:  BRA     NZ,10C8
010D2:  MOV     W1,1006
010D4:  MOV     W0,10A
010D6:  RETURN  
*
039EA:  BTSS.B  801.0
039EC:  BRA     39FC
039EE:  INC     1006
039F0:  MOV     10A,W0
039F2:  INC     W0,W0
039F4:  BTSC.B  42.1
039F6:  CLR     10A
039F8:  BCLR.B  801.0
039FA:  BRA     3A0E
039FC:  MOV     10A,W0
039FE:  BTSS.B  801.0
03A00:  BRA     3A10
03A02:  INC     1006
03A04:  MOV     10A,W0
03A06:  INC     W0,W0
03A08:  BTSC.B  42.1
03A0A:  CLR     10A
03A0C:  BCLR.B  801.0
03A0E:  MOV     10A,W0
03A10:  MOV     1006,W1
03A12:  MOV     #3,W2
03A14:  RRC     W1,W1
03A16:  RRC     W0,W0
03A18:  DEC     W2,W2
03A1A:  BRA     NZ,3A14
03A1C:  RETURN  
....................  
.................... #define	pkey		pin_e1 
.................... #define	linkLed	pin_e5 
.................... #define	pwrLed	pin_e6 
.................... #define	dataLed	pin_e7 
....................  
.................... #define pinControl485	pin_f3 
....................  
.................... #endif 
....................  
.................... #include <M95.h> 
.................... #ifndef __M95_H_ 
.................... #define __M95_H_ 
....................  
.................... #include <stdbool.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                          stdbool.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard boolean definitions                                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __STDBOOL_H__ 
.................... #define __STDBOOL_H__ 
....................  
.................... //remove TRUE and FALSE added by CCS's device .h file 
.................... #if defined(TRUE) 
.................... #undef TRUE 
.................... #endif 
.................... #if defined(FALSE) 
.................... #undef FALSE 
.................... #endif 
....................  
.................... typedef int1   bool; 
.................... #define true   1 
.................... #define false  0 
.................... #define __bool_true_false_are_defined  1 
....................  
.................... #endif 
....................  
....................  
.................... #define	CONNECT				1 
.................... #define	CONNACK				2 
.................... #define	PUBLISH				3 
.................... #define	PUBACK				4 
.................... #define	PUBREC				5 
.................... #define	PUBREL				6 
.................... #define	PUBCOMP				7 
.................... #define	SUBSCRIBE			8 
.................... #define	SUBACK				9 
.................... #define	UNSUBSCRIBE		10 
.................... #define	UNSUBACK			11 
.................... #define	PINGREQ				12 
.................... #define	PINGRESP			13 
.................... #define	DISCONNECT		14 
.................... #define	AUTH					15 
....................  
.................... #define	dupMask				8 
.................... #define	QoSMask				6 
.................... #define QoSScale				2 
.................... #define	retainMask			1 
....................  
.................... #define	userNameFlagMask	128 
.................... #define	passwordFlagMask		64 
.................... #define willRetainMask			32 
.................... #define	willQoSMask				24 
.................... #define	willQoSScale				8 
.................... #define	willFlagMask				4 
.................... #define	cleanSessionMask		2 
....................  
.................... #define	DISCONNECTED	0 
.................... #define	CONNECTED			1 
.................... #define	NOACKNOWLEDGEMENT	255 
....................  
.................... struct UART3struct{ 
.................... 	char rxDataString[256]; 
.................... 	unsigned int8	rxPointer; 
.................... }uart3; 
....................  
.................... typedef struct{ 
.................... 	char mqttClientID[100]; 
.................... 	bool	passwordFlag; 
.................... 	bool	userNameFlag; 
.................... 	char	password[64]; 
.................... 	char	userName[64]; 
.................... 	bool	cleanSession; 
.................... 	bool	willFlag; 
.................... 	bool	willQoS; 
.................... 	bool	willRetain; 
.................... 	char	willTopic; 
.................... 	char	willMessage; 
.................... }client; 
....................  
.................... client		*mqttClient; 
....................  
.................... char inputString[256]; 
.................... unsigned int index; 
.................... bool stringComplete = false; 
.................... bool	tcpFlag = false; 
.................... bool	reconnectFlag = false; 
....................  
.................... bool	mqttQuery = true; 
....................  
.................... bool	subTopicFlag; 
.................... bool	pubTopicFlag; 
.................... bool	messageFlag; 
.................... char *subTopic; 
.................... char *pubTopic; 
.................... char *message; 
....................  
.................... static char json[70]; 
....................  
.................... char	*mqttHost; 
.................... char *mqttPort; 
....................  
.................... char *at; 
.................... char *strresponse; 
....................  
.................... unsigned int16	connectionAcknowledgement = NOACKNOWLEDGEMENT; 
....................  
.................... bool finishString = false; 
.................... bool mqttFlag = false; 
.................... bool pingFlag = false; 
.................... unsigned long	len; 
.................... unsigned long	lengthLocal; 
.................... unsigned long	messageLength = 0; 
.................... volatile unsigned int	protocolVersion = 4;	//MQTT Protocol version 3.1.1 
.................... volatile unsigned int	gsmResponse = 0; 
.................... volatile unsigned int	gsmResponseFlag = 0; 
.................... volatile unsigned int	modemStatus = 0; 
.................... volatile unsigned int	tcpStatus = 0; 
.................... volatile unsigned int 	tcpStatusPrev; 
.................... volatile unsigned int	gsmSendResponse = 0; 
.................... volatile unsigned int16 lassMessageID = 0; 
.................... unsigned int	tcpATErrorCount = 0; 
.................... unsigned long	keepAliveTimeout; 
.................... unsigned long	pingPrevTicks = 0; 
.................... unsigned int packetType; 
....................  
.................... unsigned int32 delay1 = 0, delay2 = 0; 
....................  
.................... char *reply; 
.................... char t_topic[100]; 
.................... char t_message[256]; 
.................... void powerOnM95(); 
.................... char serialEvent(); 
.................... char sendAT(char * command, unsigned long waitms); 
.................... char sendATResponse(char *command, char *responseStr, unsigned long waitms); 
.................... void tcpInit(); 
.................... void mqttProcessing(); 
.................... void begin(); 
.................... void autoConnect(); 
.................... void mqttConect(client *mqttClient); 
.................... bool mqttAvailable(); 
.................... void publishACK(unsigned int16 messageID); 
.................... void publishREC(unsigned int16 messageID); 
.................... void publishREL(unsigned int1 DUP, unsigned int16 messageID); 
.................... void publishCOMP(unsigned int16 messageID); 
.................... void pingRequest(); 
.................... void pingResponse(); 
.................... void connectReturnCode(unsigned int ack); 
....................  
.................... #endif 
....................  
.................... #include <modbus_485.h> 
.................... #ifndef __MODBUS_485_H_ 
.................... #define	__MODBUS_485_H_ 
....................  
.................... #include <stdbool.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                          stdbool.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard boolean definitions                                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __STDBOOL_H__ 
.................... #define __STDBOOL_H__ 
....................  
.................... //remove TRUE and FALSE added by CCS's device .h file 
.................... #if defined(TRUE) 
.................... #undef TRUE 
.................... #endif 
.................... #if defined(FALSE) 
.................... #undef FALSE 
.................... #endif 
....................  
.................... typedef int1   bool; 
.................... #define true   1 
.................... #define false  0 
.................... #define __bool_true_false_are_defined  1 
....................  
.................... #endif 
....................  
....................  
.................... #define	slaveID	1 
....................  
.................... #define	MODBUS_SERIAL_TIMEOUT	10000 
.................... #define MODBUS_GETDATA_TIMEOUT	40 
....................  
.................... typedef enum _exception{ 
.................... 	ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2, 
.................... 	ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6, 
.................... 	MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... 	TIMEOUT=12 
.................... } exception; 
.................... typedef enum _function{ 
.................... 	FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... 	FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... 	FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... 	FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... 	FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... 	FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... 	FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... 	FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... 	FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18 
.................... } function; 
....................  
.................... struct{ 
.................... 	unsigned int8	address; 
.................... 	unsigned int8	len; 
.................... 	function	func; 
.................... 	exception	error; 
.................... 	unsigned int8 data[64]; 
.................... }modbusRx; 
....................  
.................... union{ 
.................... 	unsigned int8 b[2]; 
.................... 	unsigned int16	d; 
.................... }modbusSerialCrc; 
....................  
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... const unsigned char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
....................  
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbusSerialState = 0; 
.................... enum {RTD_CHANNEL_1 = 0, RTD_CHANNEL_2 = 1, RTD_CHANNEL_3 = 2, RTD_CHANNEL_4 = 3} numOfChannelRTD = 0; 
....................  
.................... //void modbusSerialWaitResponse(); 
.................... void modbusCalcCrc(char data); 
.................... void modbusEnableTimeout(int1 enable); 
.................... //void interruptReceiveModbus(); 
....................  
.................... bool modbusTimeoutEnable = false; 
.................... bool modbusTimeoutEnabled = false; 
.................... bool modbusSerialNew = false; 
.................... bool modbusTimeoutOK = false; 
.................... bool modbusQuery = false; 
.................... unsigned int32 modbusSerialWait = MODBUS_SERIAL_TIMEOUT; 
.................... unsigned int8 crcHigh, crcLow; 
.................... unsigned int8 caseSend = 0; 
.................... bool sendMessageComplete = false; 
.................... bool modbusResponseOK = false; 
....................  
.................... unsigned int16 dataHigh[4], dataLow[4]; 
.................... unsigned int8 numOfReg = 0; 
....................  
.................... unsigned int32 time = 0; 
....................  
.................... unsigned long tam = 0; 
....................  
.................... unsigned int8 stack = 1; 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
*
034EC:  MOV     W5,[W15++]
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
034EE:  MOV     1486,W0
034F0:  MOV.B   [W0],W5L
034F2:  MOV     1488,W0
034F4:  MOV     W0,W4
034F6:  MOV.B   [W4],W0L
034F8:  CP.B    W5L,W0L
034FA:  BRA     NZ,3510
....................       if (*s1 == '\0') 
034FC:  MOV     1486,W0
034FE:  CP0.B   [W0]
03500:  BRA     NZ,3506
....................          return(0); 
03502:  CLR.B   0
03504:  BRA     3526
03506:  MOV     1486,W0
03508:  INC     1486
0350A:  INC     1488
0350C:  GOTO    34EE
....................    return((*s1 < *s2) ? -1: 1); 
03510:  MOV     1486,W0
03512:  MOV.B   [W0],W5L
03514:  MOV     1488,W0
03516:  MOV     W0,W4
03518:  MOV.B   [W4],W0L
0351A:  CP.B    W5L,W0L
0351C:  BRA     GE,3524
0351E:  SETM.B  W0
03520:  GOTO    3526
03524:  MOV.B   #1,W0L
03526:  MOV     [--W15],W5
03528:  RETURN  
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
*
01384:  MOV     W5,[W15++]
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
01386:  MOV     1534,W0
01388:  CP0.B   [W0]
0138A:  BRA     Z,13C2
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
0138C:  PUSH    1534
0138E:  POP     1538
01390:  PUSH    1536
01392:  POP     153A
01394:  MOV     153A,W0
01396:  CP0.B   [W0]
01398:  BRA     Z,13B0
0139A:  MOV     1538,W0
0139C:  MOV.B   [W0],W5L
0139E:  MOV     153A,W0
013A0:  MOV     W0,W4
013A2:  MOV.B   [W4],W0L
013A4:  CP.B    W5L,W0L
013A6:  BRA     NZ,13B0
013A8:  INC     1538
013AA:  INC     153A
013AC:  GOTO    1394
....................  
....................       if (*t == '\0') 
013B0:  MOV     153A,W0
013B2:  CP0.B   [W0]
013B4:  BRA     NZ,13BC
....................          return s1; 
013B6:  PUSH    1534
013B8:  POP     0
013BA:  BRA     13C4
....................       ++s1; 
013BC:  INC     1534
....................       #ifdef FASTER_BUT_MORE_ROM 
013BE:  GOTO    1386
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
013C2:  CLR     0
013C4:  MOV     [--W15],W5
013C6:  RETURN  
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
*
01554:  MOV     W5,[W15++]
01556:  MOV     W6,[W15++]
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
01558:  PUSH    154E
0155A:  POP     1550
0155C:  MOV     1550,W0
0155E:  MOV.B   [W0],W5L
01560:  SE      W5,W5
01562:  CP0     W5
01564:  BRA     Z,156C
01566:  INC     1550
01568:  GOTO    155C
....................    return(sc - s); 
0156C:  MOV     1550,W4
0156E:  MOV     154E,W3
01570:  SUB     W4,W3,W0
01572:  MOV     [--W15],W6
01574:  MOV     [--W15],W5
01576:  RETURN  
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
.................... #USE DYNAMIC_MEMORY 
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
....................  #define _MEMMGMT_CSIZE 32768 
....................  #define _MEMMGMT_POS 15 
.................... #elif defined(__PCD__) 
....................    #define _MEMMGMT_CSIZE 32768 
....................    #define _MEMMGMT_POS 15 
.................... #else 
....................    #define _MEMMGMT_CSIZE 127 
....................    #define _MEMMGMT_POS 7 
.................... #endif 
....................  
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location 
*
011BA:  MOV     W5,[W15++]
.................... { 
....................    node_t *result; 
....................    result =ptr; 
011BC:  PUSH    14DE
011BE:  POP     14E0
....................    result->size=size; 
011C0:  MOV     #0,W0
011C2:  ADD     14E0,W0
011C4:  MOV     W0,W5
011C6:  MOV     14DC,W4
011C8:  MOV     W4,[W5+#0]
....................    result->next = NULL; 
011CA:  MOV     #2,W0
011CC:  ADD     14E0,W0
011CE:  MOV     W0,W5
011D0:  CLR.B   [W5]
011D2:  MOV.B   #0,W0L
011D4:  MOV.B   W0L,[W5+#1]
....................    return result; 
011D6:  PUSH    14E0
011D8:  POP     0
011DA:  MOV     [--W15],W5
011DC:  RETURN  
.................... } 
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node 
*
01214:  MOV     W5,[W15++]
.................... { 
....................    node->size=size; 
01216:  MOV     #0,W0
01218:  ADD     14DA,W0
0121A:  MOV     W0,W5
0121C:  MOV     14DC,W4
0121E:  MOV     W4,[W5+#0]
01220:  MOV     [--W15],W5
01222:  RETURN  
.................... } 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node 
*
011DE:  MOV     W5,[W15++]
.................... { 
....................     if (place->next==NULL) 
011E0:  MOV     #2,W0
011E2:  ADD     14D8,W0
011E4:  MOV     [W0],W5
011E6:  CP0     W5
011E8:  BRA     NZ,11FA
....................        node->next= NULL; 
011EA:  MOV     #2,W0
011EC:  ADD     14DA,W0
011EE:  MOV     W0,W5
011F0:  CLR.B   [W5]
011F2:  MOV.B   #0,W0L
011F4:  MOV.B   W0L,[W5+#1]
011F6:  GOTO    1206
....................     else 
....................        node->next=place->next; 
011FA:  MOV     #2,W0
011FC:  ADD     14DA,W0
011FE:  MOV     W0,W5
01200:  MOV     #2,W0
01202:  ADD     14D8,W0
01204:  MOV     [W0],[W5]
....................     place->next=node; 
01206:  MOV     #2,W0
01208:  ADD     14D8,W0
0120A:  MOV     W0,W5
0120C:  MOV     14DA,W4
0120E:  MOV     W4,[W5+#0]
01210:  MOV     [--W15],W5
01212:  RETURN  
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
....................    ptr->next=node->next; 
....................    node=NULL; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__DO_DEBUG_STDLIBM) 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     debug_stdlibm("\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................     { 
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next); 
....................         debug_stdlibm(g_DebugStdlibmStr); 
....................         if (INVALID_MEMORY_LOCATION(node->next)) 
....................         { 
....................            debug_stdlibm("Breaking because of invalid next node\r\n"); 
....................            break; 
....................         }    
....................     } 
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t)); 
....................     debug_stdlibm(g_DebugStdlibmStr); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
....................    while(node!=NULL) 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
....................       { 
....................          nsize=node->size; 
....................          temp=(unsigned int16)node->next; 
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
....................          { 
....................             nextsize=temp->size; 
....................             nsize+=nextsize+sizeof(node_t); 
....................             remove_node(temp); 
....................             update_node(node,nsize); 
....................          } 
....................          else 
....................          node=node->next; 
....................       } 
....................       else 
....................       node=node->next; 
....................    } 
.................... } 
....................  
.................... char *malloc(size_t size) 
*
01224:  MOV     W5,[W15++]
01226:  MOV     W6,[W15++]
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
01228:  MOV     14CC,W0
0122A:  AND     W0,#1,W0
0122C:  CP0     W0
0122E:  BRA     Z,1232
....................       size++; 
01230:  INC     14CC
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
01232:  PUSH    146C
01234:  POP     14CE
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu\r\n", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
01236:  CP0     14CE
01238:  BRA     Z,12C2
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
0123A:  MOV     #0,W0
0123C:  ADD     14CE,W0
0123E:  MOV     [W0],W5
01240:  BTSC    W5.F
01242:  BRA     12B6
01244:  MOV     #0,W0
01246:  ADD     14CE,W0
01248:  MOV     [W0],W6
0124A:  MOV     14CC,W4
0124C:  CP      W4,W6
0124E:  BRA     GTU,12B6
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
01250:  MOV     #0,W0
01252:  ADD     14CE,W0
01254:  MOV     [W0],[W15++]
01256:  POP     14D2
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
01258:  MOV     14CC,W4
0125A:  ADD     W4,#4,W4
0125C:  MOV     W4,W0
0125E:  MOV     14D2,W4
01260:  CP      W4,W0
01262:  BRA     LEU,12A2
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
01264:  MOV     14D2,W4
01266:  MOV     14CC,W3
01268:  SUB     W4,W3,W5
0126A:  SUB     W5,#4,W5
0126C:  MOV     14CE,W4
0126E:  ADD     W4,#4,W4
01270:  MOV     W4,W6
01272:  MOV     W6,W0
01274:  ADD     14CC,W0
01276:  MOV     W0,W6
01278:  MOV     W5,14DC
0127A:  MOV     W6,14DE
0127C:  CALL    11BA
01280:  MOV     W0,14D0
....................             insert_node_after(node,new); 
01282:  PUSH    14CE
01284:  POP     14D8
01286:  PUSH    14D0
01288:  POP     14DA
0128A:  CALL    11DE
....................             update_node(node,size+_MEMMGMT_CSIZE); 
0128E:  MOV     #8000,W4
01290:  MOV     14CC,W3
01292:  ADD     W3,W4,W5
01294:  PUSH    14CE
01296:  POP     14DA
01298:  MOV     W5,14DC
0129A:  CALL    1214
....................          } 
0129E:  GOTO    12B2
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
012A2:  MOV     #8000,W4
012A4:  MOV     14D2,W3
012A6:  ADD     W3,W4,W5
012A8:  PUSH    14CE
012AA:  POP     14DA
012AC:  MOV     W5,14DC
012AE:  CALL    1214
....................          //end if 
....................          break; 
012B2:  GOTO    12C2
....................       }//end if 
....................       node=node->next; 
012B6:  MOV     #2,W0
012B8:  ADD     14CE,W0
012BA:  MOV     [W0],[W15++]
012BC:  POP     14CE
012BE:  GOTO    1236
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
012C2:  CP0     14CE
012C4:  BRA     NZ,12CE
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
012C6:  CLR     0
012C8:  BRA     12D8
....................    } 
012CA:  GOTO    12D8
....................    else 
....................    return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
012CE:  MOV     14CE,W4
012D0:  ADD     W4,#4,W4
012D2:  MOV     W4,W0
012D4:  MOV     W0,0
012D6:  BRA     12D8
012D8:  MOV     [--W15],W6
012DA:  MOV     [--W15],W5
012DC:  RETURN  
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
....................       return; 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          update_node(node,nsize); 
....................          ptr=NULL; 
....................  
....................       } 
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
....................          return; 
....................       } 
....................    } 
....................    traverse(); 
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                    
....................  
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
.................... #ENDIF 
....................  
....................  
.................... unsigned int16 temp[4]; 
....................  
.................... #int_rda2 
.................... void interruptReceiveModbus(){ 
*
01106:  PUSH    42
01108:  PUSH    36
0110A:  PUSH    54
0110C:  MOV     W0,[W15++]
0110E:  MOV     #2,W0
01110:  REPEAT  #C
01112:  MOV     [W0++],[W15++]
.................... 	unsigned char c; 
.................... 	//output_low(pinControl485); 
.................... 	if(kbhit(MODBUS)){ 
01114:  BTSS.B  232.0
01116:  BRA     11A8
.................... 		output_high(dataLed); 
01118:  BCLR.B  E40.7
0111A:  BSET.B  E44.7
.................... 		c = fgetc(MODBUS); 
0111C:  CALL    10B4
01120:  MOV.B   W0L,15E0
.................... 		fputc(c, DEBUG); 
01122:  MOV.B   15E0,W0L
01124:  BTSC.B  223.1
01126:  BRA     1124
01128:  MOV.B   W0L,224
0112A:  CLR.B   225
.................... 		if(modbusSerialState == MODBUS_GETADDY){ 
0112C:  CP0.B   1265
0112E:  BRA     NZ,1142
.................... 			modbusSerialCrc.d = 0xffff; 
01130:  SETM    1440
.................... 			modbusRx.address = c; 
01132:  MOV.B   15E0,W0L
01134:  MOV.B   W0L,13FC
.................... 			modbusRx.len = 0; 
01136:  CLR.B   13FD
.................... 			modbusRx.error = 0; 
01138:  CLR.B   13FF
.................... 			modbusSerialState = MODBUS_GETFUNC; 
0113A:  MOV.B   #1,W0L
0113C:  MOV.B   W0L,1265
.................... 		} 
0113E:  GOTO    117A
.................... 		else if(modbusSerialState == MODBUS_GETFUNC){ 
01142:  MOV     1264,W4
01144:  LSR     W4,#8,W4
01146:  CP.B    W4L,#1
01148:  BRA     NZ,1158
.................... 			modbusRx.func = c; 
0114A:  MOV.B   15E0,W0L
0114C:  MOV.B   W0L,13FE
.................... 			modbusRx.len = 0; 
0114E:  CLR.B   13FD
.................... 			modbusSerialState = MODBUS_GETDATA; 
01150:  MOV.B   #2,W0L
01152:  MOV.B   W0L,1265
.................... 		} 
01154:  GOTO    117A
.................... 		else if(modbusSerialState == MODBUS_GETDATA){ 
01158:  MOV     1264,W4
0115A:  LSR     W4,#8,W4
0115C:  CP.B    W4L,#2
0115E:  BRA     NZ,117A
.................... 			modbusRx.data[modbusRx.len] = c; 
01160:  MOV     13FC,W4
01162:  LSR     W4,#8,W4
01164:  MOV     #1400,W3
01166:  ADD     W3,W4,W5
01168:  MOV     15E0,W0
0116A:  MOV.B   W0L,[W5+#0]
.................... 			modbusRx.len++; 
0116C:  INC.B   13FD
.................... 			if(modbusRx.len > 64)	modbusRx.len = 0; 
0116E:  MOV     13FC,W4
01170:  LSR     W4,#8,W4
01172:  MOV     #40,W3
01174:  CP.B    W3L,W4L
01176:  BRA     C,117A
01178:  CLR.B   13FD
.................... 		} 
.................... 		modbusEnableTimeout(true); 
0117A:  MOV.B   #1,W0L
0117C:  MOV.B   W0L,15E2
0117E:  CALL    10D8
.................... 		modbusCalcCrc(c); 
01182:  MOV.B   15E0,W0L
01184:  MOV.B   W0L,15E2
01186:  CALL    10E6
.................... 		modbusSerialWait = MODBUS_SERIAL_TIMEOUT; 
0118A:  MOV     #2710,W4
0118C:  MOV     W4,1444
0118E:  CLR     1446
.................... 		if((modbusSerialCrc.b[0] == 0x00) && (modbusSerialCrc.b[1] == 0x00)){ 
01190:  CP0.B   1440
01192:  BRA     NZ,11A0
01194:  CP0.B   1441
01196:  BRA     NZ,11A0
.................... 			sendMessageComplete = true; 
01198:  BSET.B  1264.7
.................... 			//fputc(modbusserialcrc.b[0], MODBUS); 
.................... 			//fputc(modbusSerialCrc.b[1], MODBUS); 
.................... 			output_low(dataLed); 
0119A:  BCLR.B  E40.7
0119C:  BCLR.B  E44.7
.................... 			modbusSerialState = MODBUS_GETADDY; 
0119E:  CLR.B   1265
....................  
.................... 		} 
.................... 		modbusResponseOK = false; 
011A0:  BCLR.B  144A.0
.................... 		modbusQuery = true; 
011A2:  BSET.B  1264.6
.................... 		output_low(dataLed); 
011A4:  BCLR.B  E40.7
011A6:  BCLR.B  E44.7
.................... 	} 
.................... } 
....................  
011A8:  BCLR.B  803.6
011AA:  MOV     #1A,W0
011AC:  REPEAT  #C
011AE:  MOV     [--W15],[W0--]
011B0:  MOV     [--W15],W0
011B2:  POP     54
011B4:  POP     36
011B6:  POP     42
011B8:  RETFIE  
.................... #define modbusSerialWaitResponse() {\ 
.................... 	modbusTimeoutOK = false;\ 
.................... 	modbusTimeoutEnable = false;\ 
.................... 	output_low(pinControl485);\ 
.................... 	if(address){\ 
.................... 		while((!modbus_kbhit()) && (--modbusSerialWait)){\ 
.................... 			modbusResponseOK = false;\ 
.................... 		}\ 
.................... 		if(!modbusSerialWait){\ 
.................... 			modbusRx.error = TIMEOUT;\ 
.................... 			modbusTimeoutOK = false;\ 
.................... 			modbusSerialWait = MODBUS_SERIAL_TIMEOUT;\ 
.................... 		}\ 
.................... 	}\ 
.................... }\ 
....................  
.................... void powerOnM95(){ 
.................... 	fprintf(DEBUG, "Power On Module SIM M95\r\n"); 
*
01300:  MOV     #0,W1
01302:  MOV     W1,W0
01304:  CLR.B   1
01306:  CALL    390
0130A:  INC     W1,W1
0130C:  BTSC.B  223.1
0130E:  BRA     130C
01310:  MOV     W0,224
01312:  MOV     #18,W0
01314:  CPSGT   W1,W0
01316:  BRA     1302
.................... 	output_high(PKEY); 
01318:  BCLR.B  E40.1
0131A:  BSET.B  E44.1
.................... 	output_low(PKEY); 
0131C:  BCLR.B  E40.1
0131E:  BCLR.B  E44.1
.................... 	delay_ms(2000); 
01320:  MOV     #7D0,W0
01322:  CALL    12EC
.................... //	output_high(PKEY); 
.................... 	output_high(pwrLed); 
01326:  BCLR.B  E40.6
01328:  BSET.B  E44.6
0132A:  RETURN  
.................... } 
....................  
.................... char serialEvent(){ 
*
01E5A:  MOV     W5,[W15++]
01E5C:  MOV     W6,[W15++]
01E5E:  MOV     W7,[W15++]
01E60:  MOV     W8,[W15++]
.................... 	unsigned int16 iteraction; 
.................... 	char inchar; 
.................... 	if(kbhit(SIMM95)){ 
01E62:  BTSS.B  252.0
01E64:  BRA     2DA0
.................... 		output_high(dataLed); 
01E66:  BCLR.B  E40.7
01E68:  BSET.B  E44.7
.................... 		inchar = fgetc(SIMM95); 
01E6A:  CALL    1376
01E6E:  MOV.B   W0L,14E0
.................... 		if(tcpFlag == false){ 
01E70:  BTSC.B  1109.1
01E72:  BRA     22DE
.................... 			if(index < 200){ 
01E74:  MOV     120C,W4
01E76:  MOV     #C8,W3
01E78:  CP      W3,W4
01E7A:  BRA     LEU,1E8A
.................... 				inputString[index++] = inchar; 
01E7C:  MOV     120C,W0
01E7E:  INC     120C
01E80:  MOV     W0,W5
01E82:  MOV     #110C,W4
01E84:  ADD     W5,W4,W6
01E86:  MOV     14E0,W0
01E88:  MOV.B   W0L,[W6+#0]
.................... //				fputc(inchar, DEBUG); 
.................... 			} 
.................... 			if(inchar == '\n'){ 
01E8A:  MOV     14E0,W4
01E8C:  CP.B    W4L,#A
01E8E:  BRA     NZ,22DA
.................... 				inputString[index] = 0; 
01E90:  MOV     #110C,W4
01E92:  MOV     120C,W3
01E94:  ADD     W3,W4,W5
01E96:  CLR.B   [W5]
.................... 				index = 0; 
01E98:  CLR     120C
.................... 				fprintf(DEBUG, inputString);			 
01E9A:  MOV     #110C,W1
01E9C:  CP0.B   [W1]
01E9E:  BRA     Z,1EAE
01EA0:  BTSC.B  223.1
01EA2:  BRA     1EA0
01EA4:  MOV.B   [W1+#0],W0L
01EA6:  MOV.B   W0L,224
01EA8:  CLR.B   225
01EAA:  INC     W1,W1
01EAC:  BRA     1E9C
.................... 				if(strstr(inputString, (char *)("OK")) != 0){ 
01EAE:  MOV     #3,W3
01EB0:  MOV     #0,W2
01EB2:  MOV     #14E2,W1
01EB4:  MOV     W3,[W15++]
01EB6:  MOV     W2,W0
01EB8:  CALL    3B6
01EBC:  MOV     [--W15],W3
01EBE:  MOV.B   W0L,[W1++]
01EC0:  INC     W2,W2
01EC2:  DEC     W3,W3
01EC4:  BTSS.B  42.1
01EC6:  BRA     1EB4
01EC8:  MOV     #110C,W4
01ECA:  MOV     W4,1534
01ECC:  MOV     #14E2,W4
01ECE:  MOV     W4,1536
01ED0:  CALL    1384
01ED4:  MOV     W0,W5
01ED6:  CP0     W5
01ED8:  BRA     Z,1EE2
.................... 					gsmResponse = 1; 
01EDA:  MOV     #1,W4
01EDC:  MOV     W4,1274
.................... 				} 
01EDE:  GOTO    22DA
.................... 				else if(strstr(inputString, (char*)("ERROR")) != 0){ 
01EE2:  MOV     #6,W3
01EE4:  MOV     #0,W2
01EE6:  MOV     #14E2,W1
01EE8:  MOV     W3,[W15++]
01EEA:  MOV     W2,W0
01EEC:  CALL    3C6
01EF0:  MOV     [--W15],W3
01EF2:  MOV.B   W0L,[W1++]
01EF4:  INC     W2,W2
01EF6:  DEC     W3,W3
01EF8:  BTSS.B  42.1
01EFA:  BRA     1EE8
01EFC:  MOV     #110C,W4
01EFE:  MOV     W4,1534
01F00:  MOV     #14E2,W4
01F02:  MOV     W4,1536
01F04:  CALL    1384
01F08:  MOV     W0,W5
01F0A:  CP0     W5
01F0C:  BRA     Z,1F18
.................... 					gsmResponse = 2; 
01F0E:  MOV     #2,W4
01F10:  MOV     W4,1274
.................... 					tcpFlag = false; 
01F12:  BCLR.B  1109.1
.................... 				} 
01F14:  GOTO    22DA
.................... 				else if(strstr(inputString, (char*)(".")) != 0){ 
01F18:  MOV     #2,W3
01F1A:  MOV     #0,W2
01F1C:  MOV     #14E2,W1
01F1E:  MOV     W3,[W15++]
01F20:  MOV     W2,W0
01F22:  CALL    3D8
01F26:  MOV     [--W15],W3
01F28:  MOV.B   W0L,[W1++]
01F2A:  INC     W2,W2
01F2C:  DEC     W3,W3
01F2E:  BTSS.B  42.1
01F30:  BRA     1F1E
01F32:  MOV     #110C,W4
01F34:  MOV     W4,1534
01F36:  MOV     #14E2,W4
01F38:  MOV     W4,1536
01F3A:  CALL    1384
01F3E:  MOV     W0,W5
01F40:  CP0     W5
01F42:  BRA     Z,1F4C
.................... 					gsmResponse = 3; 
01F44:  MOV     #3,W4
01F46:  MOV     W4,1274
.................... 				} 
01F48:  GOTO    22DA
.................... 				else if(strstr(inputString, (char*)("CONNECT FAIL")) != 0){ 
01F4C:  MOV     #D,W3
01F4E:  MOV     #0,W2
01F50:  MOV     #14E2,W1
01F52:  MOV     W3,[W15++]
01F54:  MOV     W2,W0
01F56:  CALL    3E6
01F5A:  MOV     [--W15],W3
01F5C:  MOV.B   W0L,[W1++]
01F5E:  INC     W2,W2
01F60:  DEC     W3,W3
01F62:  BTSS.B  42.1
01F64:  BRA     1F52
01F66:  MOV     #110C,W4
01F68:  MOV     W4,1534
01F6A:  MOV     #14E2,W4
01F6C:  MOV     W4,1536
01F6E:  CALL    1384
01F72:  MOV     W0,W5
01F74:  CP0     W5
01F76:  BRA     Z,1F80
.................... 					gsmResponse = 5; 
01F78:  MOV     #5,W4
01F7A:  MOV     W4,1274
.................... 				} 
01F7C:  GOTO    22DA
.................... 				else if(strstr(inputString, (char*)("CONNECT OK")) != 0){ 
01F80:  MOV     #B,W3
01F82:  MOV     #0,W2
01F84:  MOV     #14E2,W1
01F86:  MOV     W3,[W15++]
01F88:  MOV     W2,W0
01F8A:  CALL    400
01F8E:  MOV     [--W15],W3
01F90:  MOV.B   W0L,[W1++]
01F92:  INC     W2,W2
01F94:  DEC     W3,W3
01F96:  BTSS.B  42.1
01F98:  BRA     1F86
01F9A:  MOV     #110C,W4
01F9C:  MOV     W4,1534
01F9E:  MOV     #14E2,W4
01FA0:  MOV     W4,1536
01FA2:  CALL    1384
01FA6:  MOV     W0,W5
01FA8:  CP0     W5
01FAA:  BRA     Z,1FDC
.................... 					tcpFlag = true; 
01FAC:  BSET.B  1109.1
.................... 					pingFlag = true; 
01FAE:  BSET.B  1264.1
.................... 					gsmResponse = 4; 
01FB0:  MOV     #4,W4
01FB2:  MOV     W4,1274
.................... 					fprintf(DEBUG, "TCP Connected\r\n"); 
01FB4:  MOV     #0,W1
01FB6:  MOV     W1,W0
01FB8:  CLR.B   1
01FBA:  CALL    418
01FBE:  INC     W1,W1
01FC0:  BTSC.B  223.1
01FC2:  BRA     1FC0
01FC4:  MOV     W0,224
01FC6:  MOV     #E,W0
01FC8:  CPSGT   W1,W0
01FCA:  BRA     1FB6
.................... 					autoConnect(); 
01FCC:  CALL    1AF0
.................... 					tcpATErrorCount = 0; 
01FD0:  CLR     1282
.................... 					output_high(linkLed); 
01FD2:  BCLR.B  E40.5
01FD4:  BSET.B  E44.5
.................... 					return; 
01FD6:  BRA     2DA0
.................... 				} 
01FD8:  GOTO    22DA
.................... 				else if(strstr(inputString, (char*)("CONNECT\r\n")) != 0){ 
01FDC:  MOV     #A,W3
01FDE:  MOV     #0,W2
01FE0:  MOV     #14E2,W1
01FE2:  MOV     W3,[W15++]
01FE4:  MOV     W2,W0
01FE6:  CALL    434
01FEA:  MOV     [--W15],W3
01FEC:  MOV.B   W0L,[W1++]
01FEE:  INC     W2,W2
01FF0:  DEC     W3,W3
01FF2:  BTSS.B  42.1
01FF4:  BRA     1FE2
01FF6:  MOV     #110C,W4
01FF8:  MOV     W4,1534
01FFA:  MOV     #14E2,W4
01FFC:  MOV     W4,1536
01FFE:  CALL    1384
02002:  MOV     W0,W5
02004:  CP0     W5
02006:  BRA     Z,2038
.................... 					tcpFlag = true; 
02008:  BSET.B  1109.1
.................... 					pingFlag = true; 
0200A:  BSET.B  1264.1
.................... 					gsmResponse = 4; 
0200C:  MOV     #4,W4
0200E:  MOV     W4,1274
.................... 					fprintf(DEBUG, "TCP Connected\r\n"); 
02010:  MOV     #0,W1
02012:  MOV     W1,W0
02014:  CLR.B   1
02016:  CALL    418
0201A:  INC     W1,W1
0201C:  BTSC.B  223.1
0201E:  BRA     201C
02020:  MOV     W0,224
02022:  MOV     #E,W0
02024:  CPSGT   W1,W0
02026:  BRA     2012
.................... 					autoConnect(); 
02028:  CALL    1AF0
.................... 					tcpATErrorCount = 0; 
0202C:  CLR     1282
.................... 					output_high(linkLed); 
0202E:  BCLR.B  E40.5
02030:  BSET.B  E44.5
.................... 					return; 
02032:  BRA     2DA0
.................... 				} 
02034:  GOTO    22DA
.................... 				else if(strstr(inputString, (char*)("CLOSED")) != 0){ 
02038:  MOV     #7,W3
0203A:  MOV     #0,W2
0203C:  MOV     #14E2,W1
0203E:  MOV     W3,[W15++]
02040:  MOV     W2,W0
02042:  CALL    44A
02046:  MOV     [--W15],W3
02048:  MOV.B   W0L,[W1++]
0204A:  INC     W2,W2
0204C:  DEC     W3,W3
0204E:  BTSS.B  42.1
02050:  BRA     203E
02052:  MOV     #110C,W4
02054:  MOV     W4,1534
02056:  MOV     #14E2,W4
02058:  MOV     W4,1536
0205A:  CALL    1384
0205E:  MOV     W0,W5
02060:  CP0     W5
02062:  BRA     Z,208C
.................... 					gsmResponse = 4; 
02064:  MOV     #4,W4
02066:  MOV     W4,1274
.................... 					fprintf(DEBUG, "TCP Disconnected\r\n"); 
02068:  MOV     #0,W1
0206A:  MOV     W1,W0
0206C:  CLR.B   1
0206E:  CALL    45E
02072:  INC     W1,W1
02074:  BTSC.B  223.1
02076:  BRA     2074
02078:  MOV     W0,224
0207A:  MOV     #11,W0
0207C:  CPSGT   W1,W0
0207E:  BRA     206A
.................... 					tcpFlag = false; 
02080:  BCLR.B  1109.1
.................... 					pingFlag = false; 
02082:  BCLR.B  1264.1
.................... 					output_low(linkLed); 
02084:  BCLR.B  E40.5
02086:  BCLR.B  E44.5
.................... 				} 
02088:  GOTO    22DA
.................... 				else if(strstr(inputString, (char*)(">")) != 0){ 
0208C:  MOV     #2,W3
0208E:  MOV     #0,W2
02090:  MOV     #14E2,W1
02092:  MOV     W3,[W15++]
02094:  MOV     W2,W0
02096:  CALL    47E
0209A:  MOV     [--W15],W3
0209C:  MOV.B   W0L,[W1++]
0209E:  INC     W2,W2
020A0:  DEC     W3,W3
020A2:  BTSS.B  42.1
020A4:  BRA     2092
020A6:  MOV     #110C,W4
020A8:  MOV     W4,1534
020AA:  MOV     #14E2,W4
020AC:  MOV     W4,1536
020AE:  CALL    1384
020B2:  MOV     W0,W5
020B4:  CP0     W5
020B6:  BRA     Z,20D8
.................... 					gsmSendResponse = 1; 
020B8:  MOV     #1,W4
020BA:  MOV     W4,127E
.................... 					fprintf(DEBUG, "content message:\r\n"); 
020BC:  MOV     #0,W1
020BE:  MOV     W1,W0
020C0:  CLR.B   1
020C2:  CALL    48C
020C6:  INC     W1,W1
020C8:  BTSC.B  223.1
020CA:  BRA     20C8
020CC:  MOV     W0,224
020CE:  MOV     #11,W0
020D0:  CPSGT   W1,W0
020D2:  BRA     20BE
.................... 				} 
020D4:  GOTO    22DA
.................... 				else if(strstr(inputString, reply) != 0){ 
020D8:  MOV     #110C,W4
020DA:  MOV     W4,1534
020DC:  PUSH    1296
020DE:  POP     1536
020E0:  CALL    1384
020E4:  MOV     W0,W5
020E6:  CP0     W5
020E8:  BRA     Z,22DA
.................... 					gsmResponseFlag = 1; 
020EA:  MOV     #1,W4
020EC:  MOV     W4,1276
.................... 					if(strstr(inputString, (char *)(" INITIAL")) !=0){ 
020EE:  MOV     #9,W3
020F0:  MOV     #0,W2
020F2:  MOV     #14E2,W1
020F4:  MOV     W3,[W15++]
020F6:  MOV     W2,W0
020F8:  CALL    4AC
020FC:  MOV     [--W15],W3
020FE:  MOV.B   W0L,[W1++]
02100:  INC     W2,W2
02102:  DEC     W3,W3
02104:  BTSS.B  42.1
02106:  BRA     20F4
02108:  MOV     #110C,W4
0210A:  MOV     W4,1534
0210C:  MOV     #14E2,W4
0210E:  MOV     W4,1536
02110:  CALL    1384
02114:  MOV     W0,W5
02116:  CP0     W5
02118:  BRA     Z,2122
.................... 						gsmResponseFlag = 2; 
0211A:  MOV     #2,W4
0211C:  MOV     W4,1276
.................... 					} 
0211E:  GOTO    22DA
.................... 					else if(strstr(inputString, (char*)(" START")) != 0){ 
02122:  MOV     #7,W3
02124:  MOV     #0,W2
02126:  MOV     #14E2,W1
02128:  MOV     W3,[W15++]
0212A:  MOV     W2,W0
0212C:  CALL    4C2
02130:  MOV     [--W15],W3
02132:  MOV.B   W0L,[W1++]
02134:  INC     W2,W2
02136:  DEC     W3,W3
02138:  BTSS.B  42.1
0213A:  BRA     2128
0213C:  MOV     #110C,W4
0213E:  MOV     W4,1534
02140:  MOV     #14E2,W4
02142:  MOV     W4,1536
02144:  CALL    1384
02148:  MOV     W0,W5
0214A:  CP0     W5
0214C:  BRA     Z,2156
.................... 						gsmResponseFlag = 3; 
0214E:  MOV     #3,W4
02150:  MOV     W4,1276
.................... 					} 
02152:  GOTO    22DA
.................... 					else if(strstr(inputString, (char*)(" CONFIG")) != 0){ 
02156:  MOV     #8,W3
02158:  MOV     #0,W2
0215A:  MOV     #14E2,W1
0215C:  MOV     W3,[W15++]
0215E:  MOV     W2,W0
02160:  CALL    4D6
02164:  MOV     [--W15],W3
02166:  MOV.B   W0L,[W1++]
02168:  INC     W2,W2
0216A:  DEC     W3,W3
0216C:  BTSS.B  42.1
0216E:  BRA     215C
02170:  MOV     #110C,W4
02172:  MOV     W4,1534
02174:  MOV     #14E2,W4
02176:  MOV     W4,1536
02178:  CALL    1384
0217C:  MOV     W0,W5
0217E:  CP0     W5
02180:  BRA     Z,218A
.................... 						gsmResponseFlag = 4; 
02182:  MOV     #4,W4
02184:  MOV     W4,1276
.................... 					} 
02186:  GOTO    22DA
.................... 					else if(strstr(inputString, (char*)(" GPRSACT")) != 0){ 
0218A:  MOV     #9,W3
0218C:  MOV     #0,W2
0218E:  MOV     #14E2,W1
02190:  MOV     W3,[W15++]
02192:  MOV     W2,W0
02194:  CALL    4EA
02198:  MOV     [--W15],W3
0219A:  MOV.B   W0L,[W1++]
0219C:  INC     W2,W2
0219E:  DEC     W3,W3
021A0:  BTSS.B  42.1
021A2:  BRA     2190
021A4:  MOV     #110C,W4
021A6:  MOV     W4,1534
021A8:  MOV     #14E2,W4
021AA:  MOV     W4,1536
021AC:  CALL    1384
021B0:  MOV     W0,W5
021B2:  CP0     W5
021B4:  BRA     Z,21BE
.................... 						gsmResponseFlag = 4; 
021B6:  MOV     #4,W4
021B8:  MOV     W4,1276
.................... 					} 
021BA:  GOTO    22DA
.................... 					else if((strstr(inputString, (char*)(" STATUS")) != 0) || (strstr(inputString, (char*)(" CLOSE")) != 0)){ 
021BE:  MOV     #8,W3
021C0:  MOV     #0,W2
021C2:  MOV     #14E2,W1
021C4:  MOV     W3,[W15++]
021C6:  MOV     W2,W0
021C8:  CALL    500
021CC:  MOV     [--W15],W3
021CE:  MOV.B   W0L,[W1++]
021D0:  INC     W2,W2
021D2:  DEC     W3,W3
021D4:  BTSS.B  42.1
021D6:  BRA     21C4
021D8:  MOV     #110C,W4
021DA:  MOV     W4,1534
021DC:  MOV     #14E2,W4
021DE:  MOV     W4,1536
021E0:  CALL    1384
021E4:  MOV     W0,W5
021E6:  CP0     W5
021E8:  BRA     NZ,2216
021EA:  MOV     #7,W3
021EC:  MOV     #0,W2
021EE:  MOV     #14E2,W1
021F0:  MOV     W3,[W15++]
021F2:  MOV     W2,W0
021F4:  CALL    514
021F8:  MOV     [--W15],W3
021FA:  MOV.B   W0L,[W1++]
021FC:  INC     W2,W2
021FE:  DEC     W3,W3
02200:  BTSS.B  42.1
02202:  BRA     21F0
02204:  MOV     #110C,W4
02206:  MOV     W4,1534
02208:  MOV     #14E2,W4
0220A:  MOV     W4,1536
0220C:  CALL    1384
02210:  MOV     W0,W5
02212:  CP0     W5
02214:  BRA     Z,221E
.................... 						gsmResponseFlag = 5; 
02216:  MOV     #5,W4
02218:  MOV     W4,1276
.................... 					} 
0221A:  GOTO    22DA
.................... 					else if(strstr(inputString, (char*)("TCP CONNECTING")) != 0){ 
0221E:  MOV     #F,W3
02220:  MOV     #0,W2
02222:  MOV     #14E2,W1
02224:  MOV     W3,[W15++]
02226:  MOV     W2,W0
02228:  CALL    528
0222C:  MOV     [--W15],W3
0222E:  MOV.B   W0L,[W1++]
02230:  INC     W2,W2
02232:  DEC     W3,W3
02234:  BTSS.B  42.1
02236:  BRA     2224
02238:  MOV     #110C,W4
0223A:  MOV     W4,1534
0223C:  MOV     #14E2,W4
0223E:  MOV     W4,1536
02240:  CALL    1384
02244:  MOV     W0,W5
02246:  CP0     W5
02248:  BRA     Z,2252
.................... 						gsmResponseFlag = 6; 
0224A:  MOV     #6,W4
0224C:  MOV     W4,1276
.................... 					} 
0224E:  GOTO    22DA
.................... 					else if((strstr(inputString, (char*)(" CONNECT OK")) != 0) || (strstr(inputString, (char*)(" CONNECT FAIL")) != 0) || (strstr(inputString, (char*)(" PDP DEACT")) != 0)){ 
02252:  MOV     #C,W3
02254:  MOV     #0,W2
02256:  MOV     #14E2,W1
02258:  MOV     W3,[W15++]
0225A:  MOV     W2,W0
0225C:  CALL    544
02260:  MOV     [--W15],W3
02262:  MOV.B   W0L,[W1++]
02264:  INC     W2,W2
02266:  DEC     W3,W3
02268:  BTSS.B  42.1
0226A:  BRA     2258
0226C:  MOV     #110C,W4
0226E:  MOV     W4,1534
02270:  MOV     #14E2,W4
02272:  MOV     W4,1536
02274:  CALL    1384
02278:  MOV     W0,W5
0227A:  CP0     W5
0227C:  BRA     NZ,22D6
0227E:  MOV     #E,W3
02280:  MOV     #0,W2
02282:  MOV     #14E2,W1
02284:  MOV     W3,[W15++]
02286:  MOV     W2,W0
02288:  CALL    55C
0228C:  MOV     [--W15],W3
0228E:  MOV.B   W0L,[W1++]
02290:  INC     W2,W2
02292:  DEC     W3,W3
02294:  BTSS.B  42.1
02296:  BRA     2284
02298:  MOV     #110C,W4
0229A:  MOV     W4,1534
0229C:  MOV     #14E2,W4
0229E:  MOV     W4,1536
022A0:  CALL    1384
022A4:  MOV     W0,W5
022A6:  CP0     W5
022A8:  BRA     NZ,22D6
022AA:  MOV     #B,W3
022AC:  MOV     #0,W2
022AE:  MOV     #14E2,W1
022B0:  MOV     W3,[W15++]
022B2:  MOV     W2,W0
022B4:  CALL    576
022B8:  MOV     [--W15],W3
022BA:  MOV.B   W0L,[W1++]
022BC:  INC     W2,W2
022BE:  DEC     W3,W3
022C0:  BTSS.B  42.1
022C2:  BRA     22B0
022C4:  MOV     #110C,W4
022C6:  MOV     W4,1534
022C8:  MOV     #14E2,W4
022CA:  MOV     W4,1536
022CC:  CALL    1384
022D0:  MOV     W0,W5
022D2:  CP0     W5
022D4:  BRA     Z,22DA
.................... 						gsmResponseFlag = 7; 
022D6:  MOV     #7,W4
022D8:  MOV     W4,1276
.................... 					} 
.................... 				} 
.................... 			} 
.................... 		} 
022DA:  GOTO    2D9C
.................... 		else{ 
.................... 			unsigned int mqttControlPacketType = (inchar / 16) & 0x0f; 
022DE:  MOV.B   14E0,W0L
022E0:  SE      W0,W0
022E2:  MOV     W0,W4
022E4:  MOV     #10,W3
022E6:  REPEAT  #11
022E8:  DIV.S   W4,W3
022EA:  MOV     W0,W5
022EC:  AND     W5,#F,W0
022EE:  MOV     W0,14F2
.................... 			packetType = mqttControlPacketType; 
022F0:  PUSH    14F2
022F2:  POP     128C
.................... 			unsigned int	DUP = (inchar & dupMask) / dupMask; 
.................... 			unsigned int	QoS = (inchar & QoSMask) / QoSScale; 
.................... 			unsigned int	Retain = inchar & retainMask; 
022F4:  MOV.B   14E0,W0L
022F6:  SE      W0,W0
022F8:  AND     W0,#8,W5
022FA:  MOV     W5,W4
022FC:  MOV     #8,W3
022FE:  REPEAT  #11
02300:  DIV.S   W4,W3
02302:  MOV     W0,14F4
02304:  MOV.B   14E0,W0L
02306:  SE      W0,W0
02308:  AND     W0,#6,W5
0230A:  MOV     W5,W4
0230C:  MOV     #2,W3
0230E:  REPEAT  #11
02310:  DIV.S   W4,W3
02312:  MOV     W0,14F6
02314:  MOV.B   14E0,W0L
02316:  SE      W0,W0
02318:  AND     W0,#1,W0
0231A:  MOV     W0,14F8
.................... 			if((mqttControlPacketType >= CONNECT) && (mqttControlPacketType <= DISCONNECT)){ 
0231C:  MOV     14F2,W4
0231E:  CP      W4,#1
02320:  BRA     NC,2454
02322:  MOV     14F2,W4
02324:  CP      W4,#E
02326:  BRA     GTU,2454
.................... 				bool nextLengthByte = true; 
02328:  BSET.B  14E1.0
.................... 				len = 0; 
0232A:  CLR     1266
0232C:  CLR     1268
.................... 				lengthLocal = 0; 
0232E:  CLR     126A
02330:  CLR     126C
.................... 				unsigned int32 multiplier = 1; 
.................... 				int8 cchar = inchar; 
.................... 				unsigned int32 temp = 0; 
02332:  MOV     #1,W4
02334:  MOV     W4,14FA
02336:  CLR     14FC
02338:  MOV.B   14E0,W0L
0233A:  MOV.B   W0L,14FE
0233C:  CLR     1500
0233E:  CLR     1502
.................... 				while((nextLengthByte == true) && (tcpFlag == true)){ 
02340:  BTSS.B  14E1.0
02342:  BRA     2454
02344:  BTSS.B  1109.1
02346:  BRA     2454
.................... 					if(kbhit(SIMM95)){ 
02348:  BTSS.B  252.0
0234A:  BRA     2436
.................... 						output_high(dataLed); 
0234C:  BCLR.B  E40.7
0234E:  BSET.B  E44.7
.................... 						inchar = fgetc(SIMM95); 
02350:  CALL    1376
02354:  MOV.B   W0L,14E0
.................... 						if((((cchar & 0xff) == 'C') &&((inchar & 0xff) == 'L') && (len == 0)) || (((cchar & 0xff) == '+') && ((inchar & 0xff) && 'P') && (len == 0))){ 
02356:  MOV.B   14FE,W0L
02358:  SE      W0,W0
0235A:  MOV     W0,W5
0235C:  AND     #FF,W5
0235E:  MOV     #43,W4
02360:  CP      W4,W5
02362:  BRA     NZ,237A
02364:  MOV.B   14E0,W0L
02366:  SE      W0,W0
02368:  MOV     W0,W5
0236A:  AND     #FF,W5
0236C:  MOV     #4C,W4
0236E:  CP      W4,W5
02370:  BRA     NZ,237A
02372:  CP0     1266
02374:  BRA     NZ,237A
02376:  CP0     1268
02378:  BRA     Z,239A
0237A:  MOV.B   14FE,W0L
0237C:  SE      W0,W0
0237E:  MOV     W0,W5
02380:  AND     #FF,W5
02382:  MOV     #2B,W4
02384:  CP      W4,W5
02386:  BRA     NZ,23C2
02388:  MOV.B   14E0,W0L
0238A:  SE      W0,W0
0238C:  AND     #FF,W0
0238E:  CP0     W0
02390:  BRA     Z,23C2
02392:  CP0     1266
02394:  BRA     NZ,23C2
02396:  CP0     1268
02398:  BRA     NZ,23C2
.................... 							index = 0; 
0239A:  CLR     120C
.................... 							inputString[index++] = cchar; 
0239C:  MOV     120C,W0
0239E:  INC     120C
023A0:  MOV     W0,W5
023A2:  MOV     #110C,W4
023A4:  ADD     W5,W4,W6
023A6:  MOV     14FE,W0
023A8:  MOV.B   W0L,[W6+#0]
.................... 							inputString[index++] = inchar; 
023AA:  MOV     120C,W0
023AC:  INC     120C
023AE:  MOV     W0,W5
023B0:  MOV     #110C,W4
023B2:  ADD     W5,W4,W6
023B4:  MOV     14E0,W0
023B6:  MOV.B   W0L,[W6+#0]
.................... 							tcpFlag = false; 
023B8:  BCLR.B  1109.1
.................... 							mqttFlag = false; 
023BA:  BCLR.B  1264.0
.................... 							pingFlag = false; 
023BC:  BCLR.B  1264.1
.................... 						} 
023BE:  GOTO    2436
.................... 						else{ 
.................... 							if((inchar & 128) == 128){ 
023C2:  MOV.B   14E0,W0L
023C4:  SE      W0,W0
023C6:  MOV     W0,W5
023C8:  AND     #80,W5
023CA:  MOV     #80,W4
023CC:  CP      W4,W5
023CE:  BRA     NZ,2404
.................... 								len += (inchar & 127) * multiplier; 
023D0:  MOV.B   14E0,W0L
023D2:  SE      W0,W0
023D4:  MOV     W0,W5
023D6:  AND     #7F,W5
023D8:  MOV     W5,W0
023DA:  CLR     W1
023DC:  BTSC    W0.F
023DE:  SETM    W1
023E0:  MOV     14FA,W2
023E2:  MOV     14FC,W3
023E4:  CALL    1AFA
023E8:  ADD     1266
023EA:  MOV     W1,W0
023EC:  ADDC    1268,W0
023EE:  MOV     W0,1268
.................... 								multiplier *= 128; 
023F0:  MOV     #7,W4
023F2:  CLR.B   9
023F4:  INC     W4,W4
023F6:  DEC     W4,W4
023F8:  BRA     Z,2400
023FA:  SL      14FA
023FC:  RLC     14FC
023FE:  BRA     23F6
.................... 							} 
02400:  GOTO    2436
.................... 							else{ 
.................... 								nextLengthByte = false; 
02404:  BCLR.B  14E1.0
.................... 								len += (inchar & 127) * multiplier; 
02406:  MOV.B   14E0,W0L
02408:  SE      W0,W0
0240A:  MOV     W0,W5
0240C:  AND     #7F,W5
0240E:  MOV     W5,W0
02410:  CLR     W1
02412:  BTSC    W0.F
02414:  SETM    W1
02416:  MOV     14FA,W2
02418:  MOV     14FC,W3
0241A:  CALL    1AFA
0241E:  ADD     1266
02420:  MOV     W1,W0
02422:  ADDC    1268,W0
02424:  MOV     W0,1268
.................... 								multiplier *= 128; 
02426:  MOV     #7,W4
02428:  CLR.B   9
0242A:  INC     W4,W4
0242C:  DEC     W4,W4
0242E:  BRA     Z,2436
02430:  SL      14FA
02432:  RLC     14FC
02434:  BRA     242C
.................... 							} 
.................... 						} 
.................... 					} 
.................... 					temp++; 
02436:  INC     1500
02438:  BTSC.B  42.1
0243A:  INC     1502
.................... 					if(temp > 10000)	break; 
0243C:  MOV     1502,W4
0243E:  CP      W4,#0
02440:  BRA     NC,2450
02442:  BRA     GTU,244C
02444:  MOV     1500,W4
02446:  MOV     #2710,W3
02448:  CP      W3,W4
0244A:  BRA     C,2450
0244C:  GOTO    2454
02450:  GOTO    2340
.................... 				} 
.................... 			} 
.................... 			lengthLocal = len; 
02454:  PUSH    1266
02456:  POP     126A
02458:  PUSH    1268
0245A:  POP     126C
.................... 			if(len > 200)	return; 
0245C:  MOV     1268,W4
0245E:  CP      W4,#0
02460:  BRA     NC,246E
02462:  BRA     GTU,246C
02464:  MOV     1266,W4
02466:  MOV     #C8,W3
02468:  CP      W3,W4
0246A:  BRA     C,246E
0246C:  BRA     2DA0
.................... 			if(tcpFlag == true){ 
0246E:  BTSS.B  1109.1
02470:  BRA     2D9C
.................... 				index = 0; 
02472:  CLR     120C
.................... //				memset(inputString, 0, sizeof(inputString)); 
.................... 				while(len > 0){ 
02474:  CP0     1266
02476:  BRA     NZ,247C
02478:  CP0     1268
0247A:  BRA     Z,24A6
.................... 					inputString[index++] = fgetc(SIMM95); 
0247C:  MOV     120C,W0
0247E:  INC     120C
02480:  MOV     W0,W5
02482:  MOV     #110C,W4
02484:  ADD     W5,W4,W6
02486:  CALL    1376
0248A:  MOV.B   W0L,[W6]
.................... 					output_high(dataLed); 
0248C:  BCLR.B  E40.7
0248E:  BSET.B  E44.7
.................... 					len--; 
02490:  DEC     1266
02492:  BTSS.B  42.0
02494:  DEC     1268
.................... 					if(index > (sizeof(inputString) - 1))	break; 
02496:  MOV     120C,W4
02498:  MOV     #FF,W3
0249A:  CP      W3,W4
0249C:  BRA     C,24A2
0249E:  GOTO    24A6
024A2:  GOTO    2474
.................... 				} 
.................... 				fprintf(DEBUG, "inputString: %d\r\n", inputString); 
024A6:  MOV     #0,W1
024A8:  MOV     W1,W0
024AA:  CLR.B   1
024AC:  CALL    58E
024B0:  INC     W1,W1
024B2:  BTSC.B  223.1
024B4:  BRA     24B2
024B6:  MOV     W0,224
024B8:  MOV     #C,W0
024BA:  CPSGT   W1,W0
024BC:  BRA     24A8
024BE:  MOV     #110C,W0
024C0:  MOV     #0,W4
024C2:  CALL    1620
024C6:  BTSC.B  223.1
024C8:  BRA     24C6
024CA:  MOV     #D,W4
024CC:  MOV     W4,224
024CE:  BTSC.B  223.1
024D0:  BRA     24CE
024D2:  MOV     #A,W4
024D4:  MOV     W4,224
.................... 				switch(mqttControlPacketType){ 
024D6:  MOV     14F2,W0
024D8:  XOR     #2,W0
024DA:  BRA     Z,2502
024DC:  XOR     #1,W0
024DE:  BRA     Z,25BA
024E0:  XOR     #7,W0
024E2:  BRA     Z,2912
024E4:  XOR     #3,W0
024E6:  BRA     Z,2988
024E8:  XOR     #E,W0
024EA:  BRA     Z,29FE
024EC:  XOR     #2,W0
024EE:  BRA     Z,2A76
024F0:  XOR     #E,W0
024F2:  BRA     Z,2B50
024F4:  XOR     #3,W0
024F6:  BRA     Z,2C34
024F8:  XOR     #A,W0
024FA:  BRA     Z,2D16
024FC:  XOR     #1,W0
024FE:  BRA     Z,2D68
02500:  BRA     2D9C
.................... 					case CONNACK:{						 
.................... 						fprintf(DEBUG, "reponse CONNACK: %d\r\n", mqttControlPacketType); 
02502:  MOV     #0,W1
02504:  MOV     W1,W0
02506:  CLR.B   1
02508:  CALL    5AC
0250C:  INC     W1,W1
0250E:  BTSC.B  223.1
02510:  BRA     250E
02512:  MOV     W0,224
02514:  MOV     #10,W0
02516:  CPSGT   W1,W0
02518:  BRA     2504
0251A:  MOV     14F2,W0
0251C:  MOV     #0,W4
0251E:  CALL    1620
02522:  BTSC.B  223.1
02524:  BRA     2522
02526:  MOV     #D,W4
02528:  MOV     W4,224
0252A:  BTSC.B  223.1
0252C:  BRA     252A
0252E:  MOV     #A,W4
02530:  MOV     W4,224
.................... 						fprintf(DEBUG, "inputString[0]: %d\r\n", inputString[0]); 
02532:  MOV     #0,W1
02534:  MOV     W1,W0
02536:  CLR.B   1
02538:  CALL    5CE
0253C:  INC     W1,W1
0253E:  BTSC.B  223.1
02540:  BRA     253E
02542:  MOV     W0,224
02544:  MOV     #F,W0
02546:  CPSGT   W1,W0
02548:  BRA     2534
0254A:  MOV.B   110C,W0L
0254C:  SE      W0,W0
0254E:  MOV     #0,W4
02550:  CALL    1620
02554:  BTSC.B  223.1
02556:  BRA     2554
02558:  MOV     #D,W4
0255A:  MOV     W4,224
0255C:  BTSC.B  223.1
0255E:  BRA     255C
02560:  MOV     #A,W4
02562:  MOV     W4,224
.................... 						fprintf(DEBUG, "inputString[1]: %d\r\n", inputString[1]); 
02564:  MOV     #0,W1
02566:  MOV     W1,W0
02568:  CLR.B   1
0256A:  CALL    5F0
0256E:  INC     W1,W1
02570:  BTSC.B  223.1
02572:  BRA     2570
02574:  MOV     W0,224
02576:  MOV     #F,W0
02578:  CPSGT   W1,W0
0257A:  BRA     2566
0257C:  MOV.B   110D,W0L
0257E:  SE      W0,W0
02580:  MOV     #0,W4
02582:  CALL    1620
02586:  BTSC.B  223.1
02588:  BRA     2586
0258A:  MOV     #D,W4
0258C:  MOV     W4,224
0258E:  BTSC.B  223.1
02590:  BRA     258E
02592:  MOV     #A,W4
02594:  MOV     W4,224
.................... 						connectionAcknowledgement = inputString[0] * 256 + inputString[1]; 
02596:  MOV.B   110C,W0L
02598:  SE      W0,W0
0259A:  MOV     #100,W4
0259C:  MUL.SS  W0,W4,W0
0259E:  MOV     W0,W5
025A0:  MOV.B   110D,W0L
025A2:  SE      W0,W0
025A4:  ADD     W0,W5,W0
025A6:  MOV     W0,1262
.................... 						if(connectionAcknowledgement == 0){ 
025A8:  CP0     1262
025AA:  BRA     NZ,25AE
.................... 							mqttFlag = true; 
025AC:  BSET.B  1264.0
.................... 						} 
.................... 						connectReturnCode(connectionAcknowledgement); 
025AE:  PUSH    1262
025B0:  POP     1534
025B2:  CALL    1B3C
.................... 						break; 
025B6:  GOTO    2D9C
.................... 					} 
.................... 					case PUBLISH:{ 
.................... 						fprintf(DEBUG, "reponse PUBLISH: %d\r\n", mqttControlPacketType); 
025BA:  MOV     #0,W1
025BC:  MOV     W1,W0
025BE:  CLR.B   1
025C0:  CALL    612
025C4:  INC     W1,W1
025C6:  BTSC.B  223.1
025C8:  BRA     25C6
025CA:  MOV     W0,224
025CC:  MOV     #10,W0
025CE:  CPSGT   W1,W0
025D0:  BRA     25BC
025D2:  MOV     14F2,W0
025D4:  MOV     #0,W4
025D6:  CALL    1620
025DA:  BTSC.B  223.1
025DC:  BRA     25DA
025DE:  MOV     #D,W4
025E0:  MOV     W4,224
025E2:  BTSC.B  223.1
025E4:  BRA     25E2
025E6:  MOV     #A,W4
025E8:  MOV     W4,224
.................... 						fprintf(DEBUG, "inputString[0]: %d\r\n", inputString[0]); 
025EA:  MOV     #0,W1
025EC:  MOV     W1,W0
025EE:  CLR.B   1
025F0:  CALL    5CE
025F4:  INC     W1,W1
025F6:  BTSC.B  223.1
025F8:  BRA     25F6
025FA:  MOV     W0,224
025FC:  MOV     #F,W0
025FE:  CPSGT   W1,W0
02600:  BRA     25EC
02602:  MOV.B   110C,W0L
02604:  SE      W0,W0
02606:  MOV     #0,W4
02608:  CALL    1620
0260C:  BTSC.B  223.1
0260E:  BRA     260C
02610:  MOV     #D,W4
02612:  MOV     W4,224
02614:  BTSC.B  223.1
02616:  BRA     2614
02618:  MOV     #A,W4
0261A:  MOV     W4,224
.................... 						fprintf(DEBUG, "inputString[1]: %d\r\n", inputString[1]); 
0261C:  MOV     #0,W1
0261E:  MOV     W1,W0
02620:  CLR.B   1
02622:  CALL    5F0
02626:  INC     W1,W1
02628:  BTSC.B  223.1
0262A:  BRA     2628
0262C:  MOV     W0,224
0262E:  MOV     #F,W0
02630:  CPSGT   W1,W0
02632:  BRA     261E
02634:  MOV.B   110D,W0L
02636:  SE      W0,W0
02638:  MOV     #0,W4
0263A:  CALL    1620
0263E:  BTSC.B  223.1
02640:  BRA     263E
02642:  MOV     #D,W4
02644:  MOV     W4,224
02646:  BTSC.B  223.1
02648:  BRA     2646
0264A:  MOV     #A,W4
0264C:  MOV     W4,224
.................... 						unsigned int16 topicLength = inputString[0] * 256 + inputString[1]; 
0264E:  MOV.B   110C,W0L
02650:  SE      W0,W0
02652:  MOV     #100,W4
02654:  MUL.SS  W0,W4,W0
02656:  MOV     W0,W5
02658:  MOV.B   110D,W0L
0265A:  SE      W0,W0
0265C:  ADD     W0,W5,W0
0265E:  MOV     W0,1504
.................... 						fprintf(DEBUG, "topicLength: %d\r\n", topicLength); 
02660:  MOV     #0,W1
02662:  MOV     W1,W0
02664:  CLR.B   1
02666:  CALL    634
0266A:  INC     W1,W1
0266C:  BTSC.B  223.1
0266E:  BRA     266C
02670:  MOV     W0,224
02672:  MOV     #C,W0
02674:  CPSGT   W1,W0
02676:  BRA     2662
02678:  MOV     1504,W0
0267A:  MOV     #0,W4
0267C:  CALL    1620
02680:  BTSC.B  223.1
02682:  BRA     2680
02684:  MOV     #D,W4
02686:  MOV     W4,224
02688:  BTSC.B  223.1
0268A:  BRA     2688
0268C:  MOV     #A,W4
0268E:  MOV     W4,224
.................... 						if(topicLength > index){ 
02690:  MOV     120C,W0
02692:  MOV     1504,W4
02694:  CP      W4,W0
02696:  BRA     LEU,26B4
.................... 							topicLength = 0; 
02698:  CLR     1504
.................... 							fprintf(DEBUG, "topic length is large\r\n"); 
0269A:  MOV     #0,W1
0269C:  MOV     W1,W0
0269E:  CLR.B   1
026A0:  CALL    652
026A4:  INC     W1,W1
026A6:  BTSC.B  223.1
026A8:  BRA     26A6
026AA:  MOV     W0,224
026AC:  MOV     #16,W0
026AE:  CPSGT   W1,W0
026B0:  BRA     269C
.................... 							return; 
026B2:  BRA     2DA0
.................... 						} 
.................... 						unsigned int16 publishIndex = 0; 
026B4:  CLR     1506
.................... 						memset(t_topic, 0, sizeof(t_topic)); 
026B6:  MOV     #1298,W1
026B8:  MOV     #0,W2
026BA:  REPEAT  #63
026BC:  CLR.B   [W1++]
.................... 						for(iteraction = 2; iteraction < topicLength; iteraction++){ 
026BE:  MOV     #2,W4
026C0:  MOV     W4,14DE
026C2:  MOV     14DE,W0
026C4:  MOV     1504,W4
026C6:  CP      W4,W0
026C8:  BRA     LEU,26E2
.................... 							t_topic[publishIndex++] = inputString[iteraction]; 
026CA:  MOV     1506,W0
026CC:  INC     1506
026CE:  MOV     W0,W5
026D0:  MOV     #1298,W4
026D2:  ADD     W5,W4,W6
026D4:  MOV     #110C,W4
026D6:  MOV     14DE,W3
026D8:  ADD     W3,W4,W0
026DA:  MOV.B   [W0],[W6]
026DC:  INC     14DE
026DE:  GOTO    26C2
.................... 						} 
.................... 						iteraction = 0; 
026E2:  CLR     14DE
.................... 						fprintf(DEBUG, "t_tpoic1: %s\r\n", t_topic); 
026E4:  MOV     #0,W1
026E6:  MOV     W1,W0
026E8:  CLR.B   1
026EA:  CALL    676
026EE:  INC     W1,W1
026F0:  BTSC.B  223.1
026F2:  BRA     26F0
026F4:  MOV     W0,224
026F6:  MOV     #9,W0
026F8:  CPSGT   W1,W0
026FA:  BRA     26E6
026FC:  MOV     #1298,W1
026FE:  CP0.B   [W1]
02700:  BRA     Z,2710
02702:  BTSC.B  223.1
02704:  BRA     2702
02706:  MOV.B   [W1+#0],W0L
02708:  MOV.B   W0L,224
0270A:  CLR.B   225
0270C:  INC     W1,W1
0270E:  BRA     26FE
02710:  BTSC.B  223.1
02712:  BRA     2710
02714:  MOV     #D,W4
02716:  MOV     W4,224
02718:  BTSC.B  223.1
0271A:  BRA     2718
0271C:  MOV     #A,W4
0271E:  MOV     W4,224
.................... 						t_topic[publishIndex] = 0; 
02720:  MOV     #1298,W4
02722:  MOV     1506,W3
02724:  ADD     W3,W4,W5
02726:  CLR.B   [W5]
.................... 						topicLength = publishIndex; 
02728:  PUSH    1506
0272A:  POP     1504
.................... 						publishIndex = 0; 
0272C:  CLR     1506
.................... 						unsigned int16 messageStart = topicLength + 2; 
.................... 						unsigned int16 messageID	 = 0; 
0272E:  MOV     1504,W4
02730:  ADD     W4,#2,W4
02732:  MOV     W4,1508
02734:  CLR     150A
.................... 						if(QoS == 0){ 
02736:  CP0     14F6
02738:  BRA     NZ,2798
.................... 							messageStart = messageStart + 2; 
0273A:  MOV     1508,W4
0273C:  ADD     W4,#2,W4
0273E:  MOV     W4,1508
.................... 							messageID = inputString[topicLength + 2] * 256 + inputString[topicLength + 3]; 
02740:  MOV     1504,W4
02742:  ADD     W4,#2,W4
02744:  MOV     W4,W5
02746:  MOV     #110C,W4
02748:  ADD     W5,W4,W0
0274A:  MOV.B   [W0],W6L
0274C:  SE      W6,W6
0274E:  MOV     #100,W4
02750:  MUL.SS  W6,W4,W0
02752:  MOV     W0,W6
02754:  MOV     1504,W4
02756:  ADD     W4,#3,W4
02758:  MOV     W4,W8
0275A:  MOV     #110C,W4
0275C:  ADD     W8,W4,W0
0275E:  MOV     W0,W4
02760:  MOV.B   [W4],W0L
02762:  SE      W0,W0
02764:  ADD     W0,W6,W0
02766:  MOV     W0,150A
.................... 							fprintf(DEBUG, "messageID: %d\r\n", messageID); 
02768:  MOV     #0,W1
0276A:  MOV     W1,W0
0276C:  CLR.B   1
0276E:  CALL    692
02772:  INC     W1,W1
02774:  BTSC.B  223.1
02776:  BRA     2774
02778:  MOV     W0,224
0277A:  MOV     #A,W0
0277C:  CPSGT   W1,W0
0277E:  BRA     276A
02780:  MOV     150A,W0
02782:  MOV     #0,W4
02784:  CALL    1620
02788:  BTSC.B  223.1
0278A:  BRA     2788
0278C:  MOV     #D,W4
0278E:  MOV     W4,224
02790:  BTSC.B  223.1
02792:  BRA     2790
02794:  MOV     #A,W4
02796:  MOV     W4,224
.................... 						} 
.................... 						memset(t_message, 0, sizeof(t_message)); 
02798:  MOV     #12FC,W1
0279A:  MOV     #0,W2
0279C:  REPEAT  #FF
0279E:  CLR.B   [W1++]
.................... 						for(iteraction = messageStart; iteraction < lengthLocal; iteraction++){ 
027A0:  PUSH    1508
027A2:  POP     14DE
027A4:  MOV     126C,W4
027A6:  CP      W4,#0
027A8:  BRA     NC,27CC
027AA:  BRA     GTU,27B4
027AC:  MOV     14DE,W0
027AE:  MOV     126A,W4
027B0:  CP      W4,W0
027B2:  BRA     LEU,27CC
.................... 							t_message[publishIndex++] = inputString[iteraction]; 
027B4:  MOV     1506,W0
027B6:  INC     1506
027B8:  MOV     W0,W5
027BA:  MOV     #12FC,W4
027BC:  ADD     W5,W4,W6
027BE:  MOV     #110C,W4
027C0:  MOV     14DE,W3
027C2:  ADD     W3,W4,W0
027C4:  MOV.B   [W0],[W6]
027C6:  INC     14DE
027C8:  GOTO    27A4
.................... 						} 
.................... 						fprintf(DEBUG, "t_message2: %s\r\n", t_message); 
027CC:  MOV     #0,W1
027CE:  MOV     W1,W0
027D0:  CLR.B   1
027D2:  CALL    6AE
027D6:  INC     W1,W1
027D8:  BTSC.B  223.1
027DA:  BRA     27D8
027DC:  MOV     W0,224
027DE:  MOV     #B,W0
027E0:  CPSGT   W1,W0
027E2:  BRA     27CE
027E4:  MOV     #12FC,W1
027E6:  CP0.B   [W1]
027E8:  BRA     Z,27F8
027EA:  BTSC.B  223.1
027EC:  BRA     27EA
027EE:  MOV.B   [W1+#0],W0L
027F0:  MOV.B   W0L,224
027F2:  CLR.B   225
027F4:  INC     W1,W1
027F6:  BRA     27E6
027F8:  BTSC.B  223.1
027FA:  BRA     27F8
027FC:  MOV     #D,W4
027FE:  MOV     W4,224
02800:  BTSC.B  223.1
02802:  BRA     2800
02804:  MOV     #A,W4
02806:  MOV     W4,224
.................... 						t_message[publishIndex] = 0; 
02808:  MOV     #12FC,W4
0280A:  MOV     1506,W3
0280C:  ADD     W3,W4,W5
0280E:  CLR.B   [W5]
.................... 						messageLength = publishIndex; 
02810:  PUSH    1506
02812:  POP     126E
02814:  CLR     1270
.................... 						publishIndex = 0; 
02816:  CLR     1506
.................... 						if(QoS == 1){ 
02818:  MOV     14F6,W4
0281A:  CP      W4,#1
0281C:  BRA     NZ,2892
.................... 							publishACK(messageID); 
0281E:  PUSH    150A
02820:  POP     1534
02822:  CALL    1C4E
.................... 							fprintf(DEBUG, "QoS: %d\r\n", QoS); 
02826:  MOV     #0,W1
02828:  MOV     W1,W0
0282A:  CLR.B   1
0282C:  CALL    6CC
02830:  INC     W1,W1
02832:  BTSC.B  223.1
02834:  BRA     2832
02836:  MOV     W0,224
02838:  MOV     #4,W0
0283A:  CPSGT   W1,W0
0283C:  BRA     2828
0283E:  MOV     14F6,W0
02840:  MOV     #0,W4
02842:  CALL    1620
02846:  BTSC.B  223.1
02848:  BRA     2846
0284A:  MOV     #D,W4
0284C:  MOV     W4,224
0284E:  BTSC.B  223.1
02850:  BRA     284E
02852:  MOV     #A,W4
02854:  MOV     W4,224
.................... 							fprintf(DEBUG, "messageID: %s\r\n", messageID); 
02856:  MOV     #0,W1
02858:  MOV     W1,W0
0285A:  CLR.B   1
0285C:  CALL    6E2
02860:  INC     W1,W1
02862:  BTSC.B  223.1
02864:  BRA     2862
02866:  MOV     W0,224
02868:  MOV     #A,W0
0286A:  CPSGT   W1,W0
0286C:  BRA     2858
0286E:  MOV     150A,W1
02870:  CP0.B   [W1]
02872:  BRA     Z,2882
02874:  BTSC.B  223.1
02876:  BRA     2874
02878:  MOV.B   [W1+#0],W0L
0287A:  MOV.B   W0L,224
0287C:  CLR.B   225
0287E:  INC     W1,W1
02880:  BRA     2870
02882:  BTSC.B  223.1
02884:  BRA     2882
02886:  MOV     #D,W4
02888:  MOV     W4,224
0288A:  BTSC.B  223.1
0288C:  BRA     288A
0288E:  MOV     #A,W4
02890:  MOV     W4,224
.................... 						} 
.................... 						if(QoS ==2){ 
02892:  MOV     14F6,W4
02894:  CP      W4,#2
02896:  BRA     NZ,290C
.................... 							publishREC(messageID); 
02898:  PUSH    150A
0289A:  POP     1534
0289C:  CALL    1CCE
.................... 							fprintf(DEBUG, "QoS: %d\r\n", QoS); 
028A0:  MOV     #0,W1
028A2:  MOV     W1,W0
028A4:  CLR.B   1
028A6:  CALL    6CC
028AA:  INC     W1,W1
028AC:  BTSC.B  223.1
028AE:  BRA     28AC
028B0:  MOV     W0,224
028B2:  MOV     #4,W0
028B4:  CPSGT   W1,W0
028B6:  BRA     28A2
028B8:  MOV     14F6,W0
028BA:  MOV     #0,W4
028BC:  CALL    1620
028C0:  BTSC.B  223.1
028C2:  BRA     28C0
028C4:  MOV     #D,W4
028C6:  MOV     W4,224
028C8:  BTSC.B  223.1
028CA:  BRA     28C8
028CC:  MOV     #A,W4
028CE:  MOV     W4,224
.................... 							fprintf(DEBUG, "messageID: %s\r\n", messageID); 
028D0:  MOV     #0,W1
028D2:  MOV     W1,W0
028D4:  CLR.B   1
028D6:  CALL    6E2
028DA:  INC     W1,W1
028DC:  BTSC.B  223.1
028DE:  BRA     28DC
028E0:  MOV     W0,224
028E2:  MOV     #A,W0
028E4:  CPSGT   W1,W0
028E6:  BRA     28D2
028E8:  MOV     150A,W1
028EA:  CP0.B   [W1]
028EC:  BRA     Z,28FC
028EE:  BTSC.B  223.1
028F0:  BRA     28EE
028F2:  MOV.B   [W1+#0],W0L
028F4:  MOV.B   W0L,224
028F6:  CLR.B   225
028F8:  INC     W1,W1
028FA:  BRA     28EA
028FC:  BTSC.B  223.1
028FE:  BRA     28FC
02900:  MOV     #D,W4
02902:  MOV     W4,224
02904:  BTSC.B  223.1
02906:  BRA     2904
02908:  MOV     #A,W4
0290A:  MOV     W4,224
.................... 						} 
.................... 						messageFlag  = true; 
0290C:  BSET.B  1109.6
.................... 						break; 
0290E:  GOTO    2D9C
.................... 					} 
.................... 					case PUBACK:{ 
.................... 						fprintf(DEBUG, "response PUBACK: %d\r\n", mqttControlPacketType); 
02912:  MOV     #0,W1
02914:  MOV     W1,W0
02916:  CLR.B   1
02918:  CALL    6FE
0291C:  INC     W1,W1
0291E:  BTSC.B  223.1
02920:  BRA     291E
02922:  MOV     W0,224
02924:  MOV     #10,W0
02926:  CPSGT   W1,W0
02928:  BRA     2914
0292A:  MOV     14F2,W0
0292C:  MOV     #0,W4
0292E:  CALL    1620
02932:  BTSC.B  223.1
02934:  BRA     2932
02936:  MOV     #D,W4
02938:  MOV     W4,224
0293A:  BTSC.B  223.1
0293C:  BRA     293A
0293E:  MOV     #A,W4
02940:  MOV     W4,224
.................... 						unsigned int16 packetID = inputString[2] * 256 + inputString[3]; 
02942:  MOV.B   110E,W0L
02944:  SE      W0,W0
02946:  MOV     #100,W4
02948:  MUL.SS  W0,W4,W0
0294A:  MOV     W0,W5
0294C:  MOV.B   110F,W0L
0294E:  SE      W0,W0
02950:  ADD     W0,W5,W0
02952:  MOV     W0,150C
.................... 						fprintf(DEBUG, "packet ID: %d\r\n", packetID); 
02954:  MOV     #0,W1
02956:  MOV     W1,W0
02958:  CLR.B   1
0295A:  CALL    720
0295E:  INC     W1,W1
02960:  BTSC.B  223.1
02962:  BRA     2960
02964:  MOV     W0,224
02966:  MOV     #A,W0
02968:  CPSGT   W1,W0
0296A:  BRA     2956
0296C:  MOV     150C,W0
0296E:  MOV     #0,W4
02970:  CALL    1620
02974:  BTSC.B  223.1
02976:  BRA     2974
02978:  MOV     #D,W4
0297A:  MOV     W4,224
0297C:  BTSC.B  223.1
0297E:  BRA     297C
02980:  MOV     #A,W4
02982:  MOV     W4,224
.................... 						break; 
02984:  GOTO    2D9C
.................... 					} 
.................... 					case PUBCOMP:{						 
.................... 						fprintf(DEBUG, "response PUCOMP: %d\r\n", mqttControlPacketType); 
02988:  MOV     #0,W1
0298A:  MOV     W1,W0
0298C:  CLR.B   1
0298E:  CALL    73C
02992:  INC     W1,W1
02994:  BTSC.B  223.1
02996:  BRA     2994
02998:  MOV     W0,224
0299A:  MOV     #10,W0
0299C:  CPSGT   W1,W0
0299E:  BRA     298A
029A0:  MOV     14F2,W0
029A2:  MOV     #0,W4
029A4:  CALL    1620
029A8:  BTSC.B  223.1
029AA:  BRA     29A8
029AC:  MOV     #D,W4
029AE:  MOV     W4,224
029B0:  BTSC.B  223.1
029B2:  BRA     29B0
029B4:  MOV     #A,W4
029B6:  MOV     W4,224
.................... 						unsigned int16 packetID = inputString[2] * 256 + inputString[3]; 
029B8:  MOV.B   110E,W0L
029BA:  SE      W0,W0
029BC:  MOV     #100,W4
029BE:  MUL.SS  W0,W4,W0
029C0:  MOV     W0,W5
029C2:  MOV.B   110F,W0L
029C4:  SE      W0,W0
029C6:  ADD     W0,W5,W0
029C8:  MOV     W0,150E
.................... 						fprintf(DEBUG, "packet ID: %d\r\n", packetID); 
029CA:  MOV     #0,W1
029CC:  MOV     W1,W0
029CE:  CLR.B   1
029D0:  CALL    720
029D4:  INC     W1,W1
029D6:  BTSC.B  223.1
029D8:  BRA     29D6
029DA:  MOV     W0,224
029DC:  MOV     #A,W0
029DE:  CPSGT   W1,W0
029E0:  BRA     29CC
029E2:  MOV     150E,W0
029E4:  MOV     #0,W4
029E6:  CALL    1620
029EA:  BTSC.B  223.1
029EC:  BRA     29EA
029EE:  MOV     #D,W4
029F0:  MOV     W4,224
029F2:  BTSC.B  223.1
029F4:  BRA     29F2
029F6:  MOV     #A,W4
029F8:  MOV     W4,224
.................... 						break; 
029FA:  GOTO    2D9C
.................... 					} 
.................... 					case SUBACK:{ 
.................... 						fprintf(DEBUG, "response SUBACK : %d\r\n", mqttControlPacketType); 
029FE:  MOV     #0,W1
02A00:  MOV     W1,W0
02A02:  CLR.B   1
02A04:  CALL    75E
02A08:  INC     W1,W1
02A0A:  BTSC.B  223.1
02A0C:  BRA     2A0A
02A0E:  MOV     W0,224
02A10:  MOV     #11,W0
02A12:  CPSGT   W1,W0
02A14:  BRA     2A00
02A16:  MOV     14F2,W0
02A18:  MOV     #0,W4
02A1A:  CALL    1620
02A1E:  BTSC.B  223.1
02A20:  BRA     2A1E
02A22:  MOV     #D,W4
02A24:  MOV     W4,224
02A26:  BTSC.B  223.1
02A28:  BRA     2A26
02A2A:  MOV     #A,W4
02A2C:  MOV     W4,224
.................... 						unsigned int16 packetID = inputString[2] * 256 + inputString[3]; 
02A2E:  MOV.B   110E,W0L
02A30:  SE      W0,W0
02A32:  MOV     #100,W4
02A34:  MUL.SS  W0,W4,W0
02A36:  MOV     W0,W5
02A38:  MOV.B   110F,W0L
02A3A:  SE      W0,W0
02A3C:  ADD     W0,W5,W0
02A3E:  MOV     W0,1510
.................... 						fprintf(DEBUG, "packet ID: %d\r\n", packetID); 
02A40:  MOV     #0,W1
02A42:  MOV     W1,W0
02A44:  CLR.B   1
02A46:  CALL    720
02A4A:  INC     W1,W1
02A4C:  BTSC.B  223.1
02A4E:  BRA     2A4C
02A50:  MOV     W0,224
02A52:  MOV     #A,W0
02A54:  CPSGT   W1,W0
02A56:  BRA     2A42
02A58:  MOV     1510,W0
02A5A:  MOV     #0,W4
02A5C:  CALL    1620
02A60:  BTSC.B  223.1
02A62:  BRA     2A60
02A64:  MOV     #D,W4
02A66:  MOV     W4,224
02A68:  BTSC.B  223.1
02A6A:  BRA     2A68
02A6C:  MOV     #A,W4
02A6E:  MOV     W4,224
.................... 						messageFlag = true; 
02A70:  BSET.B  1109.6
.................... 						break; 
02A72:  GOTO    2D9C
.................... 					} 
.................... 					case UNSUBACK:{										 
.................... 						fprintf(DEBUG, "reponse UNSUBACK: %d\r\n", mqttControlPacketType); 
02A76:  MOV     #0,W1
02A78:  MOV     W1,W0
02A7A:  CLR.B   1
02A7C:  CALL    782
02A80:  INC     W1,W1
02A82:  BTSC.B  223.1
02A84:  BRA     2A82
02A86:  MOV     W0,224
02A88:  MOV     #11,W0
02A8A:  CPSGT   W1,W0
02A8C:  BRA     2A78
02A8E:  MOV     14F2,W0
02A90:  MOV     #0,W4
02A92:  CALL    1620
02A96:  BTSC.B  223.1
02A98:  BRA     2A96
02A9A:  MOV     #D,W4
02A9C:  MOV     W4,224
02A9E:  BTSC.B  223.1
02AA0:  BRA     2A9E
02AA2:  MOV     #A,W4
02AA4:  MOV     W4,224
.................... 						fprintf(DEBUG, "inputString[2]: %d\r\n", inputString[2]); 
02AA6:  MOV     #0,W1
02AA8:  MOV     W1,W0
02AAA:  CLR.B   1
02AAC:  CALL    7A6
02AB0:  INC     W1,W1
02AB2:  BTSC.B  223.1
02AB4:  BRA     2AB2
02AB6:  MOV     W0,224
02AB8:  MOV     #F,W0
02ABA:  CPSGT   W1,W0
02ABC:  BRA     2AA8
02ABE:  MOV.B   110E,W0L
02AC0:  SE      W0,W0
02AC2:  MOV     #0,W4
02AC4:  CALL    1620
02AC8:  BTSC.B  223.1
02ACA:  BRA     2AC8
02ACC:  MOV     #D,W4
02ACE:  MOV     W4,224
02AD0:  BTSC.B  223.1
02AD2:  BRA     2AD0
02AD4:  MOV     #A,W4
02AD6:  MOV     W4,224
.................... 						fprintf(DEBUG, "inputString[3]: %d\r\n", inputString[3]); 
02AD8:  MOV     #0,W1
02ADA:  MOV     W1,W0
02ADC:  CLR.B   1
02ADE:  CALL    7C8
02AE2:  INC     W1,W1
02AE4:  BTSC.B  223.1
02AE6:  BRA     2AE4
02AE8:  MOV     W0,224
02AEA:  MOV     #F,W0
02AEC:  CPSGT   W1,W0
02AEE:  BRA     2ADA
02AF0:  MOV.B   110F,W0L
02AF2:  SE      W0,W0
02AF4:  MOV     #0,W4
02AF6:  CALL    1620
02AFA:  BTSC.B  223.1
02AFC:  BRA     2AFA
02AFE:  MOV     #D,W4
02B00:  MOV     W4,224
02B02:  BTSC.B  223.1
02B04:  BRA     2B02
02B06:  MOV     #A,W4
02B08:  MOV     W4,224
.................... 						unsigned int16 packetID = inputString[2] * 256 + inputString[3]; 
02B0A:  MOV.B   110E,W0L
02B0C:  SE      W0,W0
02B0E:  MOV     #100,W4
02B10:  MUL.SS  W0,W4,W0
02B12:  MOV     W0,W5
02B14:  MOV.B   110F,W0L
02B16:  SE      W0,W0
02B18:  ADD     W0,W5,W0
02B1A:  MOV     W0,1512
.................... 						fprintf(DEBUG, "topicLength: %d\r\n", packetID); 
02B1C:  MOV     #0,W1
02B1E:  MOV     W1,W0
02B20:  CLR.B   1
02B22:  CALL    634
02B26:  INC     W1,W1
02B28:  BTSC.B  223.1
02B2A:  BRA     2B28
02B2C:  MOV     W0,224
02B2E:  MOV     #C,W0
02B30:  CPSGT   W1,W0
02B32:  BRA     2B1E
02B34:  MOV     1512,W0
02B36:  MOV     #0,W4
02B38:  CALL    1620
02B3C:  BTSC.B  223.1
02B3E:  BRA     2B3C
02B40:  MOV     #D,W4
02B42:  MOV     W4,224
02B44:  BTSC.B  223.1
02B46:  BRA     2B44
02B48:  MOV     #A,W4
02B4A:  MOV     W4,224
.................... 						break; 
02B4C:  GOTO    2D9C
.................... 					} 
.................... 					case PUBREC:{						 
.................... 						fprintf(DEBUG, "reponse PUBREC: %d\r\n", mqttControlPacketType); 
02B50:  MOV     #0,W1
02B52:  MOV     W1,W0
02B54:  CLR.B   1
02B56:  CALL    7EA
02B5A:  INC     W1,W1
02B5C:  BTSC.B  223.1
02B5E:  BRA     2B5C
02B60:  MOV     W0,224
02B62:  MOV     #F,W0
02B64:  CPSGT   W1,W0
02B66:  BRA     2B52
02B68:  MOV     14F2,W0
02B6A:  MOV     #0,W4
02B6C:  CALL    1620
02B70:  BTSC.B  223.1
02B72:  BRA     2B70
02B74:  MOV     #D,W4
02B76:  MOV     W4,224
02B78:  BTSC.B  223.1
02B7A:  BRA     2B78
02B7C:  MOV     #A,W4
02B7E:  MOV     W4,224
.................... 						fprintf(DEBUG, "inputString[2]: %d\r\n", inputString[2]); 
02B80:  MOV     #0,W1
02B82:  MOV     W1,W0
02B84:  CLR.B   1
02B86:  CALL    7A6
02B8A:  INC     W1,W1
02B8C:  BTSC.B  223.1
02B8E:  BRA     2B8C
02B90:  MOV     W0,224
02B92:  MOV     #F,W0
02B94:  CPSGT   W1,W0
02B96:  BRA     2B82
02B98:  MOV.B   110E,W0L
02B9A:  SE      W0,W0
02B9C:  MOV     #0,W4
02B9E:  CALL    1620
02BA2:  BTSC.B  223.1
02BA4:  BRA     2BA2
02BA6:  MOV     #D,W4
02BA8:  MOV     W4,224
02BAA:  BTSC.B  223.1
02BAC:  BRA     2BAA
02BAE:  MOV     #A,W4
02BB0:  MOV     W4,224
.................... 						fprintf(DEBUG, "inputString[3]: %d\r\n", inputString[3]); 
02BB2:  MOV     #0,W1
02BB4:  MOV     W1,W0
02BB6:  CLR.B   1
02BB8:  CALL    7C8
02BBC:  INC     W1,W1
02BBE:  BTSC.B  223.1
02BC0:  BRA     2BBE
02BC2:  MOV     W0,224
02BC4:  MOV     #F,W0
02BC6:  CPSGT   W1,W0
02BC8:  BRA     2BB4
02BCA:  MOV.B   110F,W0L
02BCC:  SE      W0,W0
02BCE:  MOV     #0,W4
02BD0:  CALL    1620
02BD4:  BTSC.B  223.1
02BD6:  BRA     2BD4
02BD8:  MOV     #D,W4
02BDA:  MOV     W4,224
02BDC:  BTSC.B  223.1
02BDE:  BRA     2BDC
02BE0:  MOV     #A,W4
02BE2:  MOV     W4,224
.................... 						unsigned int16 messageID = inputString[2] * 256 + inputString[3]; 
02BE4:  MOV.B   110E,W0L
02BE6:  SE      W0,W0
02BE8:  MOV     #100,W4
02BEA:  MUL.SS  W0,W4,W0
02BEC:  MOV     W0,W5
02BEE:  MOV.B   110F,W0L
02BF0:  SE      W0,W0
02BF2:  ADD     W0,W5,W0
02BF4:  MOV     W0,1514
.................... 						fprintf(DEBUG, "messageID: %d\r\n", messageID); 
02BF6:  MOV     #0,W1
02BF8:  MOV     W1,W0
02BFA:  CLR.B   1
02BFC:  CALL    692
02C00:  INC     W1,W1
02C02:  BTSC.B  223.1
02C04:  BRA     2C02
02C06:  MOV     W0,224
02C08:  MOV     #A,W0
02C0A:  CPSGT   W1,W0
02C0C:  BRA     2BF8
02C0E:  MOV     1514,W0
02C10:  MOV     #0,W4
02C12:  CALL    1620
02C16:  BTSC.B  223.1
02C18:  BRA     2C16
02C1A:  MOV     #D,W4
02C1C:  MOV     W4,224
02C1E:  BTSC.B  223.1
02C20:  BRA     2C1E
02C22:  MOV     #A,W4
02C24:  MOV     W4,224
.................... 						publishREL(0, messageID); 
02C26:  CLR.B   1534
02C28:  PUSH    1514
02C2A:  POP     1536
02C2C:  CALL    1D4E
.................... 						break; 
02C30:  GOTO    2D9C
.................... 					} 
.................... 					case PUBREL:{										 
.................... 						fprintf(DEBUG, "reponse PUBREL: %d\r\n", mqttControlPacketType); 
02C34:  MOV     #0,W1
02C36:  MOV     W1,W0
02C38:  CLR.B   1
02C3A:  CALL    80C
02C3E:  INC     W1,W1
02C40:  BTSC.B  223.1
02C42:  BRA     2C40
02C44:  MOV     W0,224
02C46:  MOV     #F,W0
02C48:  CPSGT   W1,W0
02C4A:  BRA     2C36
02C4C:  MOV     14F2,W0
02C4E:  MOV     #0,W4
02C50:  CALL    1620
02C54:  BTSC.B  223.1
02C56:  BRA     2C54
02C58:  MOV     #D,W4
02C5A:  MOV     W4,224
02C5C:  BTSC.B  223.1
02C5E:  BRA     2C5C
02C60:  MOV     #A,W4
02C62:  MOV     W4,224
.................... 						fprintf(DEBUG, "inputString[2]: %d\r\n", inputString[2]); 
02C64:  MOV     #0,W1
02C66:  MOV     W1,W0
02C68:  CLR.B   1
02C6A:  CALL    7A6
02C6E:  INC     W1,W1
02C70:  BTSC.B  223.1
02C72:  BRA     2C70
02C74:  MOV     W0,224
02C76:  MOV     #F,W0
02C78:  CPSGT   W1,W0
02C7A:  BRA     2C66
02C7C:  MOV.B   110E,W0L
02C7E:  SE      W0,W0
02C80:  MOV     #0,W4
02C82:  CALL    1620
02C86:  BTSC.B  223.1
02C88:  BRA     2C86
02C8A:  MOV     #D,W4
02C8C:  MOV     W4,224
02C8E:  BTSC.B  223.1
02C90:  BRA     2C8E
02C92:  MOV     #A,W4
02C94:  MOV     W4,224
.................... 						fprintf(DEBUG, "inputString[3]: %d\r\n", inputString[3]); 
02C96:  MOV     #0,W1
02C98:  MOV     W1,W0
02C9A:  CLR.B   1
02C9C:  CALL    7C8
02CA0:  INC     W1,W1
02CA2:  BTSC.B  223.1
02CA4:  BRA     2CA2
02CA6:  MOV     W0,224
02CA8:  MOV     #F,W0
02CAA:  CPSGT   W1,W0
02CAC:  BRA     2C98
02CAE:  MOV.B   110F,W0L
02CB0:  SE      W0,W0
02CB2:  MOV     #0,W4
02CB4:  CALL    1620
02CB8:  BTSC.B  223.1
02CBA:  BRA     2CB8
02CBC:  MOV     #D,W4
02CBE:  MOV     W4,224
02CC0:  BTSC.B  223.1
02CC2:  BRA     2CC0
02CC4:  MOV     #A,W4
02CC6:  MOV     W4,224
.................... 						unsigned int16 messageID = inputString[2] * 256 + inputString[3]; 
02CC8:  MOV.B   110E,W0L
02CCA:  SE      W0,W0
02CCC:  MOV     #100,W4
02CCE:  MUL.SS  W0,W4,W0
02CD0:  MOV     W0,W5
02CD2:  MOV.B   110F,W0L
02CD4:  SE      W0,W0
02CD6:  ADD     W0,W5,W0
02CD8:  MOV     W0,1516
.................... 						fprintf(DEBUG, "messageID: %d\r\n", messageID); 
02CDA:  MOV     #0,W1
02CDC:  MOV     W1,W0
02CDE:  CLR.B   1
02CE0:  CALL    692
02CE4:  INC     W1,W1
02CE6:  BTSC.B  223.1
02CE8:  BRA     2CE6
02CEA:  MOV     W0,224
02CEC:  MOV     #A,W0
02CEE:  CPSGT   W1,W0
02CF0:  BRA     2CDC
02CF2:  MOV     1516,W0
02CF4:  MOV     #0,W4
02CF6:  CALL    1620
02CFA:  BTSC.B  223.1
02CFC:  BRA     2CFA
02CFE:  MOV     #D,W4
02D00:  MOV     W4,224
02D02:  BTSC.B  223.1
02D04:  BRA     2D02
02D06:  MOV     #A,W4
02D08:  MOV     W4,224
.................... 						publishCOMP(messageID); 
02D0A:  PUSH    1516
02D0C:  POP     1534
02D0E:  CALL    1DDA
.................... 						break; 
02D12:  GOTO    2D9C
.................... 					} 
.................... 					case PINGREQ:{					 
.................... 						fprintf(DEBUG, "reponse PINGREQUEST: %d\r\n", mqttControlPacketType); 
02D16:  MOV     #0,W1
02D18:  MOV     W1,W0
02D1A:  CLR.B   1
02D1C:  CALL    82E
02D20:  INC     W1,W1
02D22:  BTSC.B  223.1
02D24:  BRA     2D22
02D26:  MOV     W0,224
02D28:  MOV     #14,W0
02D2A:  CPSGT   W1,W0
02D2C:  BRA     2D18
02D2E:  MOV     14F2,W0
02D30:  MOV     #0,W4
02D32:  CALL    1620
02D36:  BTSC.B  223.1
02D38:  BRA     2D36
02D3A:  MOV     #D,W4
02D3C:  MOV     W4,224
02D3E:  BTSC.B  223.1
02D40:  BRA     2D3E
02D42:  MOV     #A,W4
02D44:  MOV     W4,224
.................... 						tcpFlag = false; 
02D46:  BCLR.B  1109.1
.................... 						pingFlag = false; 
02D48:  BCLR.B  1264.1
.................... 						fprintf(DEBUG, "Disconnecting...\r\n"); 
02D4A:  MOV     #0,W1
02D4C:  MOV     W1,W0
02D4E:  CLR.B   1
02D50:  CALL    854
02D54:  INC     W1,W1
02D56:  BTSC.B  223.1
02D58:  BRA     2D56
02D5A:  MOV     W0,224
02D5C:  MOV     #11,W0
02D5E:  CPSGT   W1,W0
02D60:  BRA     2D4C
.................... 						modemStatus = 0; 
02D62:  CLR     1278
.................... 						break; 
02D64:  GOTO    2D9C
.................... 					} 
.................... 					case PINGRESP:{ 
.................... 						fprintf(DEBUG, "response PINGRESPONSE: %d\r\n", mqttControlPacketType); 
02D68:  MOV     #0,W1
02D6A:  MOV     W1,W0
02D6C:  CLR.B   1
02D6E:  CALL    874
02D72:  INC     W1,W1
02D74:  BTSC.B  223.1
02D76:  BRA     2D74
02D78:  MOV     W0,224
02D7A:  MOV     #16,W0
02D7C:  CPSGT   W1,W0
02D7E:  BRA     2D6A
02D80:  MOV     14F2,W0
02D82:  MOV     #0,W4
02D84:  CALL    1620
02D88:  BTSC.B  223.1
02D8A:  BRA     2D88
02D8C:  MOV     #D,W4
02D8E:  MOV     W4,224
02D90:  BTSC.B  223.1
02D92:  BRA     2D90
02D94:  MOV     #A,W4
02D96:  MOV     W4,224
.................... 						break; 
02D98:  GOTO    2D9C
.................... 					} 
.................... 				} 
.................... 			} 
.................... 		} 
.................... 		output_low(dataLed); 
02D9C:  BCLR.B  E40.7
02D9E:  BCLR.B  E44.7
.................... 	}	 
02DA0:  MOV     [--W15],W8
02DA2:  MOV     [--W15],W7
02DA4:  MOV     [--W15],W6
02DA6:  MOV     [--W15],W5
02DA8:  RETURN  
.................... } 
....................  
.................... void connectReturnCode(unsigned int ack){ 
.................... 	fprintf(DEBUG, "Connect Return Code: 0x%2x\r\n", ack); 
*
01B3C:  MOV     #0,W1
01B3E:  MOV     W1,W0
01B40:  CLR.B   1
01B42:  CALL    89C
01B46:  INC     W1,W1
01B48:  BTSC.B  223.1
01B4A:  BRA     1B48
01B4C:  MOV     W0,224
01B4E:  MOV     #16,W0
01B50:  CPSGT   W1,W0
01B52:  BRA     1B3E
01B54:  MOV     1534,W0
01B56:  MOV     #2702,W1
01B58:  CALL    13C8
01B5C:  BTSC.B  223.1
01B5E:  BRA     1B5C
01B60:  MOV     #D,W4
01B62:  MOV     W4,224
01B64:  BTSC.B  223.1
01B66:  BRA     1B64
01B68:  MOV     #A,W4
01B6A:  MOV     W4,224
.................... 	switch(ack){ 
01B6C:  MOV     1534,W0
01B6E:  XOR     #0,W0
01B70:  BRA     Z,1B88
01B72:  XOR     #1,W0
01B74:  BRA     Z,1BA4
01B76:  XOR     #3,W0
01B78:  BRA     Z,1BC0
01B7A:  XOR     #1,W0
01B7C:  BRA     Z,1BDC
01B7E:  XOR     #7,W0
01B80:  BRA     Z,1BF8
01B82:  XOR     #1,W0
01B84:  BRA     Z,1C14
01B86:  BRA     1C30
.................... 		case 0:{ 
.................... 			fprintf(DEBUG, "Connect Accepted.\r\n"); 
01B88:  MOV     #0,W1
01B8A:  MOV     W1,W0
01B8C:  CLR.B   1
01B8E:  CALL    8C6
01B92:  INC     W1,W1
01B94:  BTSC.B  223.1
01B96:  BRA     1B94
01B98:  MOV     W0,224
01B9A:  MOV     #12,W0
01B9C:  CPSGT   W1,W0
01B9E:  BRA     1B8A
.................... 			break; 
01BA0:  GOTO    1C4C
.................... 		} 
.................... 		case 1:{ 
.................... 			fprintf(DEBUG, "Connection Refused, reason: Unacceptale Protocol Version\r\n"); 
01BA4:  MOV     #0,W1
01BA6:  MOV     W1,W0
01BA8:  CLR.B   1
01BAA:  CALL    8E6
01BAE:  INC     W1,W1
01BB0:  BTSC.B  223.1
01BB2:  BRA     1BB0
01BB4:  MOV     W0,224
01BB6:  MOV     #39,W0
01BB8:  CPSGT   W1,W0
01BBA:  BRA     1BA6
.................... 			break; 
01BBC:  GOTO    1C4C
.................... 		} 
.................... 		case 2:{ 
.................... 			fprintf(DEBUG, "Connection Refused, reason: Identifier Rejected\r\n"); 
01BC0:  MOV     #0,W1
01BC2:  MOV     W1,W0
01BC4:  CLR.B   1
01BC6:  CALL    92A
01BCA:  INC     W1,W1
01BCC:  BTSC.B  223.1
01BCE:  BRA     1BCC
01BD0:  MOV     W0,224
01BD2:  MOV     #30,W0
01BD4:  CPSGT   W1,W0
01BD6:  BRA     1BC2
.................... 			break; 
01BD8:  GOTO    1C4C
.................... 		} 
.................... 		case 3:{ 
.................... 			fprintf(DEBUG, "Connection Refused, reason: Server Unavailable\r\n"); 
01BDC:  MOV     #0,W1
01BDE:  MOV     W1,W0
01BE0:  CLR.B   1
01BE2:  CALL    968
01BE6:  INC     W1,W1
01BE8:  BTSC.B  223.1
01BEA:  BRA     1BE8
01BEC:  MOV     W0,224
01BEE:  MOV     #2F,W0
01BF0:  CPSGT   W1,W0
01BF2:  BRA     1BDE
.................... 			break; 
01BF4:  GOTO    1C4C
.................... 		} 
.................... 		case 4:{ 
.................... 			fprintf(DEBUG, "Connection Refused, reason: Bad User Name of Password\r\n"); 
01BF8:  MOV     #0,W1
01BFA:  MOV     W1,W0
01BFC:  CLR.B   1
01BFE:  CALL    9A6
01C02:  INC     W1,W1
01C04:  BTSC.B  223.1
01C06:  BRA     1C04
01C08:  MOV     W0,224
01C0A:  MOV     #36,W0
01C0C:  CPSGT   W1,W0
01C0E:  BRA     1BFA
.................... 			break; 
01C10:  GOTO    1C4C
.................... 		} 
.................... 		case 5:{ 
.................... 			fprintf(DEBUG, "Connection Refused, reason: Not Authorized"); 
01C14:  MOV     #0,W1
01C16:  MOV     W1,W0
01C18:  CLR.B   1
01C1A:  CALL    9E8
01C1E:  INC     W1,W1
01C20:  BTSC.B  223.1
01C22:  BRA     1C20
01C24:  MOV     W0,224
01C26:  MOV     #29,W0
01C28:  CPSGT   W1,W0
01C2A:  BRA     1C16
.................... 			break; 
01C2C:  GOTO    1C4C
.................... 		} 
.................... 		default:{ 
.................... 			fprintf(DEBUG, "Reserved for future use\r\n"); 
01C30:  MOV     #0,W1
01C32:  MOV     W1,W0
01C34:  CLR.B   1
01C36:  CALL    A22
01C3A:  INC     W1,W1
01C3C:  BTSC.B  223.1
01C3E:  BRA     1C3C
01C40:  MOV     W0,224
01C42:  MOV     #18,W0
01C44:  CPSGT   W1,W0
01C46:  BRA     1C32
.................... 			break; 
01C48:  GOTO    1C4C
.................... 		} 
.................... 	} 
01C4C:  RETURN  
.................... } 
....................  
.................... char sendAT(char * command, unsigned long waitms){ 
.................... 	unsigned int16 currentTicks; 
.................... 	gsmResponse = 0; 
*
02DAA:  CLR     1274
.................... 	fprintf(DEBUG, "Send Command:"); 
02DAC:  MOV     #0,W1
02DAE:  MOV     W1,W0
02DB0:  CLR.B   1
02DB2:  CALL    A48
02DB6:  INC     W1,W1
02DB8:  BTSC.B  223.1
02DBA:  BRA     2DB8
02DBC:  MOV     W0,224
02DBE:  MOV     #C,W0
02DC0:  CPSGT   W1,W0
02DC2:  BRA     2DAE
.................... 	fprintf(DEBUG, command); 
02DC4:  MOV     14CC,W1
02DC6:  CP0.B   [W1]
02DC8:  BRA     Z,2DD8
02DCA:  BTSC.B  223.1
02DCC:  BRA     2DCA
02DCE:  MOV.B   [W1+#0],W0L
02DD0:  MOV.B   W0L,224
02DD2:  CLR.B   225
02DD4:  INC     W1,W1
02DD6:  BRA     2DC6
.................... 	fprintf(SIMM95, command); 
02DD8:  MOV     14CC,W1
02DDA:  CP0.B   [W1]
02DDC:  BRA     Z,2DEC
02DDE:  BTSC.B  253.1
02DE0:  BRA     2DDE
02DE2:  MOV.B   [W1+#0],W0L
02DE4:  MOV.B   W0L,254
02DE6:  CLR.B   255
02DE8:  INC     W1,W1
02DEA:  BRA     2DDA
.................... 	set_ticks(T1, 0); 
02DEC:  CLR     14DE
02DEE:  CALL    132C
.................... 	currentTicks = get_ticks(T1); 
02DF2:  CALL    1342
02DF6:  MOV     W0,14D2
.................... 	while((gsmResponse == 0) && (currentTicks < waitms)){ 
02DF8:  CP0     1274
02DFA:  BRA     NZ,2E1A
02DFC:  MOV     14D0,W4
02DFE:  CP      W4,#0
02E00:  BRA     NC,2E1A
02E02:  BRA     GTU,2E0C
02E04:  MOV     14D2,W0
02E06:  MOV     14CE,W4
02E08:  CP      W4,W0
02E0A:  BRA     LEU,2E1A
.................... 		serialEvent(); 
02E0C:  CALL    1E5A
.................... 		currentTicks = get_ticks(T1); 
02E10:  CALL    1342
02E14:  MOV     W0,14D2
02E16:  GOTO    2DF8
.................... 	} 
.................... 	return gsmResponse; 
02E1A:  MOV.B   1274,W0L
02E1C:  MOV.B   W0L,0
02E1E:  RETURN  
.................... } 
....................  
.................... char sendATResponse(char *command, char *responseStr, unsigned long waitms){ 
.................... 	unsigned int16 currentTicks; 
.................... 	memset(reply, 0, sizeof(reply)); 
02E20:  MOV     1296,W1
02E22:  MOV     #0,W2
02E24:  REPEAT  #1
02E26:  CLR.B   [W1++]
.................... 	sprintf(reply, responseStr); 
02E28:  PUSH    1296
02E2A:  POP     1476
02E2C:  MOV     14CE,W1
02E2E:  CP0.B   [W1]
02E30:  BRA     Z,2E42
02E32:  MOV     W1,[W15++]
02E34:  MOV     W1,W4
02E36:  MOV.B   [W4],W0L
02E38:  CALL    12DE
02E3C:  MOV     [--W15],W1
02E3E:  INC     W1,W1
02E40:  BRA     2E2E
.................... 	gsmResponseFlag = 0; 
02E42:  CLR     1276
.................... 	fprintf(DEBUG, "response function:"); 
02E44:  MOV     #0,W1
02E46:  MOV     W1,W0
02E48:  CLR.B   1
02E4A:  CALL    A62
02E4E:  INC     W1,W1
02E50:  BTSC.B  223.1
02E52:  BRA     2E50
02E54:  MOV     W0,224
02E56:  MOV     #11,W0
02E58:  CPSGT   W1,W0
02E5A:  BRA     2E46
.................... 	fprintf(DEBUG, command); 
02E5C:  MOV     14CC,W1
02E5E:  CP0.B   [W1]
02E60:  BRA     Z,2E70
02E62:  BTSC.B  223.1
02E64:  BRA     2E62
02E66:  MOV.B   [W1+#0],W0L
02E68:  MOV.B   W0L,224
02E6A:  CLR.B   225
02E6C:  INC     W1,W1
02E6E:  BRA     2E5E
.................... 	fprintf(SIMM95, command); 
02E70:  MOV     14CC,W1
02E72:  CP0.B   [W1]
02E74:  BRA     Z,2E84
02E76:  BTSC.B  253.1
02E78:  BRA     2E76
02E7A:  MOV.B   [W1+#0],W0L
02E7C:  MOV.B   W0L,254
02E7E:  CLR.B   255
02E80:  INC     W1,W1
02E82:  BRA     2E72
.................... 	set_ticks(T1, 0); 
02E84:  CLR     14DE
02E86:  CALL    132C
.................... 	currentTicks = get_ticks(T1); 
02E8A:  CALL    1342
02E8E:  MOV     W0,14D4
.................... 	while((gsmResponseFlag == 0) && (currentTicks < waitms)){ 
02E90:  CP0     1276
02E92:  BRA     NZ,2EB2
02E94:  MOV     14D2,W4
02E96:  CP      W4,#0
02E98:  BRA     NC,2EB2
02E9A:  BRA     GTU,2EA4
02E9C:  MOV     14D4,W0
02E9E:  MOV     14D0,W4
02EA0:  CP      W4,W0
02EA2:  BRA     LEU,2EB2
.................... 		serialEvent(); 
02EA4:  CALL    1E5A
.................... 		currentTicks = get_ticks(T1); 
02EA8:  CALL    1342
02EAC:  MOV     W0,14D4
02EAE:  GOTO    2E90
.................... 	} 
.................... 	return gsmResponseFlag; 
02EB2:  MOV.B   1276,W0L
02EB4:  MOV.B   W0L,0
02EB6:  RETURN  
.................... } 
....................  
.................... void sendLength(unsigned long length){ 
*
01578:  MOV     W5,[W15++]
0157A:  MOV     W6,[W15++]
0157C:  BCLR.B  1548.0
.................... 	bool lengthFlag = false; 
.................... 	while(lengthFlag == false){ 
0157E:  BTSC.B  1548.0
01580:  BRA     161A
.................... 		if((length / 128) > 0){ 
01582:  MOV     #7,W4
01584:  CLR.B   9
01586:  MOV     1544,W5
01588:  MOV     1546,W6
0158A:  INC     W4,W4
0158C:  DEC     W4,W4
0158E:  BRA     Z,1596
01590:  LSR     W6,W6
01592:  RRC     W5,W5
01594:  BRA     158C
01596:  CP0     W5
01598:  BRA     NZ,159E
0159A:  CP0     W6
0159C:  BRA     Z,15E8
.................... 			fputc((length % 128 + 128), SIMM95); 
0159E:  MOV     1544,W5
015A0:  AND     #7F,W5
015A2:  CLR     W6
015A4:  ADD     #80,W5
015A6:  ADDC    W6,#0,W6
015A8:  MOV.B   W5L,W0L
015AA:  BTSC.B  253.1
015AC:  BRA     15AA
015AE:  MOV.B   W0L,254
015B0:  CLR.B   255
.................... 			fprintf(DEBUG, "Send Length: %d", length); 
015B2:  MOV     #0,W1
015B4:  MOV     W1,W0
015B6:  CLR.B   1
015B8:  CALL    A82
015BC:  INC     W1,W1
015BE:  BTSC.B  223.1
015C0:  BRA     15BE
015C2:  MOV     W0,224
015C4:  MOV     #C,W0
015C6:  CPSGT   W1,W0
015C8:  BRA     15B4
015CA:  MOV     1544,W0
015CC:  MOV     1546,W1
015CE:  MOV     #0,W4
015D0:  CALL    1440
.................... 			length /= 128; 
015D4:  MOV     #7,W4
015D6:  CLR.B   9
015D8:  INC     W4,W4
015DA:  DEC     W4,W4
015DC:  BRA     Z,15E4
015DE:  LSR     1546
015E0:  RRC     1544
015E2:  BRA     15DA
.................... 		} 
015E4:  GOTO    1616
.................... 		else{ 
.................... 			fputc((length), SIMM95); 
015E8:  MOV.B   1544,W0L
015EA:  BTSC.B  253.1
015EC:  BRA     15EA
015EE:  MOV.B   W0L,254
015F0:  CLR.B   255
.................... 			fprintf(DEBUG, "Send Length: %d", length); 
015F2:  MOV     #0,W1
015F4:  MOV     W1,W0
015F6:  CLR.B   1
015F8:  CALL    A82
015FC:  INC     W1,W1
015FE:  BTSC.B  223.1
01600:  BRA     15FE
01602:  MOV     W0,224
01604:  MOV     #C,W0
01606:  CPSGT   W1,W0
01608:  BRA     15F4
0160A:  MOV     1544,W0
0160C:  MOV     1546,W1
0160E:  MOV     #0,W4
01610:  CALL    1440
.................... 			lengthFlag = true; 
01614:  BSET.B  1548.0
.................... 		} 
01616:  GOTO    157E
.................... 	} 
0161A:  MOV     [--W15],W6
0161C:  MOV     [--W15],W5
0161E:  RETURN  
.................... } 
....................  
.................... void sendUTF8String(char *string){ 
*
01716:  MOV     W5,[W15++]
01718:  PUSH    1548
0171A:  POP     154E
0171C:  CALL    1554
01720:  MOV.B   W0L,154A
01722:  CLR.B   154B
.................... 	int lengthString = strlen(string); 
.................... 	fputc((lengthString / 256), SIMM95); 
01724:  MOV     154A,W4
01726:  MOV     #100,W3
01728:  REPEAT  #11
0172A:  DIV.S   W4,W3
0172C:  MOV     W0,W5
0172E:  MOV.B   W5L,W0L
01730:  BTSC.B  253.1
01732:  BRA     1730
01734:  MOV.B   W0L,254
01736:  CLR.B   255
.................... 	fputc((lengthString % 256), SIMM95); 
01738:  MOV     154A,W4
0173A:  MOV     #100,W3
0173C:  REPEAT  #11
0173E:  DIV.S   W4,W3
01740:  MOV     W1,W5
01742:  MOV.B   W5L,W0L
01744:  BTSC.B  253.1
01746:  BRA     1744
01748:  MOV.B   W0L,254
0174A:  CLR.B   255
.................... 	fprintf(SIMM95, string); 
0174C:  MOV     1548,W1
0174E:  CP0.B   [W1]
01750:  BRA     Z,1760
01752:  BTSC.B  253.1
01754:  BRA     1752
01756:  MOV.B   [W1+#0],W0L
01758:  MOV.B   W0L,254
0175A:  CLR.B   255
0175C:  INC     W1,W1
0175E:  BRA     174E
.................... 	 
.................... 	fprintf(DEBUG, "Send Length String: %d\r\n", lengthString); 
01760:  MOV     #0,W1
01762:  MOV     W1,W0
01764:  CLR.B   1
01766:  CALL    A9E
0176A:  INC     W1,W1
0176C:  BTSC.B  223.1
0176E:  BRA     176C
01770:  MOV     W0,224
01772:  MOV     #13,W0
01774:  CPSGT   W1,W0
01776:  BRA     1762
01778:  MOV     154A,W0
0177A:  MOV     #0,W4
0177C:  CALL    1620
01780:  BTSC.B  223.1
01782:  BRA     1780
01784:  MOV     #D,W4
01786:  MOV     W4,224
01788:  BTSC.B  223.1
0178A:  BRA     1788
0178C:  MOV     #A,W4
0178E:  MOV     W4,224
.................... 	fprintf(DEBUG, "SendUTF8String: %s\r\n", string); 
01790:  MOV     #0,W1
01792:  MOV     W1,W0
01794:  CLR.B   1
01796:  CALL    AC4
0179A:  INC     W1,W1
0179C:  BTSC.B  223.1
0179E:  BRA     179C
017A0:  MOV     W0,224
017A2:  MOV     #F,W0
017A4:  CPSGT   W1,W0
017A6:  BRA     1792
017A8:  MOV     1548,W1
017AA:  CP0.B   [W1]
017AC:  BRA     Z,17BC
017AE:  BTSC.B  223.1
017B0:  BRA     17AE
017B2:  MOV.B   [W1+#0],W0L
017B4:  MOV.B   W0L,224
017B6:  CLR.B   225
017B8:  INC     W1,W1
017BA:  BRA     17AA
017BC:  BTSC.B  223.1
017BE:  BRA     17BC
017C0:  MOV     #D,W4
017C2:  MOV     W4,224
017C4:  BTSC.B  223.1
017C6:  BRA     17C4
017C8:  MOV     #A,W4
017CA:  MOV     W4,224
017CC:  MOV     [--W15],W5
017CE:  RETURN  
.................... } 
....................  
.................... void publishACK(unsigned int16 messageID){ 
*
01C4E:  MOV     W5,[W15++]
.................... 	fprintf(DEBUG, "publishACK: "); 
01C50:  MOV     #0,W1
01C52:  MOV     W1,W0
01C54:  CLR.B   1
01C56:  CALL    AE6
01C5A:  INC     W1,W1
01C5C:  BTSC.B  223.1
01C5E:  BRA     1C5C
01C60:  MOV     W0,224
01C62:  MOV     #B,W0
01C64:  CPSGT   W1,W0
01C66:  BRA     1C52
.................... 	fprintf(DEBUG, "messageID: %d\r\n", messageID); 
01C68:  MOV     #0,W1
01C6A:  MOV     W1,W0
01C6C:  CLR.B   1
01C6E:  CALL    692
01C72:  INC     W1,W1
01C74:  BTSC.B  223.1
01C76:  BRA     1C74
01C78:  MOV     W0,224
01C7A:  MOV     #A,W0
01C7C:  CPSGT   W1,W0
01C7E:  BRA     1C6A
01C80:  MOV     1534,W0
01C82:  MOV     #0,W4
01C84:  CALL    1620
01C88:  BTSC.B  223.1
01C8A:  BRA     1C88
01C8C:  MOV     #D,W4
01C8E:  MOV     W4,224
01C90:  BTSC.B  223.1
01C92:  BRA     1C90
01C94:  MOV     #A,W4
01C96:  MOV     W4,224
.................... 	fputc((PUBACK * 16), SIMM95); 
01C98:  MOV.B   #40,W0L
01C9A:  BTSC.B  253.1
01C9C:  BRA     1C9A
01C9E:  MOV.B   W0L,254
01CA0:  CLR.B   255
.................... 	sendLength(2); 
01CA2:  MOV     #2,W4
01CA4:  MOV     W4,1544
01CA6:  CLR     1546
01CA8:  CALL    1578
.................... 	fputc((messageID / 256), SIMM95); 
01CAC:  MOV.B   1535,W0L
01CAE:  MOV.B   W0L,W5L
01CB0:  CLR.B   B
01CB2:  MOV.B   W5L,W0L
01CB4:  BTSC.B  253.1
01CB6:  BRA     1CB4
01CB8:  MOV.B   W0L,254
01CBA:  CLR.B   255
.................... 	fputc((messageID % 256), SIMM95); 
01CBC:  MOV     1534,W5
01CBE:  AND     #FF,W5
01CC0:  MOV.B   W5L,W0L
01CC2:  BTSC.B  253.1
01CC4:  BRA     1CC2
01CC6:  MOV.B   W0L,254
01CC8:  CLR.B   255
01CCA:  MOV     [--W15],W5
01CCC:  RETURN  
.................... } 
....................  
.................... void publishREC(unsigned int16 messageID){ 
01CCE:  MOV     W5,[W15++]
.................... 	fprintf(DEBUG, "publishREC: "); 
01CD0:  MOV     #0,W1
01CD2:  MOV     W1,W0
01CD4:  CLR.B   1
01CD6:  CALL    B00
01CDA:  INC     W1,W1
01CDC:  BTSC.B  223.1
01CDE:  BRA     1CDC
01CE0:  MOV     W0,224
01CE2:  MOV     #B,W0
01CE4:  CPSGT   W1,W0
01CE6:  BRA     1CD2
.................... 	fprintf(DEBUG, "messageID: %d\r\n", messageID); 
01CE8:  MOV     #0,W1
01CEA:  MOV     W1,W0
01CEC:  CLR.B   1
01CEE:  CALL    692
01CF2:  INC     W1,W1
01CF4:  BTSC.B  223.1
01CF6:  BRA     1CF4
01CF8:  MOV     W0,224
01CFA:  MOV     #A,W0
01CFC:  CPSGT   W1,W0
01CFE:  BRA     1CEA
01D00:  MOV     1534,W0
01D02:  MOV     #0,W4
01D04:  CALL    1620
01D08:  BTSC.B  223.1
01D0A:  BRA     1D08
01D0C:  MOV     #D,W4
01D0E:  MOV     W4,224
01D10:  BTSC.B  223.1
01D12:  BRA     1D10
01D14:  MOV     #A,W4
01D16:  MOV     W4,224
.................... 	fputc((PUBREC * 16), SIMM95); 
01D18:  MOV.B   #50,W0L
01D1A:  BTSC.B  253.1
01D1C:  BRA     1D1A
01D1E:  MOV.B   W0L,254
01D20:  CLR.B   255
.................... 	sendLength(2); 
01D22:  MOV     #2,W4
01D24:  MOV     W4,1544
01D26:  CLR     1546
01D28:  CALL    1578
.................... 	fputc((messageID / 256), SIMM95); 
01D2C:  MOV.B   1535,W0L
01D2E:  MOV.B   W0L,W5L
01D30:  CLR.B   B
01D32:  MOV.B   W5L,W0L
01D34:  BTSC.B  253.1
01D36:  BRA     1D34
01D38:  MOV.B   W0L,254
01D3A:  CLR.B   255
.................... 	fputc((messageID % 256), SIMM95); 
01D3C:  MOV     1534,W5
01D3E:  AND     #FF,W5
01D40:  MOV.B   W5L,W0L
01D42:  BTSC.B  253.1
01D44:  BRA     1D42
01D46:  MOV.B   W0L,254
01D48:  CLR.B   255
01D4A:  MOV     [--W15],W5
01D4C:  RETURN  
.................... } 
....................  
.................... void publishREL(unsigned int1 DUP, unsigned int16 messageID){ 
01D4E:  MOV     W5,[W15++]
.................... 	fprintf(DEBUG, "publishREL: "); 
01D50:  MOV     #0,W1
01D52:  MOV     W1,W0
01D54:  CLR.B   1
01D56:  CALL    B1A
01D5A:  INC     W1,W1
01D5C:  BTSC.B  223.1
01D5E:  BRA     1D5C
01D60:  MOV     W0,224
01D62:  MOV     #B,W0
01D64:  CPSGT   W1,W0
01D66:  BRA     1D52
.................... 	fprintf(DEBUG, "messageID: %d\r\n", messageID); 
01D68:  MOV     #0,W1
01D6A:  MOV     W1,W0
01D6C:  CLR.B   1
01D6E:  CALL    692
01D72:  INC     W1,W1
01D74:  BTSC.B  223.1
01D76:  BRA     1D74
01D78:  MOV     W0,224
01D7A:  MOV     #A,W0
01D7C:  CPSGT   W1,W0
01D7E:  BRA     1D6A
01D80:  MOV     1536,W0
01D82:  MOV     #0,W4
01D84:  CALL    1620
01D88:  BTSC.B  223.1
01D8A:  BRA     1D88
01D8C:  MOV     #D,W4
01D8E:  MOV     W4,224
01D90:  BTSC.B  223.1
01D92:  BRA     1D90
01D94:  MOV     #A,W4
01D96:  MOV     W4,224
.................... 	fputc((PUBREL * 16 + DUP * dupMask + 1 * QoSScale), SIMM95); 
01D98:  MOV.B   1534,W0L
01D9A:  CLR.B   1
01D9C:  SL      W0,#3,W0
01D9E:  MOV     #60,W4
01DA0:  ADD     W0,W4,W5
01DA2:  ADD     W5,#2,W5
01DA4:  MOV.B   W5L,W0L
01DA6:  BTSC.B  253.1
01DA8:  BRA     1DA6
01DAA:  MOV.B   W0L,254
01DAC:  CLR.B   255
.................... 	sendLength(2); 
01DAE:  MOV     #2,W4
01DB0:  MOV     W4,1544
01DB2:  CLR     1546
01DB4:  CALL    1578
.................... 	fputc((messageID / 256), SIMM95); 
01DB8:  MOV.B   1537,W0L
01DBA:  MOV.B   W0L,W5L
01DBC:  CLR.B   B
01DBE:  MOV.B   W5L,W0L
01DC0:  BTSC.B  253.1
01DC2:  BRA     1DC0
01DC4:  MOV.B   W0L,254
01DC6:  CLR.B   255
.................... 	fputc((messageID % 256), SIMM95); 
01DC8:  MOV     1536,W5
01DCA:  AND     #FF,W5
01DCC:  MOV.B   W5L,W0L
01DCE:  BTSC.B  253.1
01DD0:  BRA     1DCE
01DD2:  MOV.B   W0L,254
01DD4:  CLR.B   255
01DD6:  MOV     [--W15],W5
01DD8:  RETURN  
.................... } 
....................  
.................... void publishCOMP(unsigned int16 messageID){ 
01DDA:  MOV     W5,[W15++]
.................... 	fprintf(DEBUG, "publishCOMP: "); 
01DDC:  MOV     #0,W1
01DDE:  MOV     W1,W0
01DE0:  CLR.B   1
01DE2:  CALL    B34
01DE6:  INC     W1,W1
01DE8:  BTSC.B  223.1
01DEA:  BRA     1DE8
01DEC:  MOV     W0,224
01DEE:  MOV     #C,W0
01DF0:  CPSGT   W1,W0
01DF2:  BRA     1DDE
.................... 	fprintf(DEBUG, "messageID: %d\r\n", messageID); 
01DF4:  MOV     #0,W1
01DF6:  MOV     W1,W0
01DF8:  CLR.B   1
01DFA:  CALL    692
01DFE:  INC     W1,W1
01E00:  BTSC.B  223.1
01E02:  BRA     1E00
01E04:  MOV     W0,224
01E06:  MOV     #A,W0
01E08:  CPSGT   W1,W0
01E0A:  BRA     1DF6
01E0C:  MOV     1534,W0
01E0E:  MOV     #0,W4
01E10:  CALL    1620
01E14:  BTSC.B  223.1
01E16:  BRA     1E14
01E18:  MOV     #D,W4
01E1A:  MOV     W4,224
01E1C:  BTSC.B  223.1
01E1E:  BRA     1E1C
01E20:  MOV     #A,W4
01E22:  MOV     W4,224
.................... 	fputc((PUBCOMP * 16), SIMM95); 
01E24:  MOV.B   #70,W0L
01E26:  BTSC.B  253.1
01E28:  BRA     1E26
01E2A:  MOV.B   W0L,254
01E2C:  CLR.B   255
.................... 	sendLength(2); 
01E2E:  MOV     #2,W4
01E30:  MOV     W4,1544
01E32:  CLR     1546
01E34:  CALL    1578
.................... 	fputc((messageID / 256), SIMM95); 
01E38:  MOV.B   1535,W0L
01E3A:  MOV.B   W0L,W5L
01E3C:  CLR.B   B
01E3E:  MOV.B   W5L,W0L
01E40:  BTSC.B  253.1
01E42:  BRA     1E40
01E44:  MOV.B   W0L,254
01E46:  CLR.B   255
.................... 	fputc((messageID % 256), SIMM95); 
01E48:  MOV     1534,W5
01E4A:  AND     #FF,W5
01E4C:  MOV.B   W5L,W0L
01E4E:  BTSC.B  253.1
01E50:  BRA     1E4E
01E52:  MOV.B   W0L,254
01E54:  CLR.B   255
01E56:  MOV     [--W15],W5
01E58:  RETURN  
.................... } 
....................  
.................... void pingRequest(){ 
*
03D02:  MOV     W5,[W15++]
03D04:  MOV     W6,[W15++]
03D06:  MOV     W7,[W15++]
03D08:  MOV     W8,[W15++]
03D0A:  CALL    3C9E
03D0E:  MOV     W0,1478
03D10:  CLR     147A
.................... 	unsigned long currentTicks = get_ticks(T2); 
.................... 	if(pingFlag){ 
03D12:  BTSS.B  1264.1
03D14:  BRA     3D82
.................... 		if((currentTicks - pingPrevTicks) >= keepAliveTimeout*1000/4){ 
03D16:  MOV     1478,W4
03D18:  MOV     1288,W3
03D1A:  SUB     W4,W3,W5
03D1C:  MOV     147A,W4
03D1E:  MOV     128A,W3
03D20:  SUBB    W4,W3,W6
03D22:  MOV     1284,W0
03D24:  MOV     1286,W1
03D26:  MOV     #3E8,W2
03D28:  MOV     #0,W3
03D2A:  CALL    3CD2
03D2E:  MOV     W0,W7
03D30:  MOV     W1,W8
03D32:  MOV     #2,W4
03D34:  CLR.B   9
03D36:  MOV     W7,W0
03D38:  MOV     W8,W1
03D3A:  INC     W4,W4
03D3C:  DEC     W4,W4
03D3E:  BRA     Z,3D46
03D40:  LSR     W1,W1
03D42:  RRC     W0,W0
03D44:  BRA     3D3C
03D46:  CP      W1,W6
03D48:  BRA     GTU,3D82
03D4A:  BRA     NC,3D50
03D4C:  CP      W0,W5
03D4E:  BRA     GTU,3D82
.................... 			pingPrevTicks = currentTicks;	 
03D50:  PUSH    1478
03D52:  POP     1288
03D54:  PUSH    147A
03D56:  POP     128A
.................... 			fprintf(DEBUG, "pingRequest: \r\n"); 
03D58:  MOV     #0,W1
03D5A:  MOV     W1,W0
03D5C:  CLR.B   1
03D5E:  CALL    B4E
03D62:  INC     W1,W1
03D64:  BTSC.B  223.1
03D66:  BRA     3D64
03D68:  MOV     W0,224
03D6A:  MOV     #E,W0
03D6C:  CPSGT   W1,W0
03D6E:  BRA     3D5A
.................... 			fputc((PINGREQ * 16), SIMM95); 
03D70:  MOV.B   #C0,W0L
03D72:  BTSC.B  253.1
03D74:  BRA     3D72
03D76:  MOV.B   W0L,254
03D78:  CLR.B   255
.................... 			sendLength(0); 
03D7A:  CLR     1544
03D7C:  CLR     1546
03D7E:  CALL    1578
.................... 		} 
.................... 	} 
03D82:  MOV     [--W15],W8
03D84:  MOV     [--W15],W7
03D86:  MOV     [--W15],W6
03D88:  MOV     [--W15],W5
03D8A:  RETURN  
.................... } 
....................  
.................... void pingResponse(){	 
.................... 	fprintf(DEBUG, "pingResponse: \r\n"); 
.................... 	fputc((PINGRESP * 16), SIMM95); 
.................... 	sendLength(0); 
.................... } 
....................  
.................... void mqttDisconnect(){ 
.................... 	fprintf(DEBUG, "MQTT Disconnect\r\n"); 
.................... 	fputc((DISCONNECT * 16), SIMM95); 
.................... 	sendLength(0); 
.................... 	pingFlag = false; 
.................... } 
....................  
.................... void mqttSubscribe(unsigned int1 DUP, unsigned int16 messageID, char *subtopic, unsigned int8 subQoS){ 
*
036C8:  MOV     W5,[W15++]
.................... 	fprintf(DEBUG, "MQTT SUBSCRIBE: "); 
036CA:  MOV     #0,W1
036CC:  MOV     W1,W0
036CE:  CLR.B   1
036D0:  CALL    B6A
036D4:  INC     W1,W1
036D6:  BTSC.B  223.1
036D8:  BRA     36D6
036DA:  MOV     W0,224
036DC:  MOV     #F,W0
036DE:  CPSGT   W1,W0
036E0:  BRA     36CC
.................... 	fputc((SUBSCRIBE * 16 + DUP * dupMask + 1 * QoSScale), SIMM95); 
036E2:  MOV.B   147C,W0L
036E4:  CLR.B   1
036E6:  SL      W0,#3,W0
036E8:  MOV     #80,W4
036EA:  ADD     W0,W4,W5
036EC:  ADD     W5,#2,W5
036EE:  MOV.B   W5L,W0L
036F0:  BTSC.B  253.1
036F2:  BRA     36F0
036F4:  MOV.B   W0L,254
036F6:  CLR.B   255
.................... 	int localLength = 2 + (2 + strlen(subtopic)) + 1; 
036F8:  PUSH    1480
036FA:  POP     154E
036FC:  CALL    1554
03700:  ZE      W0,W0
03702:  CLR.B   1
03704:  ADD     W0,#2,W0
03706:  ADD     W0,#2,W0
03708:  MOV     W0,W5
0370A:  ADD     W5,#1,W5
0370C:  MOV     W5,1482
.................... 	sendLength(localLength); 
0370E:  PUSH    1482
03710:  POP     1544
03712:  CLR     W4
03714:  BTSC.B  1545.7
03716:  SETM    W4
03718:  MOV     W4,1546
0371A:  CALL    1578
.................... 	fputc((messageID / 256), SIMM95); 
0371E:  MOV.B   147F,W0L
03720:  MOV.B   W0L,W5L
03722:  CLR.B   B
03724:  MOV.B   W5L,W0L
03726:  BTSC.B  253.1
03728:  BRA     3726
0372A:  MOV.B   W0L,254
0372C:  CLR.B   255
.................... 	fputc((messageID % 256), SIMM95); 
0372E:  MOV     147E,W5
03730:  AND     #FF,W5
03732:  MOV.B   W5L,W0L
03734:  BTSC.B  253.1
03736:  BRA     3734
03738:  MOV.B   W0L,254
0373A:  CLR.B   255
.................... 	fprintf(DEBUG, "messageID: %d\r\n", messageID); 
0373C:  MOV     #0,W1
0373E:  MOV     W1,W0
03740:  CLR.B   1
03742:  CALL    692
03746:  INC     W1,W1
03748:  BTSC.B  223.1
0374A:  BRA     3748
0374C:  MOV     W0,224
0374E:  MOV     #A,W0
03750:  CPSGT   W1,W0
03752:  BRA     373E
03754:  MOV     147E,W0
03756:  MOV     #0,W4
03758:  CALL    1620
0375C:  BTSC.B  223.1
0375E:  BRA     375C
03760:  MOV     #D,W4
03762:  MOV     W4,224
03764:  BTSC.B  223.1
03766:  BRA     3764
03768:  MOV     #A,W4
0376A:  MOV     W4,224
.................... 	sendUTF8String(subtopic); 
0376C:  PUSH    1480
0376E:  POP     1548
03770:  CALL    1716
.................... 	fputc(subQoS, SIMM95); 
03774:  MOV.B   147D,W0L
03776:  BTSC.B  253.1
03778:  BRA     3776
0377A:  MOV.B   W0L,254
0377C:  CLR.B   255
0377E:  MOV     [--W15],W5
03780:  RETURN  
.................... } 
....................  
.................... void mqttUnsubscribe(unsigned int1 DUP, unsigned int16 messageID, char *topic){ 
.................... 	fprintf(DEBUG, "MQTT UNSUBSCRIBE: "); 
.................... 	fputc((UNSUBSCRIBE * 16 + DUP * dupMask + 1*QoSScale), SIMM95); 
.................... 	int localLength = 2 + 2 + strlen(localLength); 
.................... 	sendLength(localLength); 
.................... 	fputc((messageID / 256), SIMM95); 
.................... 	fputc((messageID % 256), SIMM95); 
.................... 	fprintf(DEBUG, "messageID: %d\r\n", messageID); 
.................... 	sendUTF8String(topic); 
.................... } 
....................  
.................... void mqttPublish(unsigned int1 DUP, unsigned int8 QoS, unsigned int1 retain, unsigned int16 messageID, char *topic, char *message){ 
*
03888:  MOV     W5,[W15++]
.................... 	fprintf(DEBUG, "MQTT PUBLISH: "); 
0388A:  MOV     #0,W1
0388C:  MOV     W1,W0
0388E:  CLR.B   1
03890:  CALL    B88
03894:  INC     W1,W1
03896:  BTSC.B  223.1
03898:  BRA     3896
0389A:  MOV     W0,224
0389C:  MOV     #D,W0
0389E:  CPSGT   W1,W0
038A0:  BRA     388C
.................... 	fputc((PUBLISH * 16 + DUP * dupMask + QoS * QoSScale + retain), SIMM95); 
038A2:  MOV.B   147C,W0L
038A4:  CLR.B   1
038A6:  SL      W0,#3,W0
038A8:  MOV     #30,W4
038AA:  ADD     W0,W4,W5
038AC:  MOV.B   147D,W0L
038AE:  CLR.B   1
038B0:  SL      W0,#1,W0
038B2:  ADD     W0,W5,W5
038B4:  MOV     147E,W4
038B6:  CLR.B   9
038B8:  ADD     W5,W4,W5
038BA:  MOV.B   W5L,W0L
038BC:  BTSC.B  253.1
038BE:  BRA     38BC
038C0:  MOV.B   W0L,254
038C2:  CLR.B   255
.................... 	int localLength = 2 + strlen(topic); 
038C4:  PUSH    1482
038C6:  POP     154E
038C8:  CALL    1554
038CC:  ZE      W0,W0
038CE:  CLR.B   1
038D0:  ADD     W0,#2,W0
038D2:  MOV     W0,1486
.................... 	if(QoS > 0){ 
038D4:  CP0.B   147D
038D6:  BRA     Z,38DE
.................... 		localLength += 2; 
038D8:  MOV     1486,W4
038DA:  ADD     W4,#2,W4
038DC:  MOV     W4,1486
.................... 	} 
.................... 	localLength += strlen(message); 
038DE:  PUSH    1484
038E0:  POP     154E
038E2:  CALL    1554
038E6:  MOV.B   W0L,W5L
038E8:  ZE      W5,W5
038EA:  CLR.B   B
038EC:  MOV.B   W5L,W0L
038EE:  ADD     1486
.................... 	sendLength(localLength); 
038F0:  PUSH    1486
038F2:  POP     1544
038F4:  CLR     W4
038F6:  BTSC.B  1545.7
038F8:  SETM    W4
038FA:  MOV     W4,1546
038FC:  CALL    1578
.................... 	sendUTF8String(topic); 
03900:  PUSH    1482
03902:  POP     1548
03904:  CALL    1716
.................... 	if(QoS > 0){ 
03908:  CP0.B   147D
0390A:  BRA     Z,395A
.................... 		fputc(messageID / 256, SIMM95); 
0390C:  MOV.B   1481,W0L
0390E:  MOV.B   W0L,W5L
03910:  CLR.B   B
03912:  MOV.B   W5L,W0L
03914:  BTSC.B  253.1
03916:  BRA     3914
03918:  MOV.B   W0L,254
0391A:  CLR.B   255
.................... 		fputc(messageID % 256, SIMM95); 
0391C:  MOV     1480,W5
0391E:  AND     #FF,W5
03920:  MOV.B   W5L,W0L
03922:  BTSC.B  253.1
03924:  BRA     3922
03926:  MOV.B   W0L,254
03928:  CLR.B   255
.................... 		fprintf(DEBUG, "messageID: %d\r\n", messageID); 
0392A:  MOV     #0,W1
0392C:  MOV     W1,W0
0392E:  CLR.B   1
03930:  CALL    692
03934:  INC     W1,W1
03936:  BTSC.B  223.1
03938:  BRA     3936
0393A:  MOV     W0,224
0393C:  MOV     #A,W0
0393E:  CPSGT   W1,W0
03940:  BRA     392C
03942:  MOV     1480,W0
03944:  MOV     #0,W4
03946:  CALL    1620
0394A:  BTSC.B  223.1
0394C:  BRA     394A
0394E:  MOV     #D,W4
03950:  MOV     W4,224
03952:  BTSC.B  223.1
03954:  BRA     3952
03956:  MOV     #A,W4
03958:  MOV     W4,224
.................... 	} 
.................... 	fprintf(SIMM95, message); 
0395A:  MOV     1484,W1
0395C:  CP0.B   [W1]
0395E:  BRA     Z,396E
03960:  BTSC.B  253.1
03962:  BRA     3960
03964:  MOV.B   [W1+#0],W0L
03966:  MOV.B   W0L,254
03968:  CLR.B   255
0396A:  INC     W1,W1
0396C:  BRA     395C
.................... 	fprintf(DEBUG, "PubTopic: %s\r\n", topic); 
0396E:  MOV     #0,W1
03970:  MOV     W1,W0
03972:  CLR.B   1
03974:  CALL    BA4
03978:  INC     W1,W1
0397A:  BTSC.B  223.1
0397C:  BRA     397A
0397E:  MOV     W0,224
03980:  MOV     #9,W0
03982:  CPSGT   W1,W0
03984:  BRA     3970
03986:  MOV     1482,W1
03988:  CP0.B   [W1]
0398A:  BRA     Z,399A
0398C:  BTSC.B  223.1
0398E:  BRA     398C
03990:  MOV.B   [W1+#0],W0L
03992:  MOV.B   W0L,224
03994:  CLR.B   225
03996:  INC     W1,W1
03998:  BRA     3988
0399A:  BTSC.B  223.1
0399C:  BRA     399A
0399E:  MOV     #D,W4
039A0:  MOV     W4,224
039A2:  BTSC.B  223.1
039A4:  BRA     39A2
039A6:  MOV     #A,W4
039A8:  MOV     W4,224
.................... 	fprintf(DEBUG, "Message Publish: %s\r\n"message); 
039AA:  MOV     #0,W1
039AC:  MOV     W1,W0
039AE:  CLR.B   1
039B0:  CALL    BC0
039B4:  INC     W1,W1
039B6:  BTSC.B  223.1
039B8:  BRA     39B6
039BA:  MOV     W0,224
039BC:  MOV     #10,W0
039BE:  CPSGT   W1,W0
039C0:  BRA     39AC
039C2:  MOV     1484,W1
039C4:  CP0.B   [W1]
039C6:  BRA     Z,39D6
039C8:  BTSC.B  223.1
039CA:  BRA     39C8
039CC:  MOV.B   [W1+#0],W0L
039CE:  MOV.B   W0L,224
039D0:  CLR.B   225
039D2:  INC     W1,W1
039D4:  BRA     39C4
039D6:  BTSC.B  223.1
039D8:  BRA     39D6
039DA:  MOV     #D,W4
039DC:  MOV     W4,224
039DE:  BTSC.B  223.1
039E0:  BRA     39DE
039E2:  MOV     #A,W4
039E4:  MOV     W4,224
039E6:  MOV     [--W15],W5
039E8:  RETURN  
.................... } 
....................  
.................... unsigned int16 generateMessageID(){ 
.................... 	if(lassMessageID < 65535){ 
*
036AA:  MOV     1280,W4
036AC:  MOV     #FFFF,W3
036AE:  CP      W3,W4
036B0:  BRA     Z,36BE
.................... 		return ++lassMessageID; 
036B2:  INC     1280
036B4:  PUSH    1280
036B6:  POP     0
036B8:  BRA     36C6
.................... 	} 
036BA:  GOTO    36C6
.................... 	else{ 
.................... 		lassMessageID = 0; 
036BE:  CLR     1280
.................... 		return lassMessageID; 
036C0:  PUSH    1280
036C2:  POP     0
036C4:  BRA     36C6
.................... 	} 
036C6:  RETURN  
.................... } 
....................  
.................... void mqttConnect(client	*mqttClient){ 
*
017D0:  MOV     W5,[W15++]
017D2:  MOV     W6,[W15++]
.................... 	connectionAcknowledgement = NOACKNOWLEDGEMENT; 
017D4:  MOV     #FF,W4
017D6:  MOV     W4,1262
.................... 	fprintf(DEBUG, "Connect send\r\n"); 
017D8:  MOV     #0,W1
017DA:  MOV     W1,W0
017DC:  CLR.B   1
017DE:  CALL    BE2
017E2:  INC     W1,W1
017E4:  BTSC.B  223.1
017E6:  BRA     17E4
017E8:  MOV     W0,224
017EA:  MOV     #D,W0
017EC:  CPSGT   W1,W0
017EE:  BRA     17DA
.................... 	fprintf(DEBUG, "Client ID: %s\r\n", mqttClient -> mqttClientID); 
017F0:  MOV     #0,W0
017F2:  ADD     1534,W0
017F4:  MOV     W0,W5
017F6:  MOV     #0,W1
017F8:  MOV     W1,W0
017FA:  CLR.B   1
017FC:  CALL    BFE
01800:  INC     W1,W1
01802:  BTSC.B  223.1
01804:  BRA     1802
01806:  MOV     W0,224
01808:  MOV     #A,W0
0180A:  CPSGT   W1,W0
0180C:  BRA     17F8
0180E:  MOV     W5,W1
01810:  CP0.B   [W1]
01812:  BRA     Z,1822
01814:  BTSC.B  223.1
01816:  BRA     1814
01818:  MOV.B   [W1+#0],W0L
0181A:  MOV.B   W0L,224
0181C:  CLR.B   225
0181E:  INC     W1,W1
01820:  BRA     1810
01822:  BTSC.B  223.1
01824:  BRA     1822
01826:  MOV     #D,W4
01828:  MOV     W4,224
0182A:  BTSC.B  223.1
0182C:  BRA     182A
0182E:  MOV     #A,W4
01830:  MOV     W4,224
.................... 	fprintf(DEBUG, "Will Flag: 0x%2x\r\n", mqttClient -> willFlag); 
01832:  MOV     #E5,W0
01834:  ADD     1534,W0
01836:  CLR.B   W5
01838:  MOV.B   [W0],W0L
0183A:  BTSC    W0.1
0183C:  INC     W5,W5
0183E:  MOV     #0,W1
01840:  MOV     W1,W0
01842:  CLR.B   1
01844:  CALL    C1A
01848:  INC     W1,W1
0184A:  BTSC.B  223.1
0184C:  BRA     184A
0184E:  MOV     W0,224
01850:  MOV     #C,W0
01852:  CPSGT   W1,W0
01854:  BRA     1840
01856:  MOV.B   W5L,W0L
01858:  CLR.B   1
0185A:  MOV     #2702,W1
0185C:  CALL    13C8
01860:  BTSC.B  223.1
01862:  BRA     1860
01864:  MOV     #D,W4
01866:  MOV     W4,224
01868:  BTSC.B  223.1
0186A:  BRA     1868
0186C:  MOV     #A,W4
0186E:  MOV     W4,224
.................... 	fprintf(DEBUG, "UserName Flag: 0x%2x\r\n", mqttClient -> userNameFlag); 
01870:  MOV     #64,W0
01872:  ADD     1534,W0
01874:  CLR.B   W5
01876:  MOV.B   [W0],W0L
01878:  BTSC    W0.1
0187A:  INC     W5,W5
0187C:  MOV     #0,W1
0187E:  MOV     W1,W0
01880:  CLR.B   1
01882:  CALL    C3A
01886:  INC     W1,W1
01888:  BTSC.B  223.1
0188A:  BRA     1888
0188C:  MOV     W0,224
0188E:  MOV     #10,W0
01890:  CPSGT   W1,W0
01892:  BRA     187E
01894:  MOV.B   W5L,W0L
01896:  CLR.B   1
01898:  MOV     #2702,W1
0189A:  CALL    13C8
0189E:  BTSC.B  223.1
018A0:  BRA     189E
018A2:  MOV     #D,W4
018A4:  MOV     W4,224
018A6:  BTSC.B  223.1
018A8:  BRA     18A6
018AA:  MOV     #A,W4
018AC:  MOV     W4,224
.................... 	fprintf(DEBUG, "KeepAliveTimeout: %d\r\n", keepAliveTimeout); 
018AE:  MOV     #0,W1
018B0:  MOV     W1,W0
018B2:  CLR.B   1
018B4:  CALL    C5E
018B8:  INC     W1,W1
018BA:  BTSC.B  223.1
018BC:  BRA     18BA
018BE:  MOV     W0,224
018C0:  MOV     #11,W0
018C2:  CPSGT   W1,W0
018C4:  BRA     18B0
018C6:  MOV     1284,W0
018C8:  MOV     1286,W1
018CA:  MOV     #0,W4
018CC:  CALL    1440
018D0:  BTSC.B  223.1
018D2:  BRA     18D0
018D4:  MOV     #D,W4
018D6:  MOV     W4,224
018D8:  BTSC.B  223.1
018DA:  BRA     18D8
018DC:  MOV     #A,W4
018DE:  MOV     W4,224
.................... 	 
.................... 	fputc((CONNECT * 16), SIMM95); 
018E0:  MOV.B   #10,W0L
018E2:  BTSC.B  253.1
018E4:  BRA     18E2
018E6:  MOV.B   W0L,254
018E8:  CLR.B   255
.................... 	char protocolName[7] = "MQTT"; 
018EA:  MOV     #514D,W4
018EC:  MOV     W4,1536
018EE:  MOV     #5454,W4
018F0:  MOV     W4,1538
018F2:  CLR.B   153A
018F4:  MOV     #1536,W4
018F6:  MOV     W4,154E
018F8:  CALL    1554
018FC:  ZE      W0,W0
018FE:  CLR.B   1
01900:  ADD     W0,#2,W0
01902:  MOV     W0,W5
01904:  ADD     W5,#1,W5
01906:  ADD     W5,#3,W5
01908:  MOV     #0,W0
0190A:  ADD     1534,W0
0190C:  MOV     W0,W6
.................... 	int localLength = (2 + strlen(protocolName)) + 1 + 3 + (2 + strlen(mqttClient -> mqttClientID)); 
0190E:  MOV     W6,154E
01910:  CALL    1554
01914:  ZE      W0,W0
01916:  CLR.B   1
01918:  ADD     W0,#2,W0
0191A:  ADD     W0,W5,W0
0191C:  MOV     W0,153E
.................... 	if(mqttClient -> willFlag != 0){ 
0191E:  MOV     #E5,W0
01920:  ADD     1534,W0
01922:  MOV     W0,W4
01924:  CLR     W0
01926:  MOV.B   [W4],W3L
01928:  BTSC    W3.1
0192A:  INC     W0,W0
0192C:  CP0.B   W0L
0192E:  BRA     Z,195E
.................... 		localLength = localLength + (2 + strlen(mqttClient -> willTopic)  
.................... 												+ (2 + strlen(mqttClient -> willMessage))); 
01930:  MOV     #E6,W0
01932:  ADD     1534,W0
01934:  MOV.B   [W0],W5L
01936:  SE      W5,W4
01938:  MOV     W4,154E
0193A:  CALL    1554
0193E:  ZE      W0,W0
01940:  CLR.B   1
01942:  ADD     W0,#2,W0
01944:  MOV     W0,W5
01946:  MOV     #E7,W0
01948:  ADD     1534,W0
0194A:  MOV.B   [W0],W6L
0194C:  SE      W6,W4
0194E:  MOV     W4,154E
01950:  CALL    1554
01954:  ZE      W0,W0
01956:  CLR.B   1
01958:  ADD     W0,#2,W0
0195A:  ADD     W0,W5,W0
0195C:  ADD     153E
.................... 	} 
.................... 	if(mqttClient -> userNameFlag != 0){ 
0195E:  MOV     #64,W0
01960:  ADD     1534,W0
01962:  MOV     W0,W4
01964:  CLR     W0
01966:  MOV.B   [W4],W3L
01968:  BTSC    W3.1
0196A:  INC     W0,W0
0196C:  CP0.B   W0L
0196E:  BRA     Z,19AA
.................... 		localLength = localLength + (2+ strlen(mqttClient -> userName)); 
01970:  MOV     #A5,W0
01972:  ADD     1534,W0
01974:  MOV     W0,W5
01976:  MOV     W5,154E
01978:  CALL    1554
0197C:  ZE      W0,W0
0197E:  CLR.B   1
01980:  ADD     W0,#2,W0
01982:  ADD     153E
.................... 		if(mqttClient -> passwordFlag != 0){ 
01984:  MOV     #64,W0
01986:  ADD     1534,W0
01988:  MOV     W0,W4
0198A:  CLR     W0
0198C:  MOV.B   [W4],W3L
0198E:  BTSC    W3.0
01990:  INC     W0,W0
01992:  CP0.B   W0L
01994:  BRA     Z,19AA
.................... 			localLength = localLength + (2 + strlen(mqttClient -> password)); 
01996:  MOV     #65,W0
01998:  ADD     1534,W0
0199A:  MOV     W0,W5
0199C:  MOV     W5,154E
0199E:  CALL    1554
019A2:  ZE      W0,W0
019A4:  CLR.B   1
019A6:  ADD     W0,#2,W0
019A8:  ADD     153E
.................... 		} 
.................... 	} 
.................... 	 
.................... 	sendLength(localLength); 
019AA:  PUSH    153E
019AC:  POP     1544
019AE:  CLR     W4
019B0:  BTSC.B  1545.7
019B2:  SETM    W4
019B4:  MOV     W4,1546
019B6:  CALL    1578
.................... 	sendUTF8String(protocolName); 
019BA:  MOV     #1536,W4
019BC:  MOV     W4,1548
019BE:  CALL    1716
.................... 	fputc((protocolVersion), SIMM95); 
019C2:  MOV.B   1272,W0L
019C4:  BTSC.B  253.1
019C6:  BRA     19C4
019C8:  MOV.B   W0L,254
019CA:  CLR.B   255
.................... 	fputc(((mqttClient -> userNameFlag * userNameFlagMask)  
.................... 						+ (mqttClient -> passwordFlag * passwordFlagMask)  
.................... 						+ (mqttClient -> willRetain * willRetainMask)  
.................... 						+ (mqttClient -> willQoS * willQoSScale)  
.................... 						+ (mqttClient -> willFlag * willFlagMask)  
.................... 						+ (mqttClient -> cleanSession * cleanSessionMask)), SIMM95); 
019CC:  MOV     #64,W0
019CE:  ADD     1534,W0
019D0:  MOV     W0,W4
019D2:  CLR     W0
019D4:  MOV.B   [W4],W3L
019D6:  BTSC    W3.1
019D8:  INC     W0,W0
019DA:  CLR.B   1
019DC:  SL      W0,#7,W5
019DE:  MOV     #64,W0
019E0:  ADD     1534,W0
019E2:  MOV     W0,W4
019E4:  CLR     W0
019E6:  MOV.B   [W4],W3L
019E8:  BTSC    W3.0
019EA:  INC     W0,W0
019EC:  CLR.B   1
019EE:  SL      W0,#6,W0
019F0:  ADD     W0,W5,W5
019F2:  MOV     #E5,W0
019F4:  ADD     1534,W0
019F6:  MOV     W0,W4
019F8:  CLR     W0
019FA:  MOV.B   [W4],W3L
019FC:  BTSC    W3.3
019FE:  INC     W0,W0
01A00:  CLR.B   1
01A02:  SL      W0,#5,W0
01A04:  ADD     W0,W5,W5
01A06:  MOV     #E5,W0
01A08:  ADD     1534,W0
01A0A:  MOV     W0,W4
01A0C:  CLR     W0
01A0E:  MOV.B   [W4],W3L
01A10:  BTSC    W3.2
01A12:  INC     W0,W0
01A14:  CLR.B   1
01A16:  SL      W0,#3,W0
01A18:  ADD     W0,W5,W5
01A1A:  MOV     #E5,W0
01A1C:  ADD     1534,W0
01A1E:  MOV     W0,W4
01A20:  CLR     W0
01A22:  MOV.B   [W4],W3L
01A24:  BTSC    W3.1
01A26:  INC     W0,W0
01A28:  CLR.B   1
01A2A:  SL      W0,#2,W0
01A2C:  ADD     W0,W5,W5
01A2E:  MOV     #E5,W0
01A30:  ADD     1534,W0
01A32:  MOV     W0,W4
01A34:  CLR     W0
01A36:  MOV.B   [W4],W3L
01A38:  BTSC    W3.0
01A3A:  INC     W0,W0
01A3C:  CLR.B   1
01A3E:  SL      W0,#1,W0
01A40:  ADD     W0,W5,W5
01A42:  MOV.B   W5L,W0L
01A44:  BTSC.B  253.1
01A46:  BRA     1A44
01A48:  MOV.B   W0L,254
01A4A:  CLR.B   255
.................... 	fputc((keepAliveTimeout / 256), SIMM95); 
01A4C:  MOV.B   1285,W0L
01A4E:  MOV.B   W0L,W5L
01A50:  MOV.B   1286,W0L
01A52:  MOV.B   W0L,B
01A54:  MOV.B   1287,W0L
01A56:  MOV.B   W0L,W6L
01A58:  CLR.B   D
01A5A:  MOV.B   W5L,W0L
01A5C:  BTSC.B  253.1
01A5E:  BRA     1A5C
01A60:  MOV.B   W0L,254
01A62:  CLR.B   255
.................... 	fputc((keepAliveTimeout % 256), SIMM95); 
01A64:  MOV     1284,W5
01A66:  AND     #FF,W5
01A68:  CLR     W6
01A6A:  MOV.B   W5L,W0L
01A6C:  BTSC.B  253.1
01A6E:  BRA     1A6C
01A70:  MOV.B   W0L,254
01A72:  CLR.B   255
.................... 	sendUTF8String(mqttClient -> mqttClientID); 
01A74:  MOV     #0,W0
01A76:  ADD     1534,W0
01A78:  MOV     W0,W5
01A7A:  MOV     W5,1548
01A7C:  CALL    1716
.................... 	if(mqttClient -> willFlag == 1){ 
01A80:  MOV     #E5,W0
01A82:  ADD     1534,W0
01A84:  MOV     W0,W4
01A86:  CLR     W0
01A88:  MOV.B   [W4],W3L
01A8A:  BTSC    W3.1
01A8C:  INC     W0,W0
01A8E:  CP.B    W0L,#1
01A90:  BRA     NZ,1AAE
.................... 		sendUTF8String(mqttClient -> willTopic); 
01A92:  MOV     #E6,W0
01A94:  ADD     1534,W0
01A96:  MOV.B   [W0],W5L
01A98:  SE      W5,W4
01A9A:  MOV     W4,1548
01A9C:  CALL    1716
.................... 		sendUTF8String(mqttClient -> willMessage); 
01AA0:  MOV     #E7,W0
01AA2:  ADD     1534,W0
01AA4:  MOV.B   [W0],W5L
01AA6:  SE      W5,W4
01AA8:  MOV     W4,1548
01AAA:  CALL    1716
.................... 	} 
.................... 	if(mqttClient -> userNameFlag == 1){ 
01AAE:  MOV     #64,W0
01AB0:  ADD     1534,W0
01AB2:  MOV     W0,W4
01AB4:  CLR     W0
01AB6:  MOV.B   [W4],W3L
01AB8:  BTSC    W3.1
01ABA:  INC     W0,W0
01ABC:  CP.B    W0L,#1
01ABE:  BRA     NZ,1AEA
.................... 		sendUTF8String(mqttClient -> userName); 
01AC0:  MOV     #A5,W0
01AC2:  ADD     1534,W0
01AC4:  MOV     W0,W5
01AC6:  MOV     W5,1548
01AC8:  CALL    1716
.................... 		if(mqttClient -> passwordFlag == 1){ 
01ACC:  MOV     #64,W0
01ACE:  ADD     1534,W0
01AD0:  MOV     W0,W4
01AD2:  CLR     W0
01AD4:  MOV.B   [W4],W3L
01AD6:  BTSC    W3.0
01AD8:  INC     W0,W0
01ADA:  CP.B    W0L,#1
01ADC:  BRA     NZ,1AEA
.................... 			sendUTF8String(mqttClient -> password); 
01ADE:  MOV     #65,W0
01AE0:  ADD     1534,W0
01AE2:  MOV     W0,W5
01AE4:  MOV     W5,1548
01AE6:  CALL    1716
.................... 		} 
.................... 	} 
01AEA:  MOV     [--W15],W6
01AEC:  MOV     [--W15],W5
01AEE:  RETURN  
.................... } 
....................  
.................... void autoConnect(){ 
.................... 	mqttConnect(mqttClient); 
01AF0:  PUSH    110A
01AF2:  POP     1534
01AF4:  CALL    17D0
01AF8:  RETURN  
.................... } 
....................  
.................... void tcpInit(){ 
*
02EB8:  MOV     W5,[W15++]
02EBA:  MOV     W6,[W15++]
02EBC:  CLR     1478
.................... 	unsigned int16 currentTicks = 0; 
.................... 	char *commandAT; 
.................... 	char *strrep; 
.................... 	commandAT = malloc(200); 
02EBE:  MOV     #C8,W4
02EC0:  MOV     W4,14CC
02EC2:  CALL    1224
02EC6:  MOV     W0,147A
.................... 	strrep = malloc(20); 
02EC8:  MOV     #14,W4
02ECA:  MOV     W4,14CC
02ECC:  CALL    1224
02ED0:  MOV     W0,147C
.................... 	memset(commandAT, 0, sizeof(commandAT)); 
02ED2:  MOV     147A,W1
02ED4:  MOV     #0,W2
02ED6:  REPEAT  #1
02ED8:  CLR.B   [W1++]
.................... 	memset(strrep, 0, sizeof(strrep)); 
02EDA:  MOV     147C,W1
02EDC:  MOV     #0,W2
02EDE:  REPEAT  #1
02EE0:  CLR.B   [W1++]
.................... 	switch(modemStatus){ 
02EE2:  MOV     1278,W0
02EE4:  XOR     #0,W0
02EE6:  BRA     Z,2EF6
02EE8:  XOR     #1,W0
02EEA:  BRA     Z,2F82
02EEC:  XOR     #3,W0
02EEE:  BRA     Z,2FC8
02EF0:  XOR     #1,W0
02EF2:  BRA     Z,31A4
02EF4:  BRA     34E0
.................... 		case 0:{ 
.................... 			sendAT((char*)("+++"), 2000); 
02EF6:  MOV     #4,W3
02EF8:  MOV     #0,W2
02EFA:  MOV     #147E,W1
02EFC:  MOV     W3,[W15++]
02EFE:  MOV     W2,W0
02F00:  CALL    C82
02F04:  MOV     [--W15],W3
02F06:  MOV.B   W0L,[W1++]
02F08:  INC     W2,W2
02F0A:  DEC     W3,W3
02F0C:  BTSS.B  42.1
02F0E:  BRA     2EFC
02F10:  MOV     #147E,W4
02F12:  MOV     W4,14CC
02F14:  MOV     #7D0,W4
02F16:  MOV     W4,14CE
02F18:  CLR     14D0
02F1A:  CALL    2DAA
.................... 			fprintf(DEBUG, "Sending AT\r\n"); 
02F1E:  MOV     #0,W1
02F20:  MOV     W1,W0
02F22:  CLR.B   1
02F24:  CALL    C92
02F28:  INC     W1,W1
02F2A:  BTSC.B  223.1
02F2C:  BRA     2F2A
02F2E:  MOV     W0,224
02F30:  MOV     #B,W0
02F32:  CPSGT   W1,W0
02F34:  BRA     2F20
.................... 			memset(commandAT, 0, sizeof(commandAT)); 
02F36:  MOV     147A,W1
02F38:  MOV     #0,W2
02F3A:  REPEAT  #1
02F3C:  CLR.B   [W1++]
.................... 			sprintf(commandAT, "AT\r\n"); 
02F3E:  PUSH    147A
02F40:  POP     1476
02F42:  MOV     #0,W1
02F44:  MOV     W1,W0
02F46:  CLR.B   1
02F48:  CALL    CAC
02F4C:  INC     W1,W1
02F4E:  MOV     W1,[W15++]
02F50:  MOV     W0,[W15++]
02F52:  MOV     [--W15],W0
02F54:  CALL    12DE
02F58:  MOV     [--W15],W1
02F5A:  MOV     #3,W0
02F5C:  CPSGT   W1,W0
02F5E:  BRA     2F44
.................... 			if(sendAT(commandAT, 5000) == 1){ 
02F60:  PUSH    147A
02F62:  POP     14CC
02F64:  MOV     #1388,W4
02F66:  MOV     W4,14CE
02F68:  CLR     14D0
02F6A:  CALL    2DAA
02F6E:  SE      W0,W5
02F70:  CP      W5,#1
02F72:  BRA     NZ,2F7C
.................... 				modemStatus = 1; 
02F74:  MOV     #1,W4
02F76:  MOV     W4,1278
.................... 			} 
02F78:  GOTO    2F82
.................... 			else{ 
.................... 				modemStatus = 0; 
02F7C:  CLR     1278
.................... 				break; 
02F7E:  GOTO    34E0
.................... 			} 
.................... 		} 
.................... 		case 1:{ 
.................... 			sprintf(commandAT, "ATE0\r\n"); 
02F82:  PUSH    147A
02F84:  POP     1476
02F86:  MOV     #0,W1
02F88:  MOV     W1,W0
02F8A:  CLR.B   1
02F8C:  CALL    CBE
02F90:  INC     W1,W1
02F92:  MOV     W1,[W15++]
02F94:  MOV     W0,[W15++]
02F96:  MOV     [--W15],W0
02F98:  CALL    12DE
02F9C:  MOV     [--W15],W1
02F9E:  MOV     #5,W0
02FA0:  CPSGT   W1,W0
02FA2:  BRA     2F88
.................... 			if(sendAT(commandAT, 2000) == 1){ 
02FA4:  PUSH    147A
02FA6:  POP     14CC
02FA8:  MOV     #7D0,W4
02FAA:  MOV     W4,14CE
02FAC:  CLR     14D0
02FAE:  CALL    2DAA
02FB2:  SE      W0,W5
02FB4:  CP      W5,#1
02FB6:  BRA     NZ,2FC0
.................... 				modemStatus = 2; 
02FB8:  MOV     #2,W4
02FBA:  MOV     W4,1278
.................... 			} 
02FBC:  GOTO    2FC8
.................... 			else{ 
.................... 			modemStatus = 1; 
02FC0:  MOV     #1,W4
02FC2:  MOV     W4,1278
.................... 			break; 
02FC4:  GOTO    34E0
.................... 			} 
.................... 		} 
.................... 		case 2:{ 
.................... 			memset(commandAT, 0, sizeof(commandAT)); 
02FC8:  MOV     147A,W1
02FCA:  MOV     #0,W2
02FCC:  REPEAT  #1
02FCE:  CLR.B   [W1++]
.................... 			memset(strrep, 0, sizeof(strrep)); 
02FD0:  MOV     147C,W1
02FD2:  MOV     #0,W2
02FD4:  REPEAT  #1
02FD6:  CLR.B   [W1++]
.................... 			sprintf(commandAT, "AT+CREG?\r\n"); 
02FD8:  PUSH    147A
02FDA:  POP     1476
02FDC:  MOV     #0,W1
02FDE:  MOV     W1,W0
02FE0:  CLR.B   1
02FE2:  CALL    CD2
02FE6:  INC     W1,W1
02FE8:  MOV     W1,[W15++]
02FEA:  MOV     W0,[W15++]
02FEC:  MOV     [--W15],W0
02FEE:  CALL    12DE
02FF2:  MOV     [--W15],W1
02FF4:  MOV     #9,W0
02FF6:  CPSGT   W1,W0
02FF8:  BRA     2FDE
.................... 			sprintf(strrep, "+CREG: 0,1"); 
02FFA:  PUSH    147C
02FFC:  POP     1476
02FFE:  MOV     #0,W1
03000:  MOV     W1,W0
03002:  CLR.B   1
03004:  CALL    CEA
03008:  INC     W1,W1
0300A:  MOV     W1,[W15++]
0300C:  MOV     W0,[W15++]
0300E:  MOV     [--W15],W0
03010:  CALL    12DE
03014:  MOV     [--W15],W1
03016:  MOV     #9,W0
03018:  CPSGT   W1,W0
0301A:  BRA     3000
.................... 			if(sendATResponse(commandAT, strrep, 8000) == 1){ 
0301C:  PUSH    147A
0301E:  POP     14CC
03020:  PUSH    147C
03022:  POP     14CE
03024:  MOV     #1F40,W4
03026:  MOV     W4,14D0
03028:  CLR     14D2
0302A:  CALL    2E20
0302E:  SE      W0,W5
03030:  CP      W5,#1
03032:  BRA     NZ,319C
.................... 				sendAT((char*)("AT+QIFGCNT=0\r\n"), 1000); 
03034:  MOV     #F,W3
03036:  MOV     #0,W2
03038:  MOV     #1482,W1
0303A:  MOV     W3,[W15++]
0303C:  MOV     W2,W0
0303E:  CALL    D02
03042:  MOV     [--W15],W3
03044:  MOV.B   W0L,[W1++]
03046:  INC     W2,W2
03048:  DEC     W3,W3
0304A:  BTSS.B  42.1
0304C:  BRA     303A
0304E:  MOV     #1482,W4
03050:  MOV     W4,14CC
03052:  MOV     #3E8,W4
03054:  MOV     W4,14CE
03056:  CLR     14D0
03058:  CALL    2DAA
.................... 				sendAT((char*)("AT+QIDNSIP=0\r\n"), 1000); 
0305C:  MOV     #F,W3
0305E:  MOV     #0,W2
03060:  MOV     #1482,W1
03062:  MOV     W3,[W15++]
03064:  MOV     W2,W0
03066:  CALL    D1E
0306A:  MOV     [--W15],W3
0306C:  MOV.B   W0L,[W1++]
0306E:  INC     W2,W2
03070:  DEC     W3,W3
03072:  BTSS.B  42.1
03074:  BRA     3062
03076:  MOV     #1482,W4
03078:  MOV     W4,14CC
0307A:  MOV     #3E8,W4
0307C:  MOV     W4,14CE
0307E:  CLR     14D0
03080:  CALL    2DAA
.................... 				sendAT((char*)("AT+QINDI=1\r\n"), 1000); 
03084:  MOV     #D,W3
03086:  MOV     #0,W2
03088:  MOV     #1482,W1
0308A:  MOV     W3,[W15++]
0308C:  MOV     W2,W0
0308E:  CALL    D3A
03092:  MOV     [--W15],W3
03094:  MOV.B   W0L,[W1++]
03096:  INC     W2,W2
03098:  DEC     W3,W3
0309A:  BTSS.B  42.1
0309C:  BRA     308A
0309E:  MOV     #1482,W4
030A0:  MOV     W4,14CC
030A2:  MOV     #3E8,W4
030A4:  MOV     W4,14CE
030A6:  CLR     14D0
030A8:  CALL    2DAA
.................... 				sendAT((char*)("AT+QIMUX=0\r\n"), 1000); 
030AC:  MOV     #D,W3
030AE:  MOV     #0,W2
030B0:  MOV     #1482,W1
030B2:  MOV     W3,[W15++]
030B4:  MOV     W2,W0
030B6:  CALL    D54
030BA:  MOV     [--W15],W3
030BC:  MOV.B   W0L,[W1++]
030BE:  INC     W2,W2
030C0:  DEC     W3,W3
030C2:  BTSS.B  42.1
030C4:  BRA     30B2
030C6:  MOV     #1482,W4
030C8:  MOV     W4,14CC
030CA:  MOV     #3E8,W4
030CC:  MOV     W4,14CE
030CE:  CLR     14D0
030D0:  CALL    2DAA
.................... 				sendAT((char*)("AT+QIMODE=1\r\n"), 1000); 
030D4:  MOV     #E,W3
030D6:  MOV     #0,W2
030D8:  MOV     #1482,W1
030DA:  MOV     W3,[W15++]
030DC:  MOV     W2,W0
030DE:  CALL    D6E
030E2:  MOV     [--W15],W3
030E4:  MOV.B   W0L,[W1++]
030E6:  INC     W2,W2
030E8:  DEC     W3,W3
030EA:  BTSS.B  42.1
030EC:  BRA     30DA
030EE:  MOV     #1482,W4
030F0:  MOV     W4,14CC
030F2:  MOV     #3E8,W4
030F4:  MOV     W4,14CE
030F6:  CLR     14D0
030F8:  CALL    2DAA
.................... 				memset(commandAT, 0, sizeof(commandAT)); 
030FC:  MOV     147A,W1
030FE:  MOV     #0,W2
03100:  REPEAT  #1
03102:  CLR.B   [W1++]
.................... 				memset(strrep, 0, sizeof(strrep)); 
03104:  MOV     147C,W1
03106:  MOV     #0,W2
03108:  REPEAT  #1
0310A:  CLR.B   [W1++]
.................... 				sprintf(commandAT, "AT+CGATT?\r\n"); 
0310C:  PUSH    147A
0310E:  POP     1476
03110:  MOV     #0,W1
03112:  MOV     W1,W0
03114:  CLR.B   1
03116:  CALL    D88
0311A:  INC     W1,W1
0311C:  MOV     W1,[W15++]
0311E:  MOV     W0,[W15++]
03120:  MOV     [--W15],W0
03122:  CALL    12DE
03126:  MOV     [--W15],W1
03128:  MOV     #A,W0
0312A:  CPSGT   W1,W0
0312C:  BRA     3112
.................... 				sprintf(strrep, "+CGATT: 1"); 
0312E:  PUSH    147C
03130:  POP     1476
03132:  MOV     #0,W1
03134:  MOV     W1,W0
03136:  CLR.B   1
03138:  CALL    DA0
0313C:  INC     W1,W1
0313E:  MOV     W1,[W15++]
03140:  MOV     W0,[W15++]
03142:  MOV     [--W15],W0
03144:  CALL    12DE
03148:  MOV     [--W15],W1
0314A:  MOV     #8,W0
0314C:  CPSGT   W1,W0
0314E:  BRA     3134
.................... 				if(sendATResponse(commandAT, strrep, 4000) != 1){ 
03150:  PUSH    147A
03152:  POP     14CC
03154:  PUSH    147C
03156:  POP     14CE
03158:  MOV     #FA0,W4
0315A:  MOV     W4,14D0
0315C:  CLR     14D2
0315E:  CALL    2E20
03162:  SE      W0,W5
03164:  CP      W5,#1
03166:  BRA     Z,3190
.................... 					sendAT((char*)("AT+CGATT=1\r\n"), 2000); 
03168:  MOV     #D,W3
0316A:  MOV     #0,W2
0316C:  MOV     #1482,W1
0316E:  MOV     W3,[W15++]
03170:  MOV     W2,W0
03172:  CALL    DB6
03176:  MOV     [--W15],W3
03178:  MOV.B   W0L,[W1++]
0317A:  INC     W2,W2
0317C:  DEC     W3,W3
0317E:  BTSS.B  42.1
03180:  BRA     316E
03182:  MOV     #1482,W4
03184:  MOV     W4,14CC
03186:  MOV     #7D0,W4
03188:  MOV     W4,14CE
0318A:  CLR     14D0
0318C:  CALL    2DAA
.................... 				} 
.................... 				modemStatus = 3; 
03190:  MOV     #3,W4
03192:  MOV     W4,1278
.................... 				tcpStatus = 2; 
03194:  MOV     #2,W4
03196:  MOV     W4,127A
.................... 			} 
03198:  GOTO    31A4
.................... 			else{ 
.................... 				modemStatus = 2; 
0319C:  MOV     #2,W4
0319E:  MOV     W4,1278
.................... 				break; 
031A0:  GOTO    34E0
.................... 			} 
.................... 		} 
.................... 		case 3:{ 
.................... 			if(gsmResponseFlag != 7){ 
031A4:  MOV     1276,W4
031A6:  CP      W4,#7
031A8:  BRA     Z,3232
.................... 				memset(commandAT, 0, sizeof(commandAT)); 
031AA:  MOV     147A,W1
031AC:  MOV     #0,W2
031AE:  REPEAT  #1
031B0:  CLR.B   [W1++]
.................... 				memset(strrep, 0, sizeof(strrep)); 
031B2:  MOV     147C,W1
031B4:  MOV     #0,W2
031B6:  REPEAT  #1
031B8:  CLR.B   [W1++]
.................... 				sprintf(commandAT, "AT+QISTAT\r\n"); 
031BA:  PUSH    147A
031BC:  POP     1476
031BE:  MOV     #0,W1
031C0:  MOV     W1,W0
031C2:  CLR.B   1
031C4:  CALL    DD0
031C8:  INC     W1,W1
031CA:  MOV     W1,[W15++]
031CC:  MOV     W0,[W15++]
031CE:  MOV     [--W15],W0
031D0:  CALL    12DE
031D4:  MOV     [--W15],W1
031D6:  MOV     #A,W0
031D8:  CPSGT   W1,W0
031DA:  BRA     31C0
.................... 				sprintf(strrep, "STATE:"); 
031DC:  PUSH    147C
031DE:  POP     1476
031E0:  MOV     #0,W1
031E2:  MOV     W1,W0
031E4:  CLR.B   1
031E6:  CALL    DE8
031EA:  INC     W1,W1
031EC:  MOV     W1,[W15++]
031EE:  MOV     W0,[W15++]
031F0:  MOV     [--W15],W0
031F2:  CALL    12DE
031F6:  MOV     [--W15],W1
031F8:  MOV     #5,W0
031FA:  CPSGT   W1,W0
031FC:  BRA     31E2
.................... 				tcpStatus = sendATResponse(commandAT, strrep, 4000); 
031FE:  PUSH    147A
03200:  POP     14CC
03202:  PUSH    147C
03204:  POP     14CE
03206:  MOV     #FA0,W4
03208:  MOV     W4,14D0
0320A:  CLR     14D2
0320C:  CALL    2E20
03210:  SE      W0,W0
03212:  MOV     W0,127A
.................... 				if(tcpStatusPrev == tcpStatus){ 
03214:  MOV     127C,W0
03216:  CP      127A
03218:  BRA     NZ,322C
.................... 					tcpATErrorCount++; 
0321A:  INC     1282
.................... 					if(tcpATErrorCount >= 10){ 
0321C:  MOV     1282,W4
0321E:  CP      W4,#A
03220:  BRA     NC,3228
.................... 						tcpATErrorCount = 0; 
03222:  CLR     1282
.................... 						tcpStatus = 7; 
03224:  MOV     #7,W4
03226:  MOV     W4,127A
.................... 					} 
.................... 				} 
03228:  GOTO    3232
.................... 				else{ 
.................... 					tcpStatusPrev = tcpStatus; 
0322C:  PUSH    127A
0322E:  POP     127C
.................... 					tcpATErrorCount = 0; 
03230:  CLR     1282
.................... 				} 
.................... 			} 
.................... 			tcpStatusPrev = tcpStatus; 
03232:  PUSH    127A
03234:  POP     127C
.................... 			fprintf(DEBUG, "%d\r\n", tcpStatus); 
03236:  MOV     127A,W0
03238:  MOV     #0,W4
0323A:  CALL    1620
0323E:  BTSC.B  223.1
03240:  BRA     323E
03242:  MOV     #D,W4
03244:  MOV     W4,224
03246:  BTSC.B  223.1
03248:  BRA     3246
0324A:  MOV     #A,W4
0324C:  MOV     W4,224
.................... 			switch(tcpStatus){ 
0324E:  MOV     127A,W0
03250:  XOR     #2,W0
03252:  BRA     Z,326A
03254:  XOR     #1,W0
03256:  BRA     Z,3296
03258:  XOR     #7,W0
0325A:  BRA     Z,32C2
0325C:  XOR     #1,W0
0325E:  BRA     Z,3314
03260:  XOR     #3,W0
03262:  BRA     Z,343E
03264:  XOR     #1,W0
03266:  BRA     Z,3482
03268:  BRA     34E0
.................... 				case 2:{ 
.................... 					sendAT((char*)("AT+QIREGAPP=\"CMNET\"\r\n"), 5000); 
0326A:  MOV     #16,W3
0326C:  MOV     #0,W2
0326E:  MOV     #1492,W1
03270:  MOV     W3,[W15++]
03272:  MOV     W2,W0
03274:  CALL    DFC
03278:  MOV     [--W15],W3
0327A:  MOV.B   W0L,[W1++]
0327C:  INC     W2,W2
0327E:  DEC     W3,W3
03280:  BTSS.B  42.1
03282:  BRA     3270
03284:  MOV     #1492,W4
03286:  MOV     W4,14CC
03288:  MOV     #1388,W4
0328A:  MOV     W4,14CE
0328C:  CLR     14D0
0328E:  CALL    2DAA
.................... 					break; 
03292:  GOTO    34E0
.................... 				} 
.................... 				case 3:{ 
.................... 					sendAT((char*)("AT+QIACT\r\n"), 5000); 
03296:  MOV     #B,W3
03298:  MOV     #0,W2
0329A:  MOV     #14A8,W1
0329C:  MOV     W3,[W15++]
0329E:  MOV     W2,W0
032A0:  CALL    E1E
032A4:  MOV     [--W15],W3
032A6:  MOV.B   W0L,[W1++]
032A8:  INC     W2,W2
032AA:  DEC     W3,W3
032AC:  BTSS.B  42.1
032AE:  BRA     329C
032B0:  MOV     #14A8,W4
032B2:  MOV     W4,14CC
032B4:  MOV     #1388,W4
032B6:  MOV     W4,14CE
032B8:  CLR     14D0
032BA:  CALL    2DAA
.................... 					break; 
032BE:  GOTO    34E0
.................... 				} 
.................... 				case 4:{ 
.................... 					memset(commandAT, 0, sizeof(commandAT)); 
032C2:  MOV     147A,W1
032C4:  MOV     #0,W2
032C6:  REPEAT  #1
032C8:  CLR.B   [W1++]
.................... 					memset(strrep, 0, sizeof(strrep)); 
032CA:  MOV     147C,W1
032CC:  MOV     #0,W2
032CE:  REPEAT  #1
032D0:  CLR.B   [W1++]
.................... 					sprintf(commandAT, "AT+QILOCIP\r\n"); 
032D2:  PUSH    147A
032D4:  POP     1476
032D6:  MOV     #0,W1
032D8:  MOV     W1,W0
032DA:  CLR.B   1
032DC:  CALL    E36
032E0:  INC     W1,W1
032E2:  MOV     W1,[W15++]
032E4:  MOV     W0,[W15++]
032E6:  MOV     [--W15],W0
032E8:  CALL    12DE
032EC:  MOV     [--W15],W1
032EE:  MOV     #B,W0
032F0:  CPSGT   W1,W0
032F2:  BRA     32D8
.................... 					sprintf(strrep, "."); 
032F4:  PUSH    147C
032F6:  POP     1476
032F8:  MOV.B   #2E,W0L
032FA:  CALL    12DE
.................... 					sendATResponse(commandAT, strrep, 5000); 
032FE:  PUSH    147A
03300:  POP     14CC
03302:  PUSH    147C
03304:  POP     14CE
03306:  MOV     #1388,W4
03308:  MOV     W4,14D0
0330A:  CLR     14D2
0330C:  CALL    2E20
.................... 					break; 
03310:  GOTO    34E0
.................... 				} 
.................... 				case 5:{ 
.................... //					sendAT((char*)("AT + QIDNSIP = 1\r\n"), 2000); 
.................... 					memset(mqttHost, 0, sizeof(mqttHost)); 
03314:  MOV     125A,W1
03316:  MOV     #0,W2
03318:  REPEAT  #1
0331A:  CLR.B   [W1++]
.................... 					memset(mqttPort, 0, sizeof(mqttPort)); 
0331C:  MOV     125C,W1
0331E:  MOV     #0,W2
03320:  REPEAT  #1
03322:  CLR.B   [W1++]
.................... 					sprintf(mqttHost, "103.249.100.48"); 
03324:  PUSH    125A
03326:  POP     1476
03328:  MOV     #0,W1
0332A:  MOV     W1,W0
0332C:  CLR.B   1
0332E:  CALL    E50
03332:  INC     W1,W1
03334:  MOV     W1,[W15++]
03336:  MOV     W0,[W15++]
03338:  MOV     [--W15],W0
0333A:  CALL    12DE
0333E:  MOV     [--W15],W1
03340:  MOV     #D,W0
03342:  CPSGT   W1,W0
03344:  BRA     332A
.................... 					sprintf(mqttPort, "1883"); 
03346:  PUSH    125C
03348:  POP     1476
0334A:  MOV     #0,W1
0334C:  MOV     W1,W0
0334E:  CLR.B   1
03350:  CALL    E6C
03354:  INC     W1,W1
03356:  MOV     W1,[W15++]
03358:  MOV     W0,[W15++]
0335A:  MOV     [--W15],W0
0335C:  CALL    12DE
03360:  MOV     [--W15],W1
03362:  MOV     #3,W0
03364:  CPSGT   W1,W0
03366:  BRA     334C
.................... 					memset(commandAT, 0, sizeof(commandAT)); 
03368:  MOV     147A,W1
0336A:  MOV     #0,W2
0336C:  REPEAT  #1
0336E:  CLR.B   [W1++]
.................... 					sprintf(commandAT, "AT+QIOPEN=\"TCP\",\"%s\",\"%s\"\r\n", mqttHost, mqttPort); 
03370:  PUSH    147A
03372:  POP     1476
03374:  MOV     #0,W1
03376:  MOV     W1,W0
03378:  CLR.B   1
0337A:  CALL    E7E
0337E:  INC     W1,W1
03380:  MOV     W1,[W15++]
03382:  MOV     W0,[W15++]
03384:  MOV     [--W15],W0
03386:  CALL    12DE
0338A:  MOV     [--W15],W1
0338C:  MOV     #10,W0
0338E:  CPSGT   W1,W0
03390:  BRA     3376
03392:  MOV     125A,W1
03394:  CP0.B   [W1]
03396:  BRA     Z,33A8
03398:  MOV     W1,[W15++]
0339A:  MOV     W1,W4
0339C:  MOV.B   [W4],W0L
0339E:  CALL    12DE
033A2:  MOV     [--W15],W1
033A4:  INC     W1,W1
033A6:  BRA     3394
033A8:  MOV.B   #22,W0L
033AA:  CALL    12DE
033AE:  MOV.B   #2C,W0L
033B0:  CALL    12DE
033B4:  MOV.B   #22,W0L
033B6:  CALL    12DE
033BA:  MOV     125C,W1
033BC:  CP0.B   [W1]
033BE:  BRA     Z,33D0
033C0:  MOV     W1,[W15++]
033C2:  MOV     W1,W4
033C4:  MOV.B   [W4],W0L
033C6:  CALL    12DE
033CA:  MOV     [--W15],W1
033CC:  INC     W1,W1
033CE:  BRA     33BC
033D0:  MOV.B   #22,W0L
033D2:  CALL    12DE
033D6:  MOV.B   #D,W0L
033D8:  CALL    12DE
033DC:  MOV.B   #A,W0L
033DE:  CALL    12DE
.................... 					if(sendAT(commandAT, 2000) == 1){ 
033E2:  PUSH    147A
033E4:  POP     14CC
033E6:  MOV     #7D0,W4
033E8:  MOV     W4,14CE
033EA:  CLR     14D0
033EC:  CALL    2DAA
033F0:  SE      W0,W5
033F2:  CP      W5,#1
033F4:  BRA     NZ,343A
.................... 						memset(reply, 0, sizeof(reply)); 
033F6:  MOV     1296,W1
033F8:  MOV     #0,W2
033FA:  REPEAT  #1
033FC:  CLR.B   [W1++]
.................... 						strcpy(reply, "none"); 
033FE:  MOV     #0,W2
03400:  MOV     1296,W1
03402:  MOV     W2,W0
03404:  CALL    EA6
03408:  MOV.B   W0L,[W1++]
0340A:  INC     W2,W2
0340C:  CP0.B   W0L
0340E:  BTSS.B  42.1
03410:  BRA     3402
.................... 						set_ticks(T1, 0); 
03412:  CLR     14DE
03414:  CALL    132C
.................... 						currentTicks = get_ticks(T1); 
03418:  CALL    1342
0341C:  MOV     W0,1478
.................... 						while((gsmResponse != 4) && (currentTicks < 10000)){ 
0341E:  MOV     1274,W4
03420:  CP      W4,#4
03422:  BRA     Z,343A
03424:  MOV     1478,W4
03426:  MOV     #2710,W3
03428:  CP      W3,W4
0342A:  BRA     LEU,343A
.................... 							serialEvent(); 
0342C:  CALL    1E5A
.................... 							currentTicks = get_ticks(T1); 
03430:  CALL    1342
03434:  MOV     W0,1478
03436:  GOTO    341E
.................... 						} 
.................... 					} 
.................... 					break; 
0343A:  GOTO    34E0
.................... 				} 
.................... 				case 6:{ 
.................... 					fprintf(DEBUG, "Waiting reconnect...\r\n"); 
0343E:  MOV     #0,W1
03440:  MOV     W1,W0
03442:  CLR.B   1
03444:  CALL    EB8
03448:  INC     W1,W1
0344A:  BTSC.B  223.1
0344C:  BRA     344A
0344E:  MOV     W0,224
03450:  MOV     #15,W0
03452:  CPSGT   W1,W0
03454:  BRA     3440
.................... 					set_ticks(T1, 0); 
03456:  CLR     14DE
03458:  CALL    132C
.................... 					currentTicks = get_ticks(T1); 
0345C:  CALL    1342
03460:  MOV     W0,1478
.................... 					while((gsmResponse != 4) && (currentTicks < 10000)){ 
03462:  MOV     1274,W4
03464:  CP      W4,#4
03466:  BRA     Z,347E
03468:  MOV     1478,W4
0346A:  MOV     #2710,W3
0346C:  CP      W3,W4
0346E:  BRA     LEU,347E
.................... 						serialEvent(); 
03470:  CALL    1E5A
.................... 						currentTicks = get_ticks(T1); 
03474:  CALL    1342
03478:  MOV     W0,1478
0347A:  GOTO    3462
.................... 					} 
.................... 					break; 
0347E:  GOTO    34E0
.................... 				} 
.................... 				case 7:{ 
.................... 					memset(commandAT, 0 sizeof(commandAT)); 
03482:  MOV     147A,W1
03484:  MOV     #0,W2
03486:  REPEAT  #1
03488:  CLR.B   [W1++]
.................... 					memset(strrep, 0, sizeof(strrep)); 
0348A:  MOV     147C,W1
0348C:  MOV     #0,W2
0348E:  REPEAT  #1
03490:  CLR.B   [W1++]
.................... 					sprintf(commandAT, "AT+QIDEACT\r\n"); 
03492:  PUSH    147A
03494:  POP     1476
03496:  MOV     #0,W1
03498:  MOV     W1,W0
0349A:  CLR.B   1
0349C:  CALL    EDC
034A0:  INC     W1,W1
034A2:  MOV     W1,[W15++]
034A4:  MOV     W0,[W15++]
034A6:  MOV     [--W15],W0
034A8:  CALL    12DE
034AC:  MOV     [--W15],W1
034AE:  MOV     #B,W0
034B0:  CPSGT   W1,W0
034B2:  BRA     3498
.................... 					sprintf(strrep, "OK"); 
034B4:  PUSH    147C
034B6:  POP     1476
034B8:  MOV.B   #4F,W0L
034BA:  CALL    12DE
034BE:  MOV.B   #4B,W0L
034C0:  CALL    12DE
.................... 					sendATResponse(commandAT, strrep, 4000); 
034C4:  PUSH    147A
034C6:  POP     14CC
034C8:  PUSH    147C
034CA:  POP     14CE
034CC:  MOV     #FA0,W4
034CE:  MOV     W4,14D0
034D0:  CLR     14D2
034D2:  CALL    2E20
.................... 					modemStatus = 0; 
034D6:  CLR     1278
.................... 					tcpStatus = 2; 
034D8:  MOV     #2,W4
034DA:  MOV     W4,127A
.................... 					break; 
034DC:  GOTO    34E0
.................... 				} 
.................... 			} 
.................... 		} 
.................... 	} 
034E0:  MOV     [--W15],W6
034E2:  MOV     [--W15],W5
034E4:  RETURN  
.................... } 
....................  
.................... void begin(){ 
.................... //	sendAT((char*)("AT+QIDEACT\r\n"), 2000); 
.................... //	delay_ms(4000); 
.................... 	tcpInit(); 
034E6:  CALL    2EB8
034EA:  RETURN  
.................... } 
....................  
.................... void mqttProcessing(){ 
*
03D8C:  MOV     W5,[W15++]
.................... 	if(tcpFlag == false){ 
03D8E:  BTSC.B  1109.1
03D90:  BRA     3D9E
.................... 		tcpFlag = false; 
03D92:  BCLR.B  1109.1
.................... 		tcpInit(); 
03D94:  CALL    2EB8
.................... 		return; 
03D98:  BRA     3DA6
.................... 	} 
03D9A:  GOTO    3DA2
.................... 	else{ 
.................... 		serialEvent(); 
03D9E:  CALL    1E5A
.................... 	} 
.................... 	pingRequest(); 
03DA2:  CALL    3D02
03DA6:  MOV     [--W15],W5
03DA8:  RETURN  
.................... } 
....................  
.................... void messageProcessing(){ 
*
0352A:  MOV     W5,[W15++]
.................... 	if(messageFlag){ 
0352C:  BTSS.B  1109.6
0352E:  BRA     369C
.................... 		char *c_topic, *c_message, *c_msg; 
.................... 		c_topic = malloc(200); 
03530:  MOV     #C8,W4
03532:  MOV     W4,14CC
03534:  CALL    1224
03538:  MOV     W0,1478
.................... 		c_msg = malloc(200); 
0353A:  MOV     #C8,W4
0353C:  MOV     W4,14CC
0353E:  CALL    1224
03542:  MOV     W0,147C
.................... 		memset(c_topic, 0, sizeof(c_topic)); 
03544:  MOV     1478,W1
03546:  MOV     #0,W2
03548:  REPEAT  #1
0354A:  CLR.B   [W1++]
.................... 		memset(c_msg, 0, sizeof(c_msg)); 
0354C:  MOV     147C,W1
0354E:  MOV     #0,W2
03550:  REPEAT  #1
03552:  CLR.B   [W1++]
.................... 		if(t_topic > 200 || t_message > 200){ 
.................... 			messageFlag = false; 
.................... 			return; 
.................... 		} 
.................... 		else{ 
.................... 			sprintf(c_topic, "%s", mqttClient -> mqttClientID); 
03554:  MOV     #0,W0
03556:  ADD     110A,W0
03558:  MOV     W0,W5
0355A:  PUSH    1478
0355C:  POP     1476
0355E:  MOV     W5,W1
03560:  CP0.B   [W1]
03562:  BRA     Z,3574
03564:  MOV     W1,[W15++]
03566:  MOV     W1,W4
03568:  MOV.B   [W4],W0L
0356A:  CALL    12DE
0356E:  MOV     [--W15],W1
03570:  INC     W1,W1
03572:  BRA     3560
.................... 			if(!strcmp(c_topic, t_topic)){ 
03574:  PUSH    1478
03576:  POP     1486
03578:  MOV     #1298,W4
0357A:  MOV     W4,1488
0357C:  CALL    34EC
03580:  CP0.B   W0L
03582:  BRA     NZ,3694
.................... 				fprintf(DEBUG, "received topic: %s\r\n", t_topic); 
03584:  MOV     #0,W1
03586:  MOV     W1,W0
03588:  CLR.B   1
0358A:  CALL    EF6
0358E:  INC     W1,W1
03590:  BTSC.B  223.1
03592:  BRA     3590
03594:  MOV     W0,224
03596:  MOV     #F,W0
03598:  CPSGT   W1,W0
0359A:  BRA     3586
0359C:  MOV     #1298,W1
0359E:  CP0.B   [W1]
035A0:  BRA     Z,35B0
035A2:  BTSC.B  223.1
035A4:  BRA     35A2
035A6:  MOV.B   [W1+#0],W0L
035A8:  MOV.B   W0L,224
035AA:  CLR.B   225
035AC:  INC     W1,W1
035AE:  BRA     359E
035B0:  BTSC.B  223.1
035B2:  BRA     35B0
035B4:  MOV     #D,W4
035B6:  MOV     W4,224
035B8:  BTSC.B  223.1
035BA:  BRA     35B8
035BC:  MOV     #A,W4
035BE:  MOV     W4,224
.................... 				if(!strcmp((char*)("ON"), t_message)){ 
035C0:  MOV     #3,W3
035C2:  MOV     #0,W2
035C4:  MOV     #147E,W1
035C6:  MOV     W3,[W15++]
035C8:  MOV     W2,W0
035CA:  CALL    F18
035CE:  MOV     [--W15],W3
035D0:  MOV.B   W0L,[W1++]
035D2:  INC     W2,W2
035D4:  DEC     W3,W3
035D6:  BTSS.B  42.1
035D8:  BRA     35C6
035DA:  MOV     #147E,W4
035DC:  MOV     W4,1486
035DE:  MOV     #12FC,W4
035E0:  MOV     W4,1488
035E2:  CALL    34EC
035E6:  CP0.B   W0L
035E8:  BRA     NZ,362A
.................... 					fprintf(DEBUG, "Lamp Status1: %s\r\n", t_message); 
035EA:  MOV     #0,W1
035EC:  MOV     W1,W0
035EE:  CLR.B   1
035F0:  CALL    F28
035F4:  INC     W1,W1
035F6:  BTSC.B  223.1
035F8:  BRA     35F6
035FA:  MOV     W0,224
035FC:  MOV     #D,W0
035FE:  CPSGT   W1,W0
03600:  BRA     35EC
03602:  MOV     #12FC,W1
03604:  CP0.B   [W1]
03606:  BRA     Z,3616
03608:  BTSC.B  223.1
0360A:  BRA     3608
0360C:  MOV.B   [W1+#0],W0L
0360E:  MOV.B   W0L,224
03610:  CLR.B   225
03612:  INC     W1,W1
03614:  BRA     3604
03616:  BTSC.B  223.1
03618:  BRA     3616
0361A:  MOV     #D,W4
0361C:  MOV     W4,224
0361E:  BTSC.B  223.1
03620:  BRA     361E
03622:  MOV     #A,W4
03624:  MOV     W4,224
.................... 				} 
03626:  GOTO    3690
.................... 				else if(!strcmp((char*)("OFF"), t_message)){ 
0362A:  MOV     #4,W3
0362C:  MOV     #0,W2
0362E:  MOV     #147E,W1
03630:  MOV     W3,[W15++]
03632:  MOV     W2,W0
03634:  CALL    F48
03638:  MOV     [--W15],W3
0363A:  MOV.B   W0L,[W1++]
0363C:  INC     W2,W2
0363E:  DEC     W3,W3
03640:  BTSS.B  42.1
03642:  BRA     3630
03644:  MOV     #147E,W4
03646:  MOV     W4,1486
03648:  MOV     #12FC,W4
0364A:  MOV     W4,1488
0364C:  CALL    34EC
03650:  CP0.B   W0L
03652:  BRA     NZ,3690
.................... 					fprintf(DEBUG, "Lamp Status2: %s\r\n", t_message); 
03654:  MOV     #0,W1
03656:  MOV     W1,W0
03658:  CLR.B   1
0365A:  CALL    F58
0365E:  INC     W1,W1
03660:  BTSC.B  223.1
03662:  BRA     3660
03664:  MOV     W0,224
03666:  MOV     #D,W0
03668:  CPSGT   W1,W0
0366A:  BRA     3656
0366C:  MOV     #12FC,W1
0366E:  CP0.B   [W1]
03670:  BRA     Z,3680
03672:  BTSC.B  223.1
03674:  BRA     3672
03676:  MOV.B   [W1+#0],W0L
03678:  MOV.B   W0L,224
0367A:  CLR.B   225
0367C:  INC     W1,W1
0367E:  BRA     366E
03680:  BTSC.B  223.1
03682:  BRA     3680
03684:  MOV     #D,W4
03686:  MOV     W4,224
03688:  BTSC.B  223.1
0368A:  BRA     3688
0368C:  MOV     #A,W4
0368E:  MOV     W4,224
.................... 				} 
.................... 				messageFlag = false; 
03690:  BCLR.B  1109.6
.................... 				return; 
03692:  BRA     369E
.................... 			} 
.................... 			memset(c_topic, 0, sizeof(c_topic)); 
03694:  MOV     1478,W1
03696:  MOV     #0,W2
03698:  REPEAT  #1
0369A:  CLR.B   [W1++]
.................... 		} 
.................... 	} 
.................... 	messageFlag = false; 
0369C:  BCLR.B  1109.6
0369E:  MOV     [--W15],W5
036A0:  RETURN  
.................... } 
....................  
.................... bool mqttAvailable(){ 
.................... 	return mqttFlag; 
036A2:  CLR     W0
036A4:  BTSC.B  1264.0
036A6:  INC     W0,W0
036A8:  RETURN  
.................... } 
....................  
.................... void modbusEnableTimeout(int1 enable){ 
.................... 	modbusTimeoutEnabled = enable; 
*
010D8:  BCLR.B  1264.3
010DA:  BTSC.B  15E2.0
010DC:  BSET.B  1264.3
.................... 	set_ticks(T3, 0); 
010DE:  CLR     15E6
010E0:  CALL    10C2
010E4:  RETURN  
.................... } 
....................  
.................... void modbusTimeoutNow(){ 
.................... 	if((modbusSerialState == MODBUS_GETDATA) && (modbusSerialCrc.d == 0x0000) && (!modbusSerialNew)){ 
*
03A1E:  MOV     1264,W4
03A20:  LSR     W4,#8,W4
03A22:  CP.B    W4L,#2
03A24:  BRA     NZ,3A3C
03A26:  CP0     1440
03A28:  BRA     NZ,3A3C
03A2A:  BTSC.B  1264.4
03A2C:  BRA     3A3C
.................... 		modbusRx.len -= 2; 
03A2E:  MOV     13FC,W4
03A30:  LSR     W4,#8,W4
03A32:  SUB.B   W4L,#2,W0L
03A34:  MOV.B   W0L,13FD
.................... 		modbusSerialNew = true; 
03A36:  BSET.B  1264.4
.................... //		modbusSerialState = MODBUS_GETADDY; 
.................... 	} 
03A38:  GOTO    3A3E
.................... 	else{ 
.................... 		modbusSerialNew = false; 
03A3C:  BCLR.B  1264.4
.................... 	} 
.................... 	modbusSerialCrc.d = 0xffff; 
03A3E:  SETM    1440
.................... 	modbusSerialState = MODBUS_GETADDY; 
03A40:  CLR.B   1265
03A42:  PUSH    42
03A44:  BCLR.B  8C1.7
03A46:  SETM.B  42
03A48:  BSET.B  8C1.7
.................... 	modbusEnableTimeout(false); 
03A4A:  CLR.B   15E2
03A4C:  CALL    10D8
03A50:  BCLR.B  8C1.7
03A52:  POP     42
03A54:  BSET.B  8C1.7
03A56:  RETURN  
.................... } 
....................  
.................... void modbusCheckTimeout(){ 
03A58:  MOV     W5,[W15++]
.................... 	get_ticks(T3); 
03A5A:  CALL    39EA
.................... 	if(!modbusTimeoutEnabled && (get_ticks(T3) > MODBUS_GETDATA_TIMEOUT)){ 
03A5E:  BTSC.B  1264.3
03A60:  BRA     3A72
03A62:  CALL    39EA
03A66:  MOV     W0,W5
03A68:  MOV     #28,W4
03A6A:  CP      W4,W5
03A6C:  BRA     C,3A72
.................... 		modbusTimeoutNow(); 
03A6E:  CALL    3A1E
.................... 	} 
03A72:  MOV     [--W15],W5
03A74:  RETURN  
.................... } 
....................  
.................... bool modbus_kbhit(){ 
.................... 	modbusCheckTimeout(); 
03A76:  CALL    3A58
.................... 	if (kbhit(MODBUS)) { 
03A7A:  BTSS.B  232.0
03A7C:  BRA     3A98
.................... 		modbusTimeoutOK = false; 
03A7E:  BCLR.B  1264.5
.................... 		if (modbusRx.func == 0x80) { 
03A80:  MOV     13FE,W4
03A82:  XOR.B   #80,W4L
03A84:  BRA     NZ,3A8E
.................... 			modbusRx.error = modbusRx.data[0]; 
03A86:  MOV.B   1400,W0L
03A88:  MOV.B   W0L,13FF
.................... 			modbusRx.len = 1; 
03A8A:  MOV.B   #1,W0L
03A8C:  MOV.B   W0L,13FD
.................... 		} 
.................... 		return true; 
03A8E:  MOV.B   #1,W0L
03A90:  MOV.B   W0L,0
03A92:  BRA     3A9C
.................... 	} 
03A94:  GOTO    3A9C
.................... 	else { 
.................... 		return false; 
03A98:  CLR.B   0
03A9A:  BRA     3A9C
.................... 	} 
03A9C:  RETURN  
.................... 	/*if(!modbusSerialNew){ 
.................... 		return false; 
.................... 	}*/ 
.................... 	/*modbusSerialNew = false; 
.................... 	return true;*/ 
.................... } 
....................  
.................... void modbusCalcCrc(char data){ 
.................... 	unsigned int8 mIndex; 
.................... 	mIndex = modbusSerialCrc.b[1] ^ data; 
*
010E6:  MOV.B   1441,W0L
010E8:  XOR.B   15E2,W0L
010EA:  MOV.B   W0L,15E3
.................... 	modbusSerialCrc.b[1] = modbusSerialCrc.b[0] ^ modbus_auchCRCHi[mIndex]; 
010EC:  MOV.B   15E3,W0L
010EE:  CLR.B   1
010F0:  CALL    200
010F4:  MOV.B   W0L,1441
010F6:  MOV.B   1440,W0L
010F8:  XOR.B   1441
.................... 	modbusSerialCrc.b[0] = modbus_auchCRCLo[mIndex]; 
010FA:  MOV.B   15E3,W0L
010FC:  CLR.B   1
010FE:  CALL    2C8
01102:  MOV.B   W0L,1440
01104:  RETURN  
.................... } 
....................  
.................... exception modbusReadHoldingRegRsp(unsigned int8 address, unsigned int8 func, unsigned int16 startAddress, unsigned int16 quality){ 
.................... 	unsigned int8 startAddressHi, startAddressLo; 
.................... 	unsigned int8 qualityHi, qualityLo; 
.................... 	startAddressHi = make8(startAddress, 1); 
*
03A9E:  MOV.B   147B,W0L
03AA0:  MOV.B   W0L,147E
.................... 	startAddressLo = make8(startAddress, 0); 
03AA2:  MOV.B   147A,W0L
03AA4:  MOV.B   W0L,147F
.................... 	qualityHi = make8(quality, 1); 
03AA6:  MOV.B   147D,W0L
03AA8:  MOV.B   W0L,1480
.................... 	qualityLo = make8(quality, 0); 
03AAA:  MOV.B   147C,W0L
03AAC:  MOV.B   W0L,1481
.................... 	switch(caseSend){ 
03AAE:  MOV.B   1449,W0L
03AB0:  CLR.B   1
03AB2:  XOR     #0,W0
03AB4:  BRA     Z,3ADC
03AB6:  XOR     #1,W0
03AB8:  BRA     Z,3AEE
03ABA:  XOR     #3,W0
03ABC:  BRA     Z,3B16
03ABE:  XOR     #1,W0
03AC0:  BRA     Z,3B3E
03AC2:  XOR     #7,W0
03AC4:  BRA     Z,3B66
03AC6:  XOR     #1,W0
03AC8:  BRA     Z,3B8E
03ACA:  XOR     #3,W0
03ACC:  BRA     Z,3BB6
03ACE:  XOR     #1,W0
03AD0:  BRA     Z,3BDE
03AD2:  XOR     #F,W0
03AD4:  BRA     Z,3C0E
03AD6:  XOR     #1,W0
03AD8:  BRA     Z,3C3A
03ADA:  BRA     3C9C
.................... 		case 0:{ 
.................... 			disable_interrupts(int_rda2); 
03ADC:  BCLR.B  823.6
.................... 			output_high(pinControl485); 
03ADE:  BCLR.B  E50.3
03AE0:  BSET.B  E54.3
.................... 			modbusSerialCrc.d = 0xffff; 
03AE2:  SETM    1440
.................... 			modbusSerialNew = false; 
03AE4:  BCLR.B  1264.4
.................... 			caseSend = 1; 
03AE6:  MOV.B   #1,W0L
03AE8:  MOV.B   W0L,1449
.................... 			break; 
03AEA:  GOTO    3C9C
.................... 		} 
.................... 		case 1:{ 
.................... 			fputc(address, MODBUS); 
03AEE:  MOV.B   1478,W0L
03AF0:  BTSC.B  233.1
03AF2:  BRA     3AF0
03AF4:  MOV.B   W0L,234
03AF6:  CLR.B   235
03AF8:  PUSH    42
03AFA:  BCLR.B  8C1.7
03AFC:  SETM.B  42
03AFE:  BSET.B  8C1.7
.................... 			modbusCalcCrc(address); 
03B00:  MOV.B   1478,W0L
03B02:  MOV.B   W0L,15E2
03B04:  CALL    10E6
03B08:  BCLR.B  8C1.7
03B0A:  POP     42
03B0C:  BSET.B  8C1.7
.................... 			caseSend = 2; 
03B0E:  MOV.B   #2,W0L
03B10:  MOV.B   W0L,1449
.................... 			break; 
03B12:  GOTO    3C9C
.................... 		} 
.................... 		case 2:{ 
.................... 			fputc(func, MODBUS); 
03B16:  MOV.B   1479,W0L
03B18:  BTSC.B  233.1
03B1A:  BRA     3B18
03B1C:  MOV.B   W0L,234
03B1E:  CLR.B   235
03B20:  PUSH    42
03B22:  BCLR.B  8C1.7
03B24:  SETM.B  42
03B26:  BSET.B  8C1.7
.................... 			modbusCalcCrc(func); 
03B28:  MOV.B   1479,W0L
03B2A:  MOV.B   W0L,15E2
03B2C:  CALL    10E6
03B30:  BCLR.B  8C1.7
03B32:  POP     42
03B34:  BSET.B  8C1.7
.................... 			caseSend = 3; 
03B36:  MOV.B   #3,W0L
03B38:  MOV.B   W0L,1449
.................... 			break; 
03B3A:  GOTO    3C9C
.................... 		} 
.................... 		case 3:{ 
.................... 			fputc(startAddressHi, MODBUS); 
03B3E:  MOV.B   147E,W0L
03B40:  BTSC.B  233.1
03B42:  BRA     3B40
03B44:  MOV.B   W0L,234
03B46:  CLR.B   235
03B48:  PUSH    42
03B4A:  BCLR.B  8C1.7
03B4C:  SETM.B  42
03B4E:  BSET.B  8C1.7
.................... 			modbusCalcCrc(startAddressHi); 
03B50:  MOV.B   147E,W0L
03B52:  MOV.B   W0L,15E2
03B54:  CALL    10E6
03B58:  BCLR.B  8C1.7
03B5A:  POP     42
03B5C:  BSET.B  8C1.7
.................... 			caseSend = 4; 
03B5E:  MOV.B   #4,W0L
03B60:  MOV.B   W0L,1449
.................... 			break; 
03B62:  GOTO    3C9C
.................... 		} 
.................... 		case 4:{ 
.................... 			fputc(startAddressLo, MODBUS); 
03B66:  MOV.B   147F,W0L
03B68:  BTSC.B  233.1
03B6A:  BRA     3B68
03B6C:  MOV.B   W0L,234
03B6E:  CLR.B   235
03B70:  PUSH    42
03B72:  BCLR.B  8C1.7
03B74:  SETM.B  42
03B76:  BSET.B  8C1.7
.................... 			modbusCalcCrc(startAddressLo); 
03B78:  MOV.B   147F,W0L
03B7A:  MOV.B   W0L,15E2
03B7C:  CALL    10E6
03B80:  BCLR.B  8C1.7
03B82:  POP     42
03B84:  BSET.B  8C1.7
.................... 			caseSend = 5; 
03B86:  MOV.B   #5,W0L
03B88:  MOV.B   W0L,1449
.................... 			break; 
03B8A:  GOTO    3C9C
.................... 		} 
.................... 		case 5:{ 
.................... 			fputc(qualityHi, MODBUS); 
03B8E:  MOV.B   1480,W0L
03B90:  BTSC.B  233.1
03B92:  BRA     3B90
03B94:  MOV.B   W0L,234
03B96:  CLR.B   235
03B98:  PUSH    42
03B9A:  BCLR.B  8C1.7
03B9C:  SETM.B  42
03B9E:  BSET.B  8C1.7
.................... 			modbusCalcCrc(qualityHi); 
03BA0:  MOV.B   1480,W0L
03BA2:  MOV.B   W0L,15E2
03BA4:  CALL    10E6
03BA8:  BCLR.B  8C1.7
03BAA:  POP     42
03BAC:  BSET.B  8C1.7
.................... 			caseSend = 6; 
03BAE:  MOV.B   #6,W0L
03BB0:  MOV.B   W0L,1449
.................... 			break; 
03BB2:  GOTO    3C9C
.................... 		} 
.................... 		case 6:{ 
.................... 			fputc(qualityLo, MODBUS); 
03BB6:  MOV.B   1481,W0L
03BB8:  BTSC.B  233.1
03BBA:  BRA     3BB8
03BBC:  MOV.B   W0L,234
03BBE:  CLR.B   235
03BC0:  PUSH    42
03BC2:  BCLR.B  8C1.7
03BC4:  SETM.B  42
03BC6:  BSET.B  8C1.7
.................... 			modbusCalcCrc(qualityLo); 
03BC8:  MOV.B   1481,W0L
03BCA:  MOV.B   W0L,15E2
03BCC:  CALL    10E6
03BD0:  BCLR.B  8C1.7
03BD2:  POP     42
03BD4:  BSET.B  8C1.7
.................... 			caseSend = 7; 
03BD6:  MOV.B   #7,W0L
03BD8:  MOV.B   W0L,1449
.................... 			break; 
03BDA:  GOTO    3C9C
.................... 		} 
.................... 		case 7:{ 
.................... 			crcHigh = modbusSerialCrc.b[1]; 
03BDE:  MOV.B   1441,W0L
03BE0:  MOV.B   W0L,1443
.................... 			crcLow = modbusSerialCrc.b[0]; 
03BE2:  MOV.B   1440,W0L
03BE4:  MOV.B   W0L,1448
.................... 			fputc(crcHigh, MODBUS); 
03BE6:  MOV.B   1443,W0L
03BE8:  BTSC.B  233.1
03BEA:  BRA     3BE8
03BEC:  MOV.B   W0L,234
03BEE:  CLR.B   235
03BF0:  PUSH    42
03BF2:  BCLR.B  8C1.7
03BF4:  SETM.B  42
03BF6:  BSET.B  8C1.7
.................... 			modbusCalcCrc(crcHigh); 
03BF8:  MOV.B   1443,W0L
03BFA:  MOV.B   W0L,15E2
03BFC:  CALL    10E6
03C00:  BCLR.B  8C1.7
03C02:  POP     42
03C04:  BSET.B  8C1.7
.................... 			caseSend = 8; 
03C06:  MOV.B   #8,W0L
03C08:  MOV.B   W0L,1449
.................... 			break; 
03C0A:  GOTO    3C9C
.................... 		} 
.................... 		case 8:{ 
.................... 			crcLow = modbusSerialCrc.b[1]; 
03C0E:  MOV.B   1441,W0L
03C10:  MOV.B   W0L,1448
.................... 			fputc(crcLow, MODBUS); 
03C12:  MOV.B   1448,W0L
03C14:  BTSC.B  233.1
03C16:  BRA     3C14
03C18:  MOV.B   W0L,234
03C1A:  CLR.B   235
03C1C:  PUSH    42
03C1E:  BCLR.B  8C1.7
03C20:  SETM.B  42
03C22:  BSET.B  8C1.7
.................... 			modbusCalcCrc(crcLow); 
03C24:  MOV.B   1448,W0L
03C26:  MOV.B   W0L,15E2
03C28:  CALL    10E6
03C2C:  BCLR.B  8C1.7
03C2E:  POP     42
03C30:  BSET.B  8C1.7
.................... 			caseSend = 9; 
03C32:  MOV.B   #9,W0L
03C34:  MOV.B   W0L,1449
.................... 			break; 
03C36:  GOTO    3C9C
.................... 		} 
.................... 		case 9:{ 
.................... 			modbusSerialCrc.d = 0xffff; 
03C3A:  SETM    1440
.................... 			output_low(pinControl485); 
03C3C:  BCLR.B  E50.3
03C3E:  BCLR.B  E54.3
.................... 			modbusSerialNew = true; 
03C40:  BSET.B  1264.4
.................... 			modbusSerialWait = MODBUS_SERIAL_TIMEOUT; 
03C42:  MOV     #2710,W4
03C44:  MOV     W4,1444
03C46:  CLR     1446
.................... 			clear_interrupt(int_rda2); 
03C48:  REPEAT  #3
03C4A:  MOV     236,W0
03C4C:  BCLR.B  803.6
.................... 			enable_interrupts(global); 
03C4E:  BSET.B  8C3.7
.................... 			enable_interrupts(int_rda2); 
03C50:  BSET.B  823.6
.................... 			modbusSerialWaitResponse(); 
03C52:  BCLR.B  1264.5
03C54:  BCLR.B  1264.2
03C56:  BCLR.B  E50.3
03C58:  BCLR.B  E54.3
03C5A:  CP0.B   1478
03C5C:  BRA     Z,3C8E
03C5E:  CALL    3A76
03C62:  CP0.B   W0L
03C64:  BRA     NZ,3C7A
03C66:  DEC     1444
03C68:  BTSS.B  42.0
03C6A:  DEC     1446
03C6C:  CP0     1444
03C6E:  BRA     NZ,3C74
03C70:  CP0     1446
03C72:  BRA     Z,3C7A
03C74:  BCLR.B  144A.0
03C76:  GOTO    3C5E
03C7A:  CP0     1444
03C7C:  BRA     NZ,3C8E
03C7E:  CP0     1446
03C80:  BRA     NZ,3C8E
03C82:  MOV.B   #C,W0L
03C84:  MOV.B   W0L,13FF
03C86:  BCLR.B  1264.5
03C88:  MOV     #2710,W4
03C8A:  MOV     W4,1444
03C8C:  CLR     1446
.................... 			sendMessageComplete = false; 
03C8E:  BCLR.B  1264.7
.................... 			caseSend = 0; 
03C90:  CLR.B   1449
.................... 			stack = 0; 
03C92:  CLR.B   1464
.................... 			return modbusRx.error; 
03C94:  MOV.B   13FF,W0L
03C96:  BRA     3C9C
.................... 			break; 
03C98:  GOTO    3C9C
.................... 		} 
.................... 	} 
03C9C:  RETURN  
.................... } 
....................  
.................... void main(){ 
*
03DAA:  MOV     #CF80,W15
03DAC:  MOV     #CFFF,W0
03DAE:  MOV     W0,20
03DB0:  NOP     
03DB2:  BSET.B  8C1.7
03DB4:  MOV     #46,W0
03DB6:  MOV.B   W0L,742
03DB8:  MOV     #57,W0
03DBA:  MOV.B   W0L,742
03DBC:  BCLR.B  742.6
03DBE:  MOV     #54,W0
03DC0:  MOV     W0,6C4
03DC2:  MOV     #66,W0
03DC4:  MOV     W0,6C6
03DC6:  MOV     #61,W0
03DC8:  MOV     W0,6D6
03DCA:  MOV     #1B00,W0
03DCC:  MOV     W0,688
03DCE:  MOV     #1,W0
03DD0:  MOV     W0,68A
03DD2:  MOV     #3,W0
03DD4:  MOV     W0,690
03DD6:  MOV     #46,W0
03DD8:  MOV.B   W0L,742
03DDA:  MOV     #57,W0
03DDC:  MOV.B   W0L,742
03DDE:  BSET.B  742.6
03DE0:  MOV     #41,W4
03DE2:  MOV     W4,744
03DE4:  MOV     #16,W4
03DE6:  MOV     W4,746
03DE8:  DISI    #E
03DEA:  MOV     #103,W0
03DEC:  MOV     #743,W1
03DEE:  MOV     #78,W2
03DF0:  MOV     #9A,W3
03DF2:  MOV.B   W2L,[W1]
03DF4:  MOV.B   W3L,[W1]
03DF6:  MOV.B   W0L,743
03DF8:  LSR     W0,#8,W0
03DFA:  MOV     #742,W1
03DFC:  MOV     #46,W2
03DFE:  MOV     #57,W3
03E00:  MOV.B   W2L,[W1]
03E02:  MOV.B   W3L,[W1]
03E04:  MOV.B   W0L,[W1]
03E06:  CLR     1000
03E08:  MOV     #8000,W4
03E0A:  MOV     W4,220
03E0C:  MOV     #400,W4
03E0E:  MOV     W4,222
03E10:  BSET.B  220.3
03E12:  MOV     #56,W4
03E14:  MOV     W4,228
03E16:  MOV     #8000,W4
03E18:  MOV     W4,250
03E1A:  MOV     #400,W4
03E1C:  MOV     W4,252
03E1E:  BSET.B  250.3
03E20:  MOV     #2A,W4
03E22:  MOV     W4,258
03E24:  MOV     #8000,W4
03E26:  MOV     W4,230
03E28:  MOV     #400,W4
03E2A:  MOV     W4,232
03E2C:  BSET.B  230.3
03E2E:  MOV     #208,W4
03E30:  MOV     W4,238
03E32:  CLR     1002
03E34:  CLR     100
03E36:  CLR     104
03E38:  SETM    102
03E3A:  MOV     #8030,W4
03E3C:  MOV     W4,104
03E3E:  BCLR.B  800.3
03E40:  CLR     1004
03E42:  CLR     106
03E44:  CLR     110
03E46:  SETM    10C
03E48:  MOV     #8030,W4
03E4A:  MOV     W4,110
03E4C:  BCLR.B  800.7
03E4E:  CLR     1006
03E50:  CLR     10A
03E52:  CLR     112
03E54:  SETM    10E
03E56:  MOV     #8030,W4
03E58:  MOV     W4,112
03E5A:  BCLR.B  801.0
03E5C:  BCLR.B  1109.0
03E5E:  BCLR.B  1109.1
03E60:  BCLR.B  1109.2
03E62:  BSET.B  1109.3
03E64:  MOV     #FF,W4
03E66:  MOV     W4,1262
03E68:  BCLR.B  1109.7
03E6A:  BCLR.B  1264.0
03E6C:  BCLR.B  1264.1
03E6E:  CLR     126E
03E70:  CLR     1270
03E72:  MOV     #4,W4
03E74:  MOV     W4,1272
03E76:  CLR     1274
03E78:  CLR     1276
03E7A:  CLR     1278
03E7C:  CLR     127A
03E7E:  CLR     127E
03E80:  CLR     1280
03E82:  CLR     1282
03E84:  CLR     1288
03E86:  CLR     128A
03E88:  CLR     128E
03E8A:  CLR     1290
03E8C:  CLR     1292
03E8E:  CLR     1294
03E90:  CLR.B   1265
03E92:  CLR.B   1442
03E94:  BCLR.B  1264.2
03E96:  BCLR.B  1264.3
03E98:  BCLR.B  1264.4
03E9A:  BCLR.B  1264.5
03E9C:  BCLR.B  1264.6
03E9E:  MOV     #2710,W4
03EA0:  MOV     W4,1444
03EA2:  CLR     1446
03EA4:  CLR.B   1449
03EA6:  BCLR.B  1264.7
03EA8:  BCLR.B  144A.0
03EAA:  CLR.B   144B
03EAC:  CLR     145C
03EAE:  CLR     145E
03EB0:  CLR     1460
03EB2:  CLR     1462
03EB4:  MOV.B   #1,W0L
03EB6:  MOV.B   W0L,1464
03EB8:  CLR     E0E
03EBA:  CLR     E1E
03EBC:  CLR     E2E
03EBE:  CLR     E3E
03EC0:  CLR     E4E
03EC2:  CLR     E5E
03EC4:  CLR     E6E
03EC6:  MOV     #15E8,W4
03EC8:  MOV     W4,146C
03ECA:  MOV     #7FFB,W4
03ECC:  MOV     W4,15E8
03ECE:  MOV     #95E8,W4
03ED0:  MOV     W4,15EA
03ED2:  MOV     #3994,W4
03ED4:  MOV     W4,[W15++]
03ED6:  POP     95E8
03ED8:  MOV     #D000,W4
03EDA:  MOV     W4,[W15++]
03EDC:  POP     95EA
03EDE:  MOV     #FFC,W4
03EE0:  MOV     W4,[W15++]
03EE2:  POP     D000
03EE4:  MOV     #0,W4
03EE6:  MOV     W4,[W15++]
03EE8:  POP     D002
03EEA:  CLR     1214
03EEC:  CLR     1216
03EEE:  CLR     1218
03EF0:  CLR     121A
03EF2:  CLR     121C
03EF4:  CLR     121E
03EF6:  CLR     1220
03EF8:  CLR     1222
03EFA:  CLR     1224
03EFC:  CLR     1226
03EFE:  CLR     1228
03F00:  CLR     122A
03F02:  CLR     122C
03F04:  CLR     122E
03F06:  CLR     1230
03F08:  CLR     1232
03F0A:  CLR     1234
03F0C:  CLR     1236
03F0E:  CLR     1238
03F10:  CLR     123A
03F12:  CLR     123C
03F14:  CLR     123E
03F16:  CLR     1240
03F18:  CLR     1242
03F1A:  CLR     1244
03F1C:  CLR     1246
03F1E:  CLR     1248
03F20:  CLR     124A
03F22:  CLR     124C
03F24:  CLR     124E
03F26:  CLR     1250
03F28:  CLR     1252
03F2A:  CLR     1254
03F2C:  CLR     1256
03F2E:  CLR     1258
03F30:  CLR     1466
.................... 	caseSend = 0; 
03F32:  CLR.B   1449
.................... 	 
.................... 	clear_interrupt(int_rda2); 
03F34:  REPEAT  #3
03F36:  MOV     236,W0
03F38:  BCLR.B  803.6
.................... 	enable_interrupts(global); 
03F3A:  BSET.B  8C3.7
.................... 	enable_interrupts(int_rda2); 
03F3C:  BSET.B  823.6
....................  
.................... 	set_tris_f(0x42); 
03F3E:  MOV     #42,W4
03F40:  MOV     W4,E50
.................... 	output_low(pinControl485); 
03F42:  BCLR.B  E50.3
03F44:  BCLR.B  E54.3
.................... 	set_tris_e(0x10); 
03F46:  MOV     #10,W4
03F48:  MOV     W4,E40
.................... 	output_high(PKEY); 
03F4A:  BCLR.B  E40.1
03F4C:  BSET.B  E44.1
.................... 	 
.................... 	memset(inputString, 0, sizeof(inputString)); 
03F4E:  MOV     #110C,W1
03F50:  MOV     #0,W2
03F52:  REPEAT  #FF
03F54:  CLR.B   [W1++]
.................... 	 
.................... 	reply = malloc(20); 
03F56:  MOV     #14,W4
03F58:  MOV     W4,14CC
03F5A:  CALL    1224
03F5E:  MOV     W0,1296
.................... 	memset(reply, 0, sizeof(reply)); 
03F60:  MOV     1296,W1
03F62:  MOV     #0,W2
03F64:  REPEAT  #1
03F66:  CLR.B   [W1++]
.................... 	 
.................... 	mqttClient = malloc(1024); 
03F68:  MOV     #400,W4
03F6A:  MOV     W4,14CC
03F6C:  CALL    1224
03F70:  MOV     W0,110A
.................... 	memset(mqttClient, 0, sizeof(mqttClient)); 
03F72:  MOV     110A,W1
03F74:  MOV     #0,W2
03F76:  REPEAT  #1
03F78:  CLR.B   [W1++]
.................... 	sprintf(mqttClient -> mqttClientID, "DeviceNo.1"); 
03F7A:  MOV     #0,W0
03F7C:  ADD     110A,W0
03F7E:  MOV     W0,W5
03F80:  MOV     W5,1476
03F82:  MOV     #0,W1
03F84:  MOV     W1,W0
03F86:  CLR.B   1
03F88:  CALL    F78
03F8C:  INC     W1,W1
03F8E:  MOV     W1,[W15++]
03F90:  MOV     W0,[W15++]
03F92:  MOV     [--W15],W0
03F94:  CALL    12DE
03F98:  MOV     [--W15],W1
03F9A:  MOV     #9,W0
03F9C:  CPSGT   W1,W0
03F9E:  BRA     3F84
.................... 	mqttClient -> passwordFlag = false; 
03FA0:  MOV     #64,W0
03FA2:  ADD     110A,W0
03FA4:  MOV     W0,W5
03FA6:  MOV     #FE,W4
03FA8:  AND.B   W4L,[W5],[W5]
.................... 	mqttClient -> userNameFlag = false; 
03FAA:  MOV     #64,W0
03FAC:  ADD     110A,W0
03FAE:  MOV     W0,W5
03FB0:  MOV     #FD,W4
03FB2:  AND.B   W4L,[W5],[W5]
.................... 	sprintf(mqttClient -> password, ""); 
03FB4:  MOV     #65,W0
03FB6:  ADD     110A,W0
03FB8:  MOV     W0,W5
03FBA:  MOV     W5,1476
.................... 	sprintf(mqttClient -> userName, ""); 
03FBC:  MOV     #A5,W0
03FBE:  ADD     110A,W0
03FC0:  MOV     W0,W5
03FC2:  MOV     W5,1476
.................... 	mqttClient -> cleanSession = 1; 
03FC4:  MOV     #E5,W0
03FC6:  ADD     110A,W0
03FC8:  MOV     W0,W5
03FCA:  MOV     #1,W4
03FCC:  IOR.B    W4L,  [W5],[W5]
.................... 	mqttClient -> willFlag = 0; 
03FCE:  MOV     #E5,W0
03FD0:  ADD     110A,W0
03FD2:  MOV     W0,W5
03FD4:  MOV     #FD,W4
03FD6:  AND.B   W4L,[W5],[W5]
.................... 	mqttClient -> willQoS = 0; 
03FD8:  MOV     #E5,W0
03FDA:  ADD     110A,W0
03FDC:  MOV     W0,W5
03FDE:  MOV     #FB,W4
03FE0:  AND.B   W4L,[W5],[W5]
.................... 	mqttClient -> willRetain = 0; 
03FE2:  MOV     #E5,W0
03FE4:  ADD     110A,W0
03FE6:  MOV     W0,W5
03FE8:  MOV     #F7,W4
03FEA:  AND.B   W4L,[W5],[W5]
.................... 	sprintf(mqttClient -> willTopic, ""); 
03FEC:  MOV     #E6,W0
03FEE:  ADD     110A,W0
03FF0:  MOV.B   [W0],W5L
03FF2:  PUSH    1476
03FF4:  MOV.B   W5L,[W15-#2]
03FF6:  POP     1476
03FF8:  CLR.B   1477
.................... 	sprintf(mqttClient -> willMessage, ""); 
03FFA:  MOV     #E7,W0
03FFC:  ADD     110A,W0
03FFE:  MOV.B   [W0],W5L
04000:  PUSH    1476
04002:  MOV.B   W5L,[W15-#2]
04004:  POP     1476
04006:  CLR.B   1477
.................... 	keepAliveTimeout = 60; 
04008:  MOV     #3C,W4
0400A:  MOV     W4,1284
0400C:  CLR     1286
.................... 	 
.................... 	subTopicFlag = true; 
0400E:  BSET.B  1109.4
.................... 	pubTopicFlag = true; 
04010:  BSET.B  1109.5
.................... 	messageFlag	= false; 
04012:  BCLR.B  1109.6
.................... 	mqttQuery = true; 
04014:  BSET.B  1109.3
.................... 	 
.................... 	mqttHost = malloc(50); 
04016:  MOV     #32,W4
04018:  MOV     W4,14CC
0401A:  CALL    1224
0401E:  MOV     W0,125A
.................... 	mqttPort = malloc(10); 
04020:  MOV     #A,W4
04022:  MOV     W4,14CC
04024:  CALL    1224
04028:  MOV     W0,125C
.................... 	memset(mqttHost, 0, sizeof(mqttHost)); 
0402A:  MOV     125A,W1
0402C:  MOV     #0,W2
0402E:  REPEAT  #1
04030:  CLR.B   [W1++]
.................... 	memset(mqttPort, 0, sizeof(mqttPort)); 
04032:  MOV     125C,W1
04034:  MOV     #0,W2
04036:  REPEAT  #1
04038:  CLR.B   [W1++]
.................... 	 
.................... 	fprintf(DEBUG, "Setting Broker\r\n"); 
0403A:  MOV     #0,W1
0403C:  MOV     W1,W0
0403E:  CLR.B   1
04040:  CALL    F90
04044:  INC     W1,W1
04046:  BTSC.B  223.1
04048:  BRA     4046
0404A:  MOV     W0,224
0404C:  MOV     #F,W0
0404E:  CPSGT   W1,W0
04050:  BRA     403C
.................... 	sprintf(mqttHost, "103.249.100.48"); 
04052:  PUSH    125A
04054:  POP     1476
04056:  MOV     #0,W1
04058:  MOV     W1,W0
0405A:  CLR.B   1
0405C:  CALL    E50
04060:  INC     W1,W1
04062:  MOV     W1,[W15++]
04064:  MOV     W0,[W15++]
04066:  MOV     [--W15],W0
04068:  CALL    12DE
0406C:  MOV     [--W15],W1
0406E:  MOV     #D,W0
04070:  CPSGT   W1,W0
04072:  BRA     4058
.................... 	fprintf(DEBUG, "Broker: %s\r\n", mqttHost); 
04074:  MOV     #0,W1
04076:  MOV     W1,W0
04078:  CLR.B   1
0407A:  CALL    FAE
0407E:  INC     W1,W1
04080:  BTSC.B  223.1
04082:  BRA     4080
04084:  MOV     W0,224
04086:  MOV     #7,W0
04088:  CPSGT   W1,W0
0408A:  BRA     4076
0408C:  MOV     125A,W1
0408E:  CP0.B   [W1]
04090:  BRA     Z,40A0
04092:  BTSC.B  223.1
04094:  BRA     4092
04096:  MOV.B   [W1+#0],W0L
04098:  MOV.B   W0L,224
0409A:  CLR.B   225
0409C:  INC     W1,W1
0409E:  BRA     408E
040A0:  BTSC.B  223.1
040A2:  BRA     40A0
040A4:  MOV     #D,W4
040A6:  MOV     W4,224
040A8:  BTSC.B  223.1
040AA:  BRA     40A8
040AC:  MOV     #A,W4
040AE:  MOV     W4,224
.................... 	sprintf(mqttPort, "1883"); 
040B0:  PUSH    125C
040B2:  POP     1476
040B4:  MOV     #0,W1
040B6:  MOV     W1,W0
040B8:  CLR.B   1
040BA:  CALL    E6C
040BE:  INC     W1,W1
040C0:  MOV     W1,[W15++]
040C2:  MOV     W0,[W15++]
040C4:  MOV     [--W15],W0
040C6:  CALL    12DE
040CA:  MOV     [--W15],W1
040CC:  MOV     #3,W0
040CE:  CPSGT   W1,W0
040D0:  BRA     40B6
.................... 	fprintf(DEBUG, "port: %s\r\n", mqttPort); 
040D2:  MOV     #0,W1
040D4:  MOV     W1,W0
040D6:  CLR.B   1
040D8:  CALL    FC8
040DC:  INC     W1,W1
040DE:  BTSC.B  223.1
040E0:  BRA     40DE
040E2:  MOV     W0,224
040E4:  MOV     #5,W0
040E6:  CPSGT   W1,W0
040E8:  BRA     40D4
040EA:  MOV     125C,W1
040EC:  CP0.B   [W1]
040EE:  BRA     Z,40FE
040F0:  BTSC.B  223.1
040F2:  BRA     40F0
040F4:  MOV.B   [W1+#0],W0L
040F6:  MOV.B   W0L,224
040F8:  CLR.B   225
040FA:  INC     W1,W1
040FC:  BRA     40EC
040FE:  BTSC.B  223.1
04100:  BRA     40FE
04102:  MOV     #D,W4
04104:  MOV     W4,224
04106:  BTSC.B  223.1
04108:  BRA     4106
0410A:  MOV     #A,W4
0410C:  MOV     W4,224
.................... 	fprintf(DEBUG, "Setting Broker OK\r\n"); 
0410E:  MOV     #0,W1
04110:  MOV     W1,W0
04112:  CLR.B   1
04114:  CALL    FE0
04118:  INC     W1,W1
0411A:  BTSC.B  223.1
0411C:  BRA     411A
0411E:  MOV     W0,224
04120:  MOV     #12,W0
04122:  CPSGT   W1,W0
04124:  BRA     4110
.................... 	 
.................... 	powerOnM95(); 
04126:  CALL    1300
.................... 	 
.................... 	pubTopic = malloc(100); 
0412A:  MOV     #64,W4
0412C:  MOV     W4,14CC
0412E:  CALL    1224
04132:  MOV     W0,1210
.................... 	subTopic = malloc(100); 
04134:  MOV     #64,W4
04136:  MOV     W4,14CC
04138:  CALL    1224
0413C:  MOV     W0,120E
.................... 	message = malloc(255);	 
0413E:  MOV     #FF,W4
04140:  MOV     W4,14CC
04142:  CALL    1224
04146:  MOV     W0,1212
.................... 	memset(subTopic, 0, sizeof(subTopic)); 
04148:  MOV     120E,W1
0414A:  MOV     #0,W2
0414C:  REPEAT  #1
0414E:  CLR.B   [W1++]
.................... 	memset(pubTopic, 0, sizeof(pubTopic)); 
04150:  MOV     1210,W1
04152:  MOV     #0,W2
04154:  REPEAT  #1
04156:  CLR.B   [W1++]
.................... 	memset(message, 0, sizeof(message)); 
04158:  MOV     1212,W1
0415A:  MOV     #0,W2
0415C:  REPEAT  #1
0415E:  CLR.B   [W1++]
.................... 	sprintf(subTopic, "%s", mqttClient -> mqttClientID); 
04160:  MOV     #0,W0
04162:  ADD     110A,W0
04164:  MOV     W0,W5
04166:  PUSH    120E
04168:  POP     1476
0416A:  MOV     W5,W1
0416C:  CP0.B   [W1]
0416E:  BRA     Z,4180
04170:  MOV     W1,[W15++]
04172:  MOV     W1,W4
04174:  MOV.B   [W4],W0L
04176:  CALL    12DE
0417A:  MOV     [--W15],W1
0417C:  INC     W1,W1
0417E:  BRA     416C
....................  
.................... 	stack = 0; 
04180:  CLR.B   1464
.................... 	modbusQuery = true; 
04182:  BSET.B  1264.6
.................... 	modbusTimeoutOK = false; 
04184:  BCLR.B  1264.5
.................... 	 
.................... 	delay_ms(5000); 
04186:  MOV     #1388,W0
04188:  CALL    12EC
.................... 	tcpFlag = false; 
0418C:  BCLR.B  1109.1
.................... 	begin(); 
0418E:  CALL    34E6
.................... 	while(1){ 
.................... 		messageProcessing(); 
04192:  CALL    352A
.................... 		switch(stack){ 
04196:  MOV.B   1464,W0L
04198:  CLR.B   1
0419A:  XOR     #0,W0
0419C:  BRA     Z,41A4
0419E:  XOR     #1,W0
041A0:  BRA     Z,42F6
041A2:  BRA     43DC
.................... 			case 0:{ 
.................... 				stack = 1; 
041A4:  MOV.B   #1,W0L
041A6:  MOV.B   W0L,1464
.................... 				if(tcpFlag){ 
041A8:  BTSS.B  1109.1
041AA:  BRA     42F2
.................... //					serialEvent(); 
.................... 					if(mqttAvailable()){ 
041AC:  CALL    36A2
041B0:  CP0.B   W0L
041B2:  BRA     Z,42EC
.................... 						serialEvent(); 
041B4:  CALL    1E5A
.................... 						if(subTopicFlag && mqttQuery){ 
041B8:  BTSS.B  1109.4
041BA:  BRA     4200
041BC:  BTSS.B  1109.3
041BE:  BRA     4200
.................... 							memset(subTopic, 0, sizeof(subTopic)); 
041C0:  MOV     120E,W1
041C2:  MOV     #0,W2
041C4:  REPEAT  #1
041C6:  CLR.B   [W1++]
.................... 							sprintf(subTopic, "%s", mqttClient -> mqttClientID); 
041C8:  MOV     #0,W0
041CA:  ADD     110A,W0
041CC:  MOV     W0,W5
041CE:  PUSH    120E
041D0:  POP     1476
041D2:  MOV     W5,W1
041D4:  CP0.B   [W1]
041D6:  BRA     Z,41E8
041D8:  MOV     W1,[W15++]
041DA:  MOV     W1,W4
041DC:  MOV.B   [W4],W0L
041DE:  CALL    12DE
041E2:  MOV     [--W15],W1
041E4:  INC     W1,W1
041E6:  BRA     41D4
.................... 							mqttSubscribe(0, generateMessageID(), subTopic, 0); 
041E8:  CALL    36AA
041EC:  MOV     W0,W5
041EE:  CLR.B   147C
041F0:  CLR.B   147D
041F2:  MOV     W5,147E
041F4:  PUSH    120E
041F6:  POP     1480
041F8:  CALL    36C8
.................... 							subTopicFlag = false; 
041FC:  BCLR.B  1109.4
.................... 							mqttQuery = false; 
041FE:  BCLR.B  1109.3
.................... 						} 
.................... 						if(pubTopicFlag && mqttQuery){ 
04200:  BTSS.B  1109.5
04202:  BRA     42E8
04204:  BTSS.B  1109.3
04206:  BRA     42E8
.................... 							fprintf(DEBUG, "mqtt Control Packet Type: %d\r\n", packetType); 
04208:  MOV     #0,W1
0420A:  MOV     W1,W0
0420C:  CLR.B   1
0420E:  CALL    1000
04212:  INC     W1,W1
04214:  BTSC.B  223.1
04216:  BRA     4214
04218:  MOV     W0,224
0421A:  MOV     #19,W0
0421C:  CPSGT   W1,W0
0421E:  BRA     420A
04220:  MOV     128C,W0
04222:  MOV     #0,W4
04224:  CALL    1620
04228:  BTSC.B  223.1
0422A:  BRA     4228
0422C:  MOV     #D,W4
0422E:  MOV     W4,224
04230:  BTSC.B  223.1
04232:  BRA     4230
04234:  MOV     #A,W4
04236:  MOV     W4,224
.................... 							memset(pubTopic, 0, mqttQuery); 
04238:  CLR     W0
0423A:  BTSC.B  1109.3
0423C:  INC     W0,W0
0423E:  MOV.B   W0L,W5L
04240:  MOV     1210,W1
04242:  MOV     #0,W2
04244:  MOV.B   W5L,W0L
04246:  CLR.B   1
04248:  DEC     W0,W0
0424A:  BRA     N,424E
0424C:  REPEAT  W0
0424E:  CLR.B   [W1++]
.................... 							//sprintf(pubTopic, "%s/temperature/value", mqttClient -> mqttClientID); 
.................... 							sprintf(pubTopic, "/devices/temperature/value"); 
04250:  PUSH    1210
04252:  POP     1476
04254:  MOV     #0,W1
04256:  MOV     W1,W0
04258:  CLR.B   1
0425A:  CALL    102C
0425E:  INC     W1,W1
04260:  MOV     W1,[W15++]
04262:  MOV     W0,[W15++]
04264:  MOV     [--W15],W0
04266:  CALL    12DE
0426A:  MOV     [--W15],W1
0426C:  MOV     #19,W0
0426E:  CPSGT   W1,W0
04270:  BRA     4256
.................... 							/*if(numOfReg == 8){ 
.................... 								temp[RTD_CHANNEL_1] = modbusRx.data[1] * 256 + modbusRx.data[2]; 
.................... 								temp[RTD_CHANNEL_2] = modbusRx.data[3] * 256 + modbusRx.data[4]; 
.................... 								temp[RTD_CHANNEL_3] = modbusRX.data[5] * 256 + modbusRx.data[6]; 
.................... 								temp[RTD_CHANNEL_4] = modbusRx.data[7] * 256 + modbusRx.data[8]; 
.................... 							}*/ 
.................... 							//memset(message, 0, sizeof(message)); 
.................... 							//sprintf(message, "Current Temperature Value: %d.%d degreeC", dataHigh[RTD_CHANNEL_4], dataLow[RTD_CHANNEL_4]); 
.................... 							//mqttPublish(0, 0, 0, generateMessageID(), pubTopic, message); 
.................... 							sprintf(json, "{\"Temp\":\"%d.%d\"}", (temp[RTD_CHANNEL_4] / 10), (temp[RTD_CHANNEL_4] % 10)); 
04272:  MOV     1474,W4
04274:  MOV     #A,W3
04276:  REPEAT  #11
04278:  DIV.U   W4,W3
0427A:  MOV     W0,W5
0427C:  MOV     1474,W4
0427E:  MOV     #A,W3
04280:  REPEAT  #11
04282:  DIV.U   W4,W3
04284:  MOV     W1,W6
04286:  MOV     #1214,W4
04288:  MOV     W4,1476
0428A:  MOV     #0,W1
0428C:  MOV     W1,W0
0428E:  CLR.B   1
04290:  CALL    1054
04294:  INC     W1,W1
04296:  MOV     W1,[W15++]
04298:  MOV     W0,[W15++]
0429A:  MOV     [--W15],W0
0429C:  CALL    12DE
042A0:  MOV     [--W15],W1
042A2:  MOV     #8,W0
042A4:  CPSGT   W1,W0
042A6:  BRA     428C
042A8:  MOV     W5,W0
042AA:  MOV     #0,W4
042AC:  CALL    3782
042B0:  MOV.B   #2E,W0L
042B2:  CALL    12DE
042B6:  MOV     W6,W0
042B8:  MOV     #0,W4
042BA:  CALL    3782
042BE:  MOV.B   #22,W0L
042C0:  CALL    12DE
042C4:  MOV.B   #7D,W0L
042C6:  CALL    12DE
.................... 							mqttPublish(0, 0, 0, generateMessageID(), pubTopic, json); 
042CA:  CALL    36AA
042CE:  MOV     W0,W5
042D0:  CLR.B   147C
042D2:  CLR.B   147D
042D4:  CLR.B   147E
042D6:  MOV     W5,1480
042D8:  PUSH    1210
042DA:  POP     1482
042DC:  MOV     #1214,W4
042DE:  MOV     W4,1484
042E0:  CALL    3888
.................... 							pubTopicFlag = false; 
042E4:  BCLR.B  1109.5
.................... 							mqttQuery = false; 
042E6:  BCLR.B  1109.3
.................... 						} 
.................... 					} 
042E8:  GOTO    42F2
.................... 					else{ 
.................... 						subTopicFlag = true; 
042EC:  BSET.B  1109.4
.................... 						pubTopicFlag = true; 
042EE:  BSET.B  1109.5
.................... 						mqttQuery = true; 
042F0:  BSET.B  1109.3
.................... 					} 
.................... 				} 
.................... 				break; 
042F2:  GOTO    43DC
.................... 			} 
.................... 			case 1:{ 
.................... 				output_high(pinControl485); 
042F6:  BCLR.B  E50.3
042F8:  BSET.B  E54.3
.................... 				if (modbusReadHoldingRegRsp(slaveID, FUNC_READ_HOLDING_REGISTERS, 40020, 4)) { 
042FA:  MOV.B   #1,W0L
042FC:  MOV.B   W0L,1478
042FE:  MOV.B   #3,W0L
04300:  MOV.B   W0L,1479
04302:  MOV     #9C54,W4
04304:  MOV     W4,147A
04306:  MOV     #4,W4
04308:  MOV     W4,147C
0430A:  CALL    3A9E
0430E:  CP0.B   W0L
04310:  BRA     Z,439C
.................... 					numOfReg = modbusRx.data[0]; 
04312:  MOV.B   1400,W0L
04314:  MOV.B   W0L,144B
.................... 					fprintf(DEBUG, "\r\nnumOfReg: %d\r\n", numOfReg); 
04316:  MOV     #0,W1
04318:  MOV     W1,W0
0431A:  CLR.B   1
0431C:  CALL    1072
04320:  INC     W1,W1
04322:  BTSC.B  223.1
04324:  BRA     4322
04326:  MOV     W0,224
04328:  MOV     #B,W0
0432A:  CPSGT   W1,W0
0432C:  BRA     4318
0432E:  MOV.B   144B,W0L
04330:  SE      W0,W0
04332:  MOV     #0,W4
04334:  CALL    1620
04338:  BTSC.B  223.1
0433A:  BRA     4338
0433C:  MOV     #D,W4
0433E:  MOV     W4,224
04340:  BTSC.B  223.1
04342:  BRA     4340
04344:  MOV     #A,W4
04346:  MOV     W4,224
.................... 					if (numOfReg == 8) { 
04348:  MOV     144A,W4
0434A:  LSR     W4,#8,W4
0434C:  CP.B    W4L,#8
0434E:  BRA     NZ,4398
.................... 						temp[RTD_CHANNEL_1] = modbusRx.data[1] * 256 + modbusRx.data[2]; 
04350:  MOV.B   1401,W0L
04352:  CLR.B   1
04354:  MOV.B   W0L,W0L
04356:  MOV.B   W0L,B
04358:  CLR.B   W5
0435A:  MOV     1402,W4
0435C:  CLR.B   9
0435E:  ADD     W5,W4,W0
04360:  MOV     W0,146E
.................... 						temp[RTD_CHANNEL_2] = modbusRx.data[3] * 256 + modbusRx.data[4]; 
04362:  MOV.B   1403,W0L
04364:  CLR.B   1
04366:  MOV.B   W0L,W0L
04368:  MOV.B   W0L,B
0436A:  CLR.B   W5
0436C:  MOV     1404,W4
0436E:  CLR.B   9
04370:  ADD     W5,W4,W0
04372:  MOV     W0,1470
.................... 						temp[RTD_CHANNEL_3] = modbusRX.data[5] * 256 + modbusRx.data[6]; 
04374:  MOV.B   1405,W0L
04376:  CLR.B   1
04378:  MOV.B   W0L,W0L
0437A:  MOV.B   W0L,B
0437C:  CLR.B   W5
0437E:  MOV     1406,W4
04380:  CLR.B   9
04382:  ADD     W5,W4,W0
04384:  MOV     W0,1472
.................... 						temp[RTD_CHANNEL_4] = modbusRx.data[7] * 256 + modbusRx.data[8]; 
04386:  MOV.B   1407,W0L
04388:  CLR.B   1
0438A:  MOV.B   W0L,W0L
0438C:  MOV.B   W0L,B
0438E:  CLR.B   W5
04390:  MOV     1408,W4
04392:  CLR.B   9
04394:  ADD     W5,W4,W0
04396:  MOV     W0,1474
.................... 					} 
.................... 				} 
04398:  GOTO    43D6
.................... 				else { 
.................... 					fprintf(debug, "*** Exception: %d ***\r\n", modbusRx.error); 
0439C:  MOV     #0,W1
0439E:  MOV     W1,W0
043A0:  CLR.B   1
043A2:  CALL    1090
043A6:  INC     W1,W1
043A8:  BTSC.B  223.1
043AA:  BRA     43A8
043AC:  MOV     W0,224
043AE:  MOV     #E,W0
043B0:  CPSGT   W1,W0
043B2:  BRA     439E
043B4:  MOV.B   13FF,W0L
043B6:  SE      W0,W0
043B8:  MOV     #0,W4
043BA:  CALL    1620
043BE:  MOV     #11,W1
043C0:  MOV     W1,W0
043C2:  CLR.B   1
043C4:  CALL    1090
043C8:  INC     W1,W1
043CA:  BTSC.B  223.1
043CC:  BRA     43CA
043CE:  MOV     W0,224
043D0:  MOV     #16,W0
043D2:  CPSGT   W1,W0
043D4:  BRA     43C0
.................... 				} 
.................... 				modbusquery = false; 
043D6:  BCLR.B  1264.6
.................... 				break; 
043D8:  GOTO    43DC
.................... 			} 
.................... 		} 
.................... 		mqttProcessing(); 
043DC:  CALL    3D8C
.................... 		mqttQuery = true; 
043E0:  BSET.B  1109.3
.................... //		subTopicFlag = true; 
.................... 		pubTopicFlag = true; 
043E2:  BSET.B  1109.5
043E4:  GOTO    4192
.................... 	} 
.................... 	return; 
.................... } 
043E8:  PWRSAV  #0

Configuration Fuses:
   Word  3L: 0003   NOWRT NOPROTECT NOGSSK
          H: FF00  
   Word  4L: 0080   FRC IESO
          H: FF00  
   Word  5L: 0026   HS NOOSCIO IOL1WAY CKSFSM
          H: FF00  
   Word  6L: 007F   WPOSTS16 WPRES128 PLLWAIT WINDIS NOWDT
          H: FF00  
   Word  7L: 0037   PUT128 NOBROWNOUT NOALTI2C1
          H: FF00  
   Word  8L: 00D7   ICSP1 RESET_PRIMARY NOJTAG NODEBUG
          H: FF00  
   Word  9L: 0003   NOAWRT NOAPROTECT NOAPLK
          H: FF00  
